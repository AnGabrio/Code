<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andrea Gabrio">
<meta name="dcterms.date" content="2025-11-18">

<title>Statistical methods for model-based HTA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="code2_files/libs/clipboard/clipboard.min.js"></script>
<script src="code2_files/libs/quarto-html/quarto.js"></script>
<script src="code2_files/libs/quarto-html/popper.min.js"></script>
<script src="code2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="code2_files/libs/quarto-html/anchor.min.js"></script>
<link href="code2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="code2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="code2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="code2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="code2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Statistical methods for model-based HTA</h1>
<p class="subtitle lead">Part I</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://angabrio.github.io/agabriosite2/">Andrea Gabrio</a> <a href="mailto:a.gabrio@maastrichtuniversity.nl" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0002-7650-4534" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <a href="https://www.maastrichtuniversity.nl/research/methodology-and-statistics">
            Maastricht University
            </a>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This document provides the full code used to simulate some artificial model-based HTA data and implement different types of statistical methods to analyse them. The methods listed here are based on a selection made according to recommendations from the current literature <span class="citation" data-cites="el2022scoping">(<a href="#ref-el2022scoping" role="doc-biblioref">El Alili et al. 2022</a>)</span> and national guidelines from the <em>ZorgInstituut Nederland</em><span class="citation" data-cites="nederland2024guideline">(<a href="#ref-nederland2024guideline" role="doc-biblioref">Nederland 2024</a>)</span> about the statistical analysis of (empirical) trial-based health economic evaluations in the Netherlands.</p>
<p>The code is presented with some comments and brief descriptions using an HTML interface generated via <a href="https://quarto.org/"><em>quarto</em></a> and <a href="https://posit.co/download/rstudio-desktop/"><em>Rstudio</em></a> to ease accessibility. The raw code is provided in a separate file in the same <a href="https://github.com/AnGabrio/Code/tree/master/RHTAmethods">GitHub repository</a>.</p>
<section id="sec-dtm" class="level1">
<h1>Decision Tree Models</h1>
<section id="basic-elements" class="level2">
<h2 class="anchored" data-anchor-id="basic-elements">Basic elements</h2>
<p>Perhaps one of the simplest and most popular types of <em>decision-analytic models</em> in HTA is represented by <strong>decision tree</strong><span class="citation" data-cites="briggs2006decision">(<a href="#ref-briggs2006decision" role="doc-biblioref">A. Briggs, Sculpher, and Claxton 2006</a>)</span>. These are used to graphically display a tree structure in which alternative future possibilities are represented by distinct and mutually exclusive “branches”. To introduce the underlying idea of decision trees, let’s consider a simple example where two treatments are compared with a do-nothing option: “Trt A”, “Trt B”, and “None” (eg take no drugs). Each treatment has different costs and benefits in terms of chances that the drug is successful at treating a patient.</p>
<p>Within a decision tree, usually, there are different types of “nodes” which may have different interpretations:</p>
<ul>
<li><p><strong>Decision nodes</strong>: these are places at the root of the tree (often represented as squares) from which a set of branches develop, each representing alternative treatment choices that patients may take.</p></li>
<li><p><strong>Chance nodes</strong>: these are associated with an estimated probability (often represented as circles) which represents the chance of a random event to occur (eg whether a treatment was successful or not).</p></li>
<li><p><strong>Terminal nodes</strong>: these are placed at the end of each branch path (often represented as triangles and called <em>leaves</em>) and are associated with a given <em>value</em> (eg costs and/or benefits).</p></li>
</ul>
<p>The term “value” refers to the numbers attached to the nodes, which usually consist in cost (<span class="math inline">\(c_i\)</span>) and benefit (<span class="math inline">\(e_i\)</span>) measures associated to each node <span class="math inline">\(i\)</span>. The term “probability” refers to the chance at a given node for a given random event to occur, and should therefore be considered as <em>conditional probabilities</em> denoted as <span class="math inline">\(p_{ij}=p(x_j\mid x_i)\)</span>, representing the probability that the event <span class="math inline">\(x_j\)</span> occurs given an already occurred event <span class="math inline">\(x_i\)</span>. Within a decision tree, the existence of conditional probabilities means that the probability of going through a branch depends on what occurred at a previous node. Given that all possible outcomes at a specific node need to be explicitly defined, this means that the probabilities on branches from a chance node must sum up to one.</p>
<p>A decision tree is often used to describe underlying disease natural history and typical treatment outcomes as it allows to easily quantify the risks and payoffs associated with different courses of action <span class="citation" data-cites="caro2012modeling">(<a href="#ref-caro2012modeling" role="doc-biblioref">Caro et al. 2012</a>)</span>. Essentially, decision trees show alternative clinical pathways where discrete decisions and related payoffs occur in sequence in short time frames. However, they are not well suited for simulations with considerable gaps between treatment decisions and realisation of the payoffs. In addition, the influence of time cannot be easily incorporated in decision trees. Finally, when the possibility of returning to past nodes is non-zero (eg recovery from illness after starting in an healthy state), this needs to be taken into account in the model. Although this might be possible to incorporate in a decision tree, the required increase in the number of nodes and general tree structure makes the adoption of alternative modelling approaches (eg Markov Models) more appropriate choices to simulate the disease progression.</p>
</section>
<section id="calculations" class="level2">
<h2 class="anchored" data-anchor-id="calculations">Calculations</h2>
<p>The probabilities computed along each branch of the tree are conditional probabilities <span class="math inline">\(p(x_j\mid x_i)\)</span>, which is important to remember when calculating the expected cost and benefit values associated to each end node. It is possible to think of a unique pathway from the root node until reaching a given terminal node, where at each encountered chance node one of the possible outcomes occurs. By chaining the conditional probabilities for a given pathway it is possible to obtain the total or <em>joint probability</em> of reaching a given terminal node. As an example, let’s define <span class="math inline">\(x\)</span> as the event variable representing the occurrence of a pathway based on a tree with length <span class="math inline">\(n\)</span> nodes:</p>
<p><span class="math display">\[
x_{[1]} \rightarrow x_{[2]} \rightarrow \cdots \rightarrow x_{[n]}
\]</span> where <span class="math inline">\(x_{[1]}\)</span> is the root node, <span class="math inline">\(x_{[n]}\)</span> is the terminal node, with the notation <span class="math inline">\(x_{[i]}\)</span> denoting the <span class="math inline">\(i\)</span>-th ordered node in the sequence. We can express the joint probability of this path as the product of the conditional probabilities which sit on this path:</p>
<p><span class="math display">\[
p(x_{[1]},\ldots,x_{[n]})=p(x_{[2]}\mid x_{[1]}) \times \cdots \times p(x_{[n]}\mid x_{[n-1]})=\prod_{i=1}^{n-1}p(x_{[i+1]}\mid x_{[i]}).
\]</span> The corresponding cost and benefit values associated with this pathway would then correspond to the respective set of payoffs <span class="math inline">\(c=(c_{[1]},\ldots,c_{[n]})\)</span> and <span class="math inline">\(e=(e_{[1]},\ldots,e_{[n]})\)</span>. Identifying the optimal pathway alongside a decision tree is often called <em>solving</em> the tree, which requires to calculate the expected values of each decision. In general, there are two approaches to achieve this.</p>
<ol type="1">
<li><strong>Backwards computation</strong>. The first approach is to work backwards taking a weighted average of the total values of the successive (child) nodes of a given past (parent) node, where the weights are the probability to go through each branch to the child nodes. The expected value at node <span class="math inline">\(i\)</span> is given by:</li>
</ol>
<p><span class="math display">\[
\text{E}[V_i]=\Biggl\{ \begin{array}{cc}o_i &amp; \text{if} \;\; i \in N_t\\ o_i+\sum_{j\in \text{child}(i)}p_{ij}\text{E}[V_j] &amp; \text{otherwise} \end{array}
\]</span> where <span class="math inline">\(\text{E}[\cdot]\)</span> denotes the expected average of the values <span class="math inline">\(o_i\)</span> occurred at node <span class="math inline">\(i\)</span>, <span class="math inline">\(\text{child}(i)\)</span> is the set of child nodes from node <span class="math inline">\(i\)</span>, and <span class="math inline">\(N_t\)</span> is the set of all terminal nodes. Thus, <span class="math inline">\(V_i\)</span> is the total value at a node consisting of <span class="math inline">\(o_i\)</span> and the values of the child nodes along a trajectory. In short, starting at the terminal nodes the expected costs and benefits at each chance node are calculated in turn all the way back to the decision node. An advantage of using this approach is that total expected values can be obtained at each node and, in the presence of multiple decision nodes, it is possible to fold-back sub-trees.</p>
<ol start="2" type="1">
<li><strong>Forward computation</strong>. The second approach is to calculate total costs, benefits and joint probabilities along all of the distinct pathways of the tree corresponding to a decision. The weighted average of the costs and benefits give the expected value at the decision node:</li>
</ol>
<p><span class="math display">\[
\text{E}[V]=\sum_{j=1}^m o_j^\star p_j^\star,
\]</span> where <span class="math inline">\(o_j^\star=(o_{[1]},\ldots,o_{[n_j]})\)</span> is the sum total of the values along each pathway for <span class="math inline">\(j=1,\ldots,m\)</span> and of length <span class="math inline">\(n_j\)</span>, while <span class="math inline">\(p_j^\star\)</span> is the associated joint probability set of going through the path.</p>
<p>Using the expected outcomes for different decisions calculated at the decision nodes in the tree, it is possible to determine the optimal course of action to obtain the maximum expected benefit. Expected outcomes are often expressed in terms of incremental means between two competing treatments in terms of some benefit measure (eg QALYs) <span class="math inline">\(\Delta_e=\text{E}[e\mid \text{trt}_2]-\text{E}[e\mid \text{trt}_1]\)</span> and costs <span class="math inline">\(\Delta_c=\text{E}[c\mid \text{trt}_2]-\text{E}[c\mid \text{trt}_1]\)</span>. These quantities are then often combined in order to derive standard cost-effectiveness measures, such as the <em>Incremental Cost-Effectiveness Ratio</em> (ICER) and the <em>Incremental Net Monetary Benefit</em> (INMB), in combination with a pre-specified value for the <em>acceptance</em> or <em>willingness to pay threshold</em> (wtp) fixed by the decision maker to inform the decision about the relative cost-effectiveness of the competing treatments.</p>
</section>
<section id="sensitivity-analysis" class="level2">
<h2 class="anchored" data-anchor-id="sensitivity-analysis">Sensitivity Analysis</h2>
<p>A final element that should be considered is the need to quantify the uncertainty around the modelling process, which is an indispensable component when conducting HTA <span class="citation" data-cites="briggs2012model">(<a href="#ref-briggs2012model" role="doc-biblioref">A. H. Briggs et al. 2012</a>)</span>. This means that measures of uncertainty around point estimates, including probabilities, outcome values, etc…, need to be provided to better inform decision making. In the literature, uncertainty is often divided into two main groups: <em>stochastic</em> and <em>parameter</em>. Stochastic uncertainty relates to the uncertainty around a realisation at the individual level, while parameter uncertainty is associated with the uncertainty around the model input parameters. In general, HTA is primarily concerned with parameter uncertainty given that the focus is on population averages rather than at the individual level.</p>
<p>There are different approaches to explore the impact of uncertainty on the model results, an exercise often referred to as <em>sensitivity analysis</em>. A first approach, called <strong>Deterministic Sensitivity Analysis</strong> (DSA) consists in varying parameter values to test the sensitivity of the model outputs to specific sets of parameter values. Alternatively, a <strong>Probabilistic Sensitivity Analysis</strong> (PSA) varies all parameter values simultaneously by sampling them from probability distributions, and is often preferred to DSA since it allows to assess the impact of uncertainty around all relevant parameters in a joint way. In practice, conducting PSA means that for a given sequence of iterations <span class="math inline">\(s=1,\ldots,S\)</span>, a value of all random inputs <span class="math inline">\(\theta_{(s)}\)</span> is simulated from a given distribution <span class="math inline">\(p(\theta)\)</span>. The decision tree is then run with these values and a distribution for the expected incremental costs and benefits are calculated <span class="citation" data-cites="baio2015probabilistic">(<a href="#ref-baio2015probabilistic" role="doc-biblioref">Baio and Dawid 2015</a>)</span>. That is, we obtain samples of pairs <span class="math inline">\((\Delta_e^{(s)},\Delta_c^{(s)})\)</span>, where <span class="math inline">\(\Delta_e^{(s)}=\text{E}[e\mid \theta_{(s)}, \text{trt}_2]-\text{E}[e\mid \theta_{(s)},\text{trt}_1]\)</span> and <span class="math inline">\(\Delta_c^{(s)}=\text{E}[c\mid \theta_{(s)}, \text{trt}_2]-\text{E}[c\mid \theta_{(s)},\text{trt}_1]\)</span>.</p>
</section>
<section id="implementation-in-r" class="level2">
<h2 class="anchored" data-anchor-id="implementation-in-r">Implementation in <code>R</code></h2>
<p>In this section I will show how to implement a simple decision tree model in <code>R</code> using first a forward and then a backwards computation approach to generate the output under both a point value and PSA scenario.</p>
<section id="forward-computation" class="level3">
<h3 class="anchored" data-anchor-id="forward-computation">Forward computation</h3>
<p>We start by setting the number of treatments and their names together with empty objects that will be filled with costs, benefits and probabilities of movement between nodes once calculations are performed.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#trt names and number</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>trt_names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Trt1"</span>,<span class="st">"Trt2"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>n_trt <span class="ot">&lt;-</span> <span class="fu">length</span>(trt_names)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#objects to contain outcomes and probabilities</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>c_success <span class="ot">&lt;-</span> c_fail <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="cn">NA</span>, n_trt), trt_names)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>e_success <span class="ot">&lt;-</span> e_fail <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="cn">NA</span>, n_trt), trt_names)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>p_success <span class="ot">&lt;-</span> p_fail <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="cn">NA</span>, n_trt), trt_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next, we fill in the created objects based on some external information (eg obtained from the literature)</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#assign values to each state and trt group</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#QALYs</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>e_success[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="dv">35</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>e_fail[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="dv">15</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>e_success[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="dv">26</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>e_fail[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="dv">22</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Costs</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>c_success[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="dv">15000</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>c_fail[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="dv">35000</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>c_success[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="dv">7000</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>c_fail[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="dv">13000</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">#for costs also add some initial costs</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>c_init <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Trt1"</span><span class="ot">=</span><span class="dv">3000</span>, <span class="st">"Trt2"</span><span class="ot">=</span><span class="dv">500</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">#probs</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>p_success[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="fl">0.75</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>p_fail[<span class="st">"Trt1"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> p_success[<span class="st">"Trt1"</span>] <span class="co">#events are mutually exclusive</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>p_success[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="fl">0.93</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>p_fail[<span class="st">"Trt2"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> p_success[<span class="st">"Trt2"</span>] <span class="co">#events are mutually exclusive</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty objects to contain total outcomes</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>c_tot <span class="ot">&lt;-</span> e_tot <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="cn">NA</span>, n_trt), trt_names)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>c_delta <span class="ot">&lt;-</span> e_delta <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">rep</span>(<span class="cn">NA</span>, n_trt), trt_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once this is done, we can now perform the forward calculation.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute path joint probabilities</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>p_star <span class="ot">&lt;-</span> <span class="fu">rbind</span>(p_success,p_fail)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#path total costs</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>c_star <span class="ot">&lt;-</span> <span class="fu">cbind</span>(c_init <span class="sc">+</span> c_success <span class="sc">+</span> c_fail)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#path total QALYs</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>e_star <span class="ot">&lt;-</span> <span class="fu">cbind</span>(e_success <span class="sc">+</span> e_fail)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">#compute the sum of each product term to obtain total expected values</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">#EV in terms of total costs and QALYs for each trt group</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(c_star[<span class="st">"Trt1"</span>, ]<span class="sc">*</span>p_star[, <span class="st">"Trt1"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 53000</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(c_star[<span class="st">"Trt2"</span>, ]<span class="sc">*</span>p_star[, <span class="st">"Trt2"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 20500</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(e_star[<span class="st">"Trt1"</span>, ]<span class="sc">*</span>p_star[, <span class="st">"Trt1"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 50</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(e_star[<span class="st">"Trt2"</span>, ]<span class="sc">*</span>p_star[, <span class="st">"Trt2"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 48</code></pre>
</div>
</div>
<p>Given the simple structure of the decision tree, we may also obtain the total costs and QALYs for each group by directly writing the respective equations in vector format. Similarly, we can compute the incremental quantities assuming <code>Trt2</code> being the comparator and <code>Trt1</code> the reference intervention.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#for total costs c_init not in brackets since they apply to both pathways</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>c_tot <span class="ot">&lt;-</span> c_init <span class="sc">+</span> (p_success<span class="sc">*</span>c_success <span class="sc">+</span> p_fail<span class="sc">*</span>c_fail)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>e_tot <span class="ot">&lt;-</span> (p_success<span class="sc">*</span>e_success <span class="sc">+</span> p_fail<span class="sc">*</span>e_fail)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#incrementals</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>c_delta <span class="ot">&lt;-</span> c_tot[<span class="st">"Trt1"</span>]<span class="sc">-</span>c_tot[<span class="st">"Trt2"</span>]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>e_delta <span class="ot">&lt;-</span> e_tot[<span class="st">"Trt1"</span>]<span class="sc">-</span>e_tot[<span class="st">"Trt2"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Finally, we can compute the ICER and INMB based on the incremental quantities, assuming a certain value for the acceptance threshold parameter <span class="math inline">\(k\)</span>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">20000</span> <span class="co">#wtp (costs per QALY gained)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>icer <span class="ot">&lt;-</span> c_delta<span class="sc">/</span>e_delta</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>inmb <span class="ot">&lt;-</span> e_delta<span class="sc">*</span>k <span class="sc">-</span> c_delta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The ICER is <span class="math inline">\(3523\)</span> refers to the additional cost (eg in euros) per unit of QALY gained when using the reference treatment with respect to the comparator. Given that its value is below the assumed value for <span class="math inline">\(k=2\times 10^{4}\)</span>, then we may conclude that the reference intervention is cost-effective at the given <span class="math inline">\(k\)</span>. Similarly, we may arrive to the same conclusion by looking at the INMB which is <span class="math inline">\(7.052\times 10^{4}\)</span>: since its value is positive, at the assumed value for <span class="math inline">\(k=2\times 10^{4}\)</span>, we conclude that the reference intervention is cost-effective.</p>
<p>Once the results from a point value scenario are derived (as we did so far), then it is important to extend the model to perform a PSA by replacing point estimates for outcomes and probabilities with <span class="math inline">\(S\)</span> random samples drawn from appropriate probability distributions. For this simple example, we will fix the probability point values associated with branches from chance nodes. We will instead draw cost and QALY samples from Gamma distributions centred around the point estimates used before, ie <span class="math inline">\(\sim \text{Gamma}(\phi,\psi)\)</span>. For the given simulation size <span class="math inline">\(S\)</span>, we can then obtain the draws <span class="math inline">\(c_{\text{init},(s)}\)</span> separately for the two treatments and for <span class="math inline">\(s=1\ldots,S\)</span> by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="dv">200</span> <span class="co">#set total number of simulations</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#generate initial cost samples for each treatment</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>c_init_psa <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#choice of Gamma parameters here made to obtain distribution centred around means used before</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#in practice these values need to be defined based on the context</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_init[<span class="st">"Trt1"</span>]<span class="sc">/</span><span class="dv">500</span>, <span class="at">scale =</span> <span class="dv">500</span>),</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_init[<span class="st">"Trt2"</span>]<span class="sc">/</span><span class="dv">670</span>, <span class="at">scale =</span> <span class="dv">670</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">#this results in a matrix with trt groups on rows and samples on columns</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can then create the other cost and QALY samples in the same way</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>c_success_psa <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_success[<span class="st">"Trt1"</span>]<span class="sc">/</span><span class="dv">100</span>, <span class="at">scale =</span> <span class="dv">100</span>),</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_success[<span class="st">"Trt2"</span>]<span class="sc">/</span><span class="dv">60</span>, <span class="at">scale =</span> <span class="dv">60</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>c_fail_psa <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_fail[<span class="st">"Trt1"</span>]<span class="sc">/</span><span class="dv">200</span>, <span class="at">scale =</span> <span class="dv">200</span>),</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> c_fail[<span class="st">"Trt2"</span>]<span class="sc">/</span><span class="dv">110</span>, <span class="at">scale =</span> <span class="dv">110</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>e_success_psa <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> e_success[<span class="st">"Trt1"</span>]<span class="sc">/</span><span class="fl">0.3</span>, <span class="at">scale =</span> <span class="fl">0.3</span>),</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> e_success[<span class="st">"Trt2"</span>]<span class="sc">/</span><span class="fl">0.37</span>, <span class="at">scale =</span> <span class="fl">0.37</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>e_fail_psa <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> e_fail[<span class="st">"Trt1"</span>]<span class="sc">/</span><span class="fl">0.6</span>, <span class="at">scale =</span> <span class="fl">0.6</span>),</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span> <span class="ot">=</span> <span class="fu">rgamma</span>(<span class="at">n=</span>S, <span class="at">shape =</span> e_fail[<span class="st">"Trt2"</span>]<span class="sc">/</span><span class="fl">0.4</span>, <span class="at">scale =</span> <span class="fl">0.4</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If vectorisation is done correctly, we may then use the same code as in the point value case to obtain total and incremental quantities.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#for total costs c_init not in brackets since they apply to both pathways</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>c_tot_psa <span class="ot">&lt;-</span> c_init_psa <span class="sc">+</span> (p_success<span class="sc">*</span>c_success_psa <span class="sc">+</span> p_fail<span class="sc">*</span>c_fail_psa)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>e_tot_psa <span class="ot">&lt;-</span> (p_success<span class="sc">*</span>e_success_psa <span class="sc">+</span> p_fail<span class="sc">*</span>e_fail_psa)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">#incrementals</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>c_delta_psa <span class="ot">&lt;-</span> c_tot_psa[<span class="st">"Trt1"</span>,]<span class="sc">-</span>c_tot_psa[<span class="st">"Trt2"</span>,]</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>e_delta_psa <span class="ot">&lt;-</span> e_tot_psa[<span class="st">"Trt1"</span>,]<span class="sc">-</span>e_tot_psa[<span class="st">"Trt2"</span>,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In comparison with the point value case shown before, we now calculate standard HTA measures by taking the average of the incrementals across the <span class="math inline">\(S\)</span> samples generated.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>icer_psa <span class="ot">&lt;-</span> <span class="fu">mean</span>(c_delta_psa)<span class="sc">/</span><span class="fu">mean</span>(e_delta_psa)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>inmb_psa <span class="ot">&lt;-</span> <span class="fu">mean</span>(e_delta_psa)<span class="sc">*</span>k <span class="sc">-</span> <span class="fu">mean</span>(c_delta_psa)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The ICER is now estimated as <span class="math inline">\(3785\)</span> while the INMB is <span class="math inline">\(6.4173\times 10^{4}\)</span>, therefore still suggesting the cost-effectiveness of the reference treatment, on average. However, one of the main reasons to perform PSA is precisely to assess the level of uncertainty around this conclusion, which is only based on average values. Using the <span class="math inline">\(S\)</span> samples for both incremental quantities, we can now produce standard HTA probabilistic outputs such as the <em>cost-effectiveness plane</em> (CE plane) and the <em>cost-effectiveness acceptability curve</em> (CEAC) to better inform the decision maker about the <em>chance</em> that the reference intervention is cost-effective, for a given or a range of values of the acceptance threshold parameter. These graphs can be easily drawn using functions from the <code>R</code> package <code>BCEA</code>. As an example, CE plane and CEAC plots may be computed using the following commands</p>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(BCEA) <span class="co">#load package</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">#use main function to generate CEA output</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>bcea_cea <span class="ot">&lt;-</span> <span class="fu">bcea</span>(<span class="at">eff=</span><span class="fu">t</span>(e_tot_psa), <span class="at">cost=</span><span class="fu">t</span>(c_tot_psa), <span class="at">interventions =</span> <span class="fu">c</span>(<span class="st">"Trt1"</span>,<span class="st">"Trt2"</span>), <span class="at">ref=</span><span class="dv">1</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">#scatter plot of delta_e and delta_c with assumed value k for wtp</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">#points in shaded area  / total points = prob of cost-effectiveness at k</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="fu">ceplane.plot</span>(bcea_cea, <span class="at">wtp =</span> k)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">#prob of cost-effectiveness for a range of wtp values</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="fu">ceac.plot</span>(bcea_cea)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-1-1" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-1-1.png" id="fig-1-1" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-1-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1
</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-1-2" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-1-2.png" id="fig-1-2" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-1-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2
</figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="backwards-computation" class="level2">
<h2 class="anchored" data-anchor-id="backwards-computation">Backwards computation</h2>
<p>Because the backwards computation of a decision tree is a recursive process, we will use a recursive function to apply this approach. This might seem less clear compared to a forward approach but it has the advantage of facilitating solutions of decision trees that are more complex. The remainder of the code for this section will be folded as it is just an alternative way to implement decision trees, but the interested reader is free to open the folded parts contained in this section to see how the backwards computation may also be performed.</p>
<p>In <code>R</code>, backwards computation can be achieved through two alternative methods: an <em>adjacency matrix</em> or <em>adjacency list</em>, the choice depending on the structure of the tree under consideration. In the following example, an adjacency list will be used, where the list names and associated vectors denote the parent node indices of the tree. In <code>R</code>, we begin by defining the tree structure as follows:</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">#define tree</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"1"</span><span class="ot">=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="co">#root node</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>             <span class="st">"2"</span><span class="ot">=</span><span class="fu">c</span>(), <span class="co">#terminal node</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>             <span class="st">"3"</span><span class="ot">=</span><span class="fu">c</span>()) <span class="co">#terminal node </span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>tree</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$`1`
[1] 2 3

$`2`
NULL

$`3`
NULL</code></pre>
</div>
</div>
<p>where the <code>tree</code> object represents the information that node 1 has children nodes 2 and 3, while nodes 2 and 3 have no children (ie they are terminal nodes). Next, we provide the probabilities, costs and QALYs for this tree by creating a list of data frames, separately by treatment group, which are meant to contain information about “node”, “probability”, and “value”. This is needed in order to loop over different treatment scenarios through the recursive function.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">#define data frames for nodes, probs and outcomes for each trt group</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">#re-use success and fail vectors from previous method to define elements of data frames</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">#costs</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>data_c_recur <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="co">#node index</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt1"</span>], p_fail[<span class="st">"Trt1"</span>]),  <span class="co">#prob of success-fail at each node</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(c_init[<span class="st">"Trt1"</span>],c_success[<span class="st">"Trt1"</span>],c_fail[<span class="st">"Trt1"</span>]) <span class="co">#values for each node</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt2"</span>], p_fail[<span class="st">"Trt2"</span>]),  </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(c_init[<span class="st">"Trt2"</span>],c_success[<span class="st">"Trt2"</span>],c_fail[<span class="st">"Trt2"</span>])</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>  )  </span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co">#QALYs</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>data_e_recur <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt1"</span>], p_fail[<span class="st">"Trt1"</span>]),  </span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(<span class="dv">0</span>,e_success[<span class="st">"Trt1"</span>],e_fail[<span class="st">"Trt1"</span>])</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt2"</span>], p_fail[<span class="st">"Trt2"</span>]),  </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(<span class="dv">0</span>,e_success[<span class="st">"Trt2"</span>],e_fail[<span class="st">"Trt2"</span>])</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>  )  </span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>For example, the cost list of data frames (one for each treatment group) looks something like this.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$Trt1
  node prob  vals
1    1   NA  3000
2    2 0.75 15000
3    3 0.25 35000

$Trt2
  node prob  vals
1    1   NA   500
2    2 0.93  7000
3    3 0.07 13000</code></pre>
</div>
</div>
<p>Note that the root node is assigned a probability of <code>NA</code> in the code, since it has no preceding nodes. Next, the recursive function needs to be coded for calculating the expected values at a node, and here this is done by assuming a binary tree structure (ie success/failure chance at each node). The function <code>ev_rec()</code> takes the current node, tree structure and data for the values and probabilities as inputs and checks whether the current node is a terminal one. If this is true, the function returns the value at the node; otherwise the function calculates, recursively for each child node, the expected value of the children nodes and returns the sum of the current node and the weighted sum of the expected values of the children nodes</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">#define function</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>ev_rec <span class="ot">&lt;-</span> <span class="cf">function</span>(node, tree, data){</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">#if terminal node return 0</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.na</span>(node)){</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="dv">0</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">#else</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract values at current node</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  c_node <span class="ot">&lt;-</span> data<span class="sc">$</span>vals[data<span class="sc">$</span>node<span class="sc">==</span>node]</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check tree structure starting from current node</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  child <span class="ot">&lt;-</span> tree[[node]]</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">#if terminal node return current node </span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(child)){</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(c_node)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { </span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#else extract probs along each branch (binary tree structure)</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    pL <span class="ot">&lt;-</span> data<span class="sc">$</span>prob[data<span class="sc">$</span>node<span class="sc">==</span>child[<span class="dv">1</span>]] <span class="co">#left branch</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    pR <span class="ot">&lt;-</span> data<span class="sc">$</span>prob[data<span class="sc">$</span>node<span class="sc">==</span>child[<span class="dv">2</span>]] <span class="co">#right branch</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">#check for NA values and if so set probs to 0</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">any</span>(<span class="fu">is.na</span>(pL))) {pL <span class="ot">&lt;-</span> <span class="dv">0</span>}</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">any</span>(<span class="fu">is.na</span>(pR))) {pR <span class="ot">&lt;-</span> <span class="dv">0</span>}</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">#re-apply the function to children from current node and return sum of values from current node</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">#along the branches of the tree until a terminal node is found</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(c_node<span class="sc">+</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>             pL<span class="sc">*</span><span class="fu">ev_rec</span>(child[<span class="dv">1</span>],tree,data) <span class="sc">+</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>             pR<span class="sc">*</span><span class="fu">ev_rec</span>(child[<span class="dv">2</span>],tree,data)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>           )</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>When applied to out simple example, the application of <code>ev_rec()</code> to the tree object defined in <code>tree</code> produces, at the first iteration, the cost at the starting node together with the probabilities (of success and failure) associated with the current node’s children. The current cost is then added to the weighted mean of the expected costs of the two children nodes. These expected costs are calculated in the same way as for the starting node, thus producing a recursive procedure. This continues until a node without children is found (terminal node), for which only the current costs are returned since the weighted costs of the children (none) are set to 0.</p>
<p>We apply the recursive function separately for costs and QALYs, passing the data for the particular branch values</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>root <span class="ot">&lt;-</span> <span class="fu">names</span>(tree)[<span class="dv">1</span>] <span class="co">#index of root node</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">#define empty objects to contain outcomes computed recursively</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>c_tot_recur <span class="ot">&lt;-</span> e_tot_recur <span class="ot">&lt;-</span> <span class="fu">setNames</span>(</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">vector</span>(<span class="at">mode=</span><span class="st">"numeric"</span>, <span class="at">length =</span> <span class="dv">2</span>L),</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">"Trt1"</span>,<span class="st">"Trt2"</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to extract total cost and QALY outcomes by trt group from the tree using recursive function and store results into new objects</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  c_tot_recur[i] <span class="ot">&lt;-</span> <span class="fu">ev_rec</span>(<span class="at">node =</span> root, tree, data_c_recur[[i]]) </span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  e_tot_recur[i] <span class="ot">&lt;-</span> <span class="fu">ev_rec</span>(<span class="at">node =</span> root, tree, data_e_recur[[i]]) </span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can alternatively calculate the total cost and QALYs for both treatment groups in a single step by looping over the inputs. Although this can also be done using base <code>R</code> commands, here we use the function <code>map_dbl()</code> from the <code>purrr</code> package to facilitate the looping through the list of inputs.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr) <span class="co">#load package</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">#loop over cost and QALY inputs for each node in the tree </span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">#computed recursively using the ev_rec function </span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>c_tot_rec <span class="ot">&lt;-</span> <span class="fu">map_dbl</span>(</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#inputs: value data frames by group recursive function</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#~ and . used to tell that function is applied to each output produced by itlsef at previous node</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  data_c_recur, <span class="sc">~</span> <span class="fu">ev_rec</span>(<span class="at">node=</span>root, tree, .) </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>e_tot_rec <span class="ot">&lt;-</span> <span class="fu">map_dbl</span>(</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  data_e_recur, <span class="sc">~</span> <span class="fu">ev_rec</span>(<span class="at">node=</span>root, tree, .)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next, using these outcomes, we can calculate the incremental costs and QALYs, and any other HTA measures (eg ICER), as we did in the forward computation approach.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>c_delta_rec <span class="ot">&lt;-</span> c_tot_recur[<span class="st">"Trt1"</span>] <span class="sc">-</span> c_tot_recur[<span class="st">"Trt2"</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>e_delta_rec <span class="ot">&lt;-</span> e_tot_recur[<span class="st">"Trt1"</span>] <span class="sc">-</span> e_tot_recur[<span class="st">"Trt2"</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>icer_rec <span class="ot">&lt;-</span> c_delta_rec<span class="sc">/</span>e_delta_rec</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The ICER is <span class="math inline">\(3523\)</span> as computed using the forward approach. Finally, as done for the forward computation approach, I also provide below the code (folded) for embedding the recursive computation within a Monte Carlo sampling procedure to produce the output needed for a PSA. To make things simple, I have re-used the same PSA samples generated for the forward approach for <span class="math inline">\(S=200\)</span> and assuming point values for all movement probabilities between nodes. Since I used the same PSA samples generated for the forward approach, the same CE results will be produced (eg ICER value based on PSA samples).</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">#apply recursive computation for PSA</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">#step 1: generate cost and QALY samples for each treatment using appropriate distributions for a given number of iterations S and create 2xS matrix objects to contain the samples. Here I re-use the same objects created for the forward computation PSA example using Gamma distributions, namely: c_init_psa, c_success_psa, c_fail_psa, e_success_psa, e_fail_psa </span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">#step 2: define empty Sx2 matrix objects to contain outcomes computed recursively for each treatment at each iteration of the PSA procedure</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>c_tot_recur_psa <span class="ot">&lt;-</span> e_tot_recur_psa <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>,<span class="at">nrow =</span> S, <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">dimnames =</span> <span class="fu">list</span>(<span class="cn">NULL</span>, <span class="fu">c</span>(<span class="st">"Trt1"</span>, <span class="st">"Trt2"</span>)))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="co">#step 3: embed the recursive procedure applied for the point value case within a loop going over the S PSA iterations and store the results in the outcome matrix objects created before </span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(s <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>S){ <span class="co">#loop over PSA iterations</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  data_c_recur <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="co">#node index</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt1"</span>], p_fail[<span class="st">"Trt1"</span>]),</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(c_init_psa[<span class="st">"Trt1"</span>,s],c_success_psa[<span class="st">"Trt1"</span>,s],c_fail_psa[<span class="st">"Trt1"</span>,s]) </span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt2"</span>], p_fail[<span class="st">"Trt2"</span>]),  </span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(c_init_psa[<span class="st">"Trt2"</span>,s],c_success_psa[<span class="st">"Trt2"</span>,s],c_fail_psa[<span class="st">"Trt2"</span>,s])</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>  )  </span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>data_e_recur <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt1"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt1"</span>], p_fail[<span class="st">"Trt1"</span>]),  </span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(<span class="dv">0</span>,e_success_psa[<span class="st">"Trt1"</span>,s],e_fail_psa[<span class="st">"Trt1"</span>,s])</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Trt2"</span><span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>    <span class="at">node=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">prob=</span><span class="fu">c</span>(<span class="cn">NA</span>,p_success[<span class="st">"Trt2"</span>], p_fail[<span class="st">"Trt2"</span>]),  </span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="at">vals=</span><span class="fu">c</span>(<span class="dv">0</span>,e_success_psa[<span class="st">"Trt2"</span>,s],e_fail_psa[<span class="st">"Trt2"</span>,s])</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>  )  </span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to extract total cost and QALY outcomes by trt group from the tree using recursive function and store results into new objects for each PSA sample s and treatment group i</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>  c_tot_recur_psa[s,i] <span class="ot">&lt;-</span> <span class="fu">ev_rec</span>(<span class="at">node =</span> root, tree, data_c_recur[[i]]) </span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>  e_tot_recur_psa[s,i] <span class="ot">&lt;-</span> <span class="fu">ev_rec</span>(<span class="at">node =</span> root, tree, data_e_recur[[i]]) </span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a><span class="co">#step 4: compute cost and QALY incrementals for each PSA sample</span></span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>c_delta_rec_psa <span class="ot">&lt;-</span> c_tot_recur_psa[,<span class="st">"Trt1"</span>] <span class="sc">-</span> c_tot_recur_psa[,<span class="st">"Trt2"</span>]</span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a>e_delta_rec_psa <span class="ot">&lt;-</span> e_tot_recur_psa[,<span class="st">"Trt1"</span>] <span class="sc">-</span> e_tot_recur_psa[,<span class="st">"Trt2"</span>]</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a><span class="co">#compute ICER based on S PSA samples as ratio of mean incrementals</span></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a>icer_rec_psa <span class="ot">&lt;-</span> <span class="fu">mean</span>(c_delta_rec_psa)<span class="sc">/</span><span class="fu">mean</span>(e_delta_rec_psa)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>Decision trees are not appropriate where the disease exhibits long latencies after a clinical intervention or where conditions require multiple interventions over extended times. In these cases, it is indeed quite restrictive to assign an instantaneous cost and outcome after each chance node since these variables may not be observed for some time and many “not modelled” variables may affect the ultimate value of the outcomes.</p>
<p>The influence of time is not easily represented in decision trees, with patients that progress through the tree in an unidirectional way with movements “back and forth” over the branches that is not allowed. This feature prevents to account for disease recurrence, which may instead be quite important in some clinical contexts. Although in principle the structure of the tree can be adjusted to account for these events and possibilities, as the complexity of the tree increases its adoption becomes inefficient and the interpretation of the results more challenging. In practice, alternative models, known as <strong>Markov models</strong> or <strong>Discrete Event Simulations</strong> are more appropriate to handle these features. In any case, a decision tree may still be useful, especially when combined with other types of models, eg using a tree to describe the pathway of diagnostic tests whose results are then “fed” into a larger population model.</p>
<p>Within HTA, decision trees are suited for modelling diagnostic technologies and screening programmes, with false positives, true positives, etc… that could be each nodes flowing from the parent node to denote a given intervention. In short, the use of decision trees is recommended for only those contexts where time dependency and long-term disease processes or outcomes are not relevant<span class="citation" data-cites="yang2019use">(<a href="#ref-yang2019use" role="doc-biblioref">Yang et al. 2019</a>)</span>. In these cases, alternative decision-analytic approaches are more appropriate.</p>
</section>
</section>
<section id="sec-mmd" class="level1">
<h1>Markov Models in Discrete Time</h1>
<section id="introduction-to-markov-models" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-markov-models">Introduction to Markov Models</h2>
<p>When the context of the analysis makes the use of decision tree inappropriate or inefficient, cohort <strong>Markov models</strong> offer a valid alternative, especially for simulating diseases/treatments with long-term consequences and repeating events <span class="citation" data-cites="briggs2006decision siebert2012state">(<a href="#ref-briggs2006decision" role="doc-biblioref">A. Briggs, Sculpher, and Claxton 2006</a>; <a href="#ref-siebert2012state" role="doc-biblioref">Siebert et al. 2012</a>)</span>. A key characteristic of Markov models is their ability to simulate the nature of disease progression and estimate the expected costs and benefits under the assumption that the disease can be characterised in terms of <em>health states</em>. These states must be collectively exhaustive and mutually exclusive, which means that individuals cannot be in more than one state.</p>
<p>The numbers of health states and the structure of the Markov model linking these states is often graphically represented using <em>state-transition diagrams</em>, which typically display the states as squares with arrows them denoting movements (called <em>transitions</em>) allowed between them. As a simple example, let’s consider a model with four states: three related to different levels of disease progression (Mild, Moderate, Severe) and one related to death (Dead). Assume also that, within this model, patients in a given health state are only allowed moving either to more severe states or death. Such model is referred to as <em>irreversible</em> given that, once a patient falls in a “more progressed” state, they can no longer move back to previous states. A different type of model would apply if patients are also allowed to move back and forwards between different progression states, which would be more appropriate when modelling diseases characterised by the chance of remission and/or relapse for the patients. In both types of models, transitions from the Dead to other states are not allowed and the death state is referred to as an <em>absorbing</em> state.</p>
<p>To illustrate how a Markov model can be implemented in <code>R</code>, we will create an hypothetical example about colon cancer, with the objective of the health economic analysis being to assess the cost-effectiveness of two post-surgical therapies. In this context, we assume a total of three alternative treatment options are compared: 1) <em>No treatment</em> (None); 2) <em>Drug A</em> (A); 3) <em>Drug A+B</em> (AB). We will develop a cohort Markov model to address this research question and focus on the key elements and concepts for implementing such model in <code>R</code>.</p>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>The first step consists in defining the number and names of the alternative treatment options in objects in the <code>R</code> workspace</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>n_trt <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co">#n of treatments</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>trt_names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"None"</span>,<span class="st">"A"</span>,<span class="st">"AB"</span>) <span class="co">#names of treatments</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next, we will load a few <code>R</code> packages which can facilitate the implementation of the model compared to only using basic <code>R</code> commands. The exact functionality for these packages will become clear as we go through the code but, for the interested readers, two popular packages often used to implement Markov models in <code>R</code> are <code>heemod</code> and <code>hesim</code> <span class="citation" data-cites="filipovic2016markov incerti2021hesim">(<a href="#ref-filipovic2016markov" role="doc-biblioref">Filipovic-Pierucci, Zarca, and Durand-Zaleski 2016</a>; <a href="#ref-incerti2021hesim" role="doc-biblioref">Incerti and Jansen 2021</a>)</span>. In this document, we will still mostly use basic <code>R</code> commands to illustrate through a step-step process how the model can be constructed and the meaning of the different elements at the basis of the code.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(heemod)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(BCEA)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(survival)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(flexsurv)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(diagram)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The following health states are used to describe the disease progression in colon cancer, mostly distinguished based on the different costs and benefits associated with them: 1) <em>Recurrence-free</em>; 2) <em>Recurrence</em>; 3) <em>Dead (all cause)</em>; 4) <em>Dead (cancer)</em>. We can write up into <code>R</code> objects the information about the number of states in the model and their names by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>n_state <span class="ot">&lt;-</span> <span class="dv">4</span> <span class="co">#n of health states</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>state_names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Recurrence-free"</span>,<span class="st">"Recurrence"</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                 <span class="st">"Dead(all cause)"</span>,<span class="st">"Dead(cancer)"</span>) <span class="co">#names of states</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We then need to define what are the allowed transitions in the model between the assumed states. For example, we may consider an irreversible Markov model with the following disease progression:</p>
<ul>
<li>individuals start in the Recurrence-free state from which they can move either to Recurrence, Dead(all cause), or Dead(cancer);</li>
<li>individuals in the Recurrence state cannot not transition back to Recurrence-free and can only move to one of the death states;</li>
<li>individuals in either the Recurrence-free or Recurrence state are allowed to remain in the current state over time;</li>
<li>both death states are absorbing.</li>
</ul>
<p>At this point, a key element to define is the value of the transition probabilities which define the chance for individuals to move between states alongside the allowed transition paths. The probabilities are often organised into so-called <em>transition matrices</em>, where rows denote the current health state of the individual and columns those to which they can transition. The <code>heemod</code> package provides a useful feature to graphically display the assumed structure of a Markov model, including information about health states and transition probabilities. As an example, we may use the following lines to encode and plot the model structure in <code>R</code> using <code>heemod</code> functions:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">#object containing info about state names and transition probabilities between states</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>state_diagram <span class="ot">&lt;-</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">define_transition</span>(</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">state_names =</span> state_names,</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    X1, X2, X3, <span class="dv">0</span>, <span class="co">#assign different X values to each transition prob</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, X4, X5, X6,</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, X7, <span class="dv">0</span>,</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, X8</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  ) </span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co">#plot diagram of the model</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(state_diagram, </span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>     <span class="at">box.size=</span><span class="fl">0.12</span>,<span class="at">relsize=</span><span class="fl">0.75</span>,<span class="at">self.cex=</span><span class="fl">0.5</span>) <span class="co">#aestetics info</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-2" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-2-1.png" id="fig-2" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="general-features-of-cohort-markov-models" class="level3">
<h3 class="anchored" data-anchor-id="general-features-of-cohort-markov-models">General features of cohort Markov models</h3>
<p>A distinction needs to be made between <em>continuous</em> and <em>discrete</em> time models according to whether the transitions between states can occur at any time along a continuous interval or only at discrete time points (eg monthly). In the context of state-transition models, these discrete time points are often referred to as <em>cycles</em> and their duration is mainly determined by the nature of the disease/intervention considered. In particular, the chosen duration or <em>cycle’s length</em> must be sufficiently short to capture relevant events. In practice, individuals can transition between states in a continuous time but, provided that the cycle length is adequately chosen with respect to the context of the analysis, the bias introduced by discretising time may be acceptable. In general, it is possible to reduce this bias by choosing shorter duration but this needs to be balanced against the need for highly disaggregated data to reliably estimate transition probabilities between states. Currently, we focus on discrete time Markov models to introduce the topic in a relatively simple analysis context.</p>
<p>After each cycle (eg annual), individuals are associated with probabilities of transitioning to certain states which, in <a href="#fig-2" class="quarto-xref">Figure&nbsp;3</a>, are denoted with different X values. The number of cycles corresponds to the time horizon of the model which, for many models dealing with long-term diseases, is often set to a value covering the entire lifetime horizon of the individuals <span class="citation" data-cites="national2022nice nederland2024guideline">(<a href="#ref-national2022nice" role="doc-biblioref">Health and Excellence 2022</a>; <a href="#ref-nederland2024guideline" role="doc-biblioref">Nederland 2024</a>)</span>. For our example related to colon cancer patients, we will set the time horizon of the model to <span class="math inline">\(50\)</span> years.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>n_cycle <span class="ot">&lt;-</span> <span class="dv">50</span> <span class="co">#n of cycles</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Transition between states in a discrete time Markov model are governed by probabilities while those in continuous time model by <em>rates</em>, which are defined as instantaneous measures ranging from zero to infinity. Rates are used to describe the number of transitions between states for a given number of individuals per unit of time, while probabilities describe the likelihood that an individual will transition between states in a given time period (cycle length) and ranges between zero and one. It is possible to use published transition probabilities in the model but it is possible that a given transition probability cannot be found for a specific cycle length. In these cases, it is possible to transform probabilities from one time frame to another <span class="citation" data-cites="briggs2006decision">(<a href="#ref-briggs2006decision" role="doc-biblioref">A. Briggs, Sculpher, and Claxton 2006</a>)</span>. As an example, consider a <span class="math inline">\(5\)</span>-month probability for a given transition is reported in the literature but that the assumed model uses a <span class="math inline">\(1\)</span>-month cycle length. Assuming a constant rate over time, we can convert a <span class="math inline">\(5\)</span>-month rate into a <span class="math inline">\(1\)</span>-month rate through simple division (ie divide by <span class="math inline">\(5\)</span>) but we cannot use the same approach when dealing with probabilities. However, under an assumption of constant rate of event and two events only, we can convert a rate <span class="math inline">\(r\)</span> into a corresponding probability <span class="math inline">\(p\)</span> over the time frame <span class="math inline">\(t\)</span> using the following formula:</p>
<p><span class="math display">\[
p(t) = 1-e^{-rt}.
\]</span> If we need to change the time frame of a probability, we first need to convert said probability into a rate over the re-scaled time frame using the formula</p>
<p><span class="math display">\[
r(t) = -\frac{\log(1-p)}{t},
\]</span> and then convert it back to a probability. The following code shows how to perform these steps for converting a <span class="math inline">\(5\)</span>-month probability to a <span class="math inline">\(1\)</span>-month probability</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>p_5m <span class="ot">&lt;-</span> <span class="fl">0.5</span> <span class="co">#5-month prob</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>t_5m <span class="ot">&lt;-</span> <span class="dv">5</span> <span class="co">#initial time frame of 5 months</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>r_1m <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fu">log</span>(<span class="dv">1</span><span class="sc">-</span>p_5m)<span class="sc">/</span>t_5m <span class="co">#convert to 1 month rate</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>t_1m <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#desired time frame of 1 month</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>p_1m <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>r_1m<span class="sc">*</span>t_1m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Another commonly reported statistics for events are <em>odds</em> and <em>odds ratios</em>, where the odds of an event correspond to the ratio of the probability of the event <span class="math inline">\(p\)</span> occurring and its complement</p>
<p><span class="math display">\[
\text{odds}=\frac{p}{(1-p)}.
\]</span> Odds ratios, often defined for some treatment <span class="math inline">\(1\)</span> with event probability <span class="math inline">\(p_1\)</span> compared to some treatment <span class="math inline">\(2\)</span> with probability <span class="math inline">\(p_2\)</span>, are defined as the ratio of the corresponding odds</p>
<p><span class="math display">\[
\text{OR}=\frac{p_1/(1-p_1)}{p_2/(1-p_2)}.
\]</span> It is possible to convert log(odds) to the probability scale over the same time frame using the inverse of the logistic function, while a probability can be converted to the log(odds) scale using the logistic function. The following code shows some two functions to perform this tranformation</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">#function to convert log(odds) to probs</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>invlogit <span class="ot">&lt;-</span> <span class="cf">function</span>(logodds){</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> (<span class="fu">exp</span>(logodds)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">+</span><span class="fu">exp</span>(logodds)))</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(p)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co">#function to convert probs to logodds</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>logit <span class="ot">&lt;-</span> <span class="cf">function</span>(p){</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  logodds <span class="ot">&lt;-</span> <span class="fu">log</span>(p<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>p))</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(logodds)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Markov models are characterised by a property called the <em>Markov assumption</em>, under which the movement of an individual from their current state to a future one, conditional on both past and present states, depends only on the current state of the individual and not on the past states <span class="citation" data-cites="jackson2011multi">(<a href="#ref-jackson2011multi" role="doc-biblioref">Jackson 2011</a>)</span>. A <em>semi-Markov model</em> relaxes this assumption by allowing transition rates to depend also on the time spent in the current state, often referred to as <em>sojourn time</em>. In addition, Markov or semi-Markov models can be implemented at the cohort or individual level, where the former simulate a closed group of individuals who is assumed to be homogeneous, whereas the latter allows the cohort to be heterogeneous <span class="citation" data-cites="krijkamp2018microsimulation">(<a href="#ref-krijkamp2018microsimulation" role="doc-biblioref">Krijkamp et al. 2018</a>)</span>. Here we will only focus on cohort Markov models to ease the presentation of basic elements and concepts related to model construction and implementation.</p>
</section>
</section>
<section id="time-homogeneous-markov-model" class="level2">
<h2 class="anchored" data-anchor-id="time-homogeneous-markov-model">Time-homogeneous Markov model</h2>
<p>When setting up the transition probabilities between model states it is important to decide whether they are assumed to remain constant at each cycle (<em>time-homogeneous</em>) or they are allowed to change over time (<em>time-inhomogeneous</em>). We will start coding the model using an array to assign memory for the transition between states for each treatment under a time-homogeneous assumption. The transition matrix has dimension <span class="math inline">\(4\times 4\)</span>, where rows need to sum up to one (mutually exclusive and exhaustive states) and the impossibility of transitioning from one state to another is encoded through a zero probability value. The following code shows how the matrix can be constructed for the example considered as well as how its probability entries can be filled in (using appropriate values from the literature).</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty trans matrix objects for each treatment option  (homogeneous model)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_state, n_state), <span class="co">#dimensions (3 x 4 x 4)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, state_names, state_names) <span class="co">#names of each dimension</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">#probs for None from Recur-free to each of the 4 model states (itself, Recur, dead-all,dead-cancer)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"None"</span>, <span class="st">"Recurrence-free"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="fl">0.063</span>, <span class="fl">0.12</span>, <span class="dv">0</span>)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="co">#probs for None from Recur to each of the 4 model states (Recur-free,itself, dead-all,dead-cancer)</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"None"</span>, <span class="st">"Recurrence"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="cn">NA</span>, <span class="fl">0.12</span>, <span class="fl">0.43</span>)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="co">#probs for None from Dead-all to each of the 4 model states (Recur-free,Recur, itself,dead-cancer)</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"None"</span>, <span class="st">"Dead(all cause)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>, <span class="dv">0</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="co">#probs for None from Dead-cancer to each of the 4 model states (Recur-free,Recur, dead-all,itself)</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"None"</span>, <span class="st">"Dead(cancer)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for Trt A</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"A"</span>, <span class="st">"Recurrence-free"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="fl">0.068</span>, <span class="fl">0.12</span>, <span class="dv">0</span>)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"A"</span>, <span class="st">"Recurrence"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="cn">NA</span>, <span class="fl">0.12</span>, <span class="fl">0.39</span>)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"A"</span>, <span class="st">"Dead(all cause)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>, <span class="dv">0</span>)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"A"</span>, <span class="st">"Dead(cancer)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>)</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for Trt AB</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"AB"</span>, <span class="st">"Recurrence-free"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="fl">0.048</span>, <span class="fl">0.12</span>, <span class="dv">0</span>)</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"AB"</span>, <span class="st">"Recurrence"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="cn">NA</span>, <span class="fl">0.12</span>, <span class="fl">0.27</span>)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"AB"</span>, <span class="st">"Dead(all cause)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>, <span class="dv">0</span>)</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"AB"</span>, <span class="st">"Dead(cancer)"</span>, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="cn">NA</span>)</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co">#ensure row sum up to 1</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in NAs (prob of remaining in state) as 1 - sum of probs on the same row for same treatment option</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(state_names)){</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>  trans_matrix_homo[, i, i] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">rowSums</span>(trans_matrix_homo[, i, <span class="sc">-</span>i])</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a><span class="co">#check matrix entries for a given trt (eg None)</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>trans_matrix_homo[<span class="st">"None"</span>, , ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                Recurrence-free Recurrence Dead(all cause) Dead(cancer)
Recurrence-free           0.817      0.063            0.12         0.00
Recurrence                0.000      0.450            0.12         0.43
Dead(all cause)           0.000      0.000            1.00         0.00
Dead(cancer)              0.000      0.000            0.00         1.00</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">#check that each row sums up to 1 for each trt and state</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(trans_matrix_homo, <span class="fu">c</span>(<span class="dv">1</span>), rowSums)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                None A AB
Recurrence-free    1 1  1
Recurrence         1 1  1
Dead(all cause)    1 1  1
Dead(cancer)       1 1  1</code></pre>
</div>
</div>
<p>Another key element of Markov models is the <em>Markov trace</em>, which provides information about how the cohort is proportionally distributed across the states at each cycle. In our example, since everyone starts in the Recurrence-free state, the Markov trace of the model will show a value of <span class="math inline">\(1\)</span> in this state for all treatments, suggesting that <span class="math inline">\(100\%\)</span> of the cohort is in this state at the start and <span class="math inline">\(0\%\)</span> in all other states. Over time individuals will transition to other states, thus causing the proportion to change, with typically the majority of the cohort ending in the dead states. The Markov trace is generated using the transition probabilities to calculate movements between states at each cycle over the time horizon. In particular, given initial proportions for the cohort <span class="math inline">\(\pi_0\)</span>, successive proportions at cycle <span class="math inline">\(t+1\)</span> <span class="math inline">\(\pi_{t+1}\)</span> are calculated using the transition matrix <span class="math inline">\(P\)</span> and <span class="math inline">\(\pi_{t}\)</span> via matrix multiplication:</p>
<p><span class="math display">\[
\pi_{t+1}=\pi_tP.
\]</span></p>
<p>This product, in <code>R</code> obtained using the command <code>%*%</code>, allows to calculate which proportion of individuals will make a transition from their current state to the other states and sum this result to get the overall proportion of each state at the end of the cycle. This will provide the distribution of individuals transitioning from their current state to other states. Looking at the Markov trace allows to check how the model behaves compared to the expected clinical context being simulated. In our example, we can calculate the Markov trace by typing:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">#proportion in each state at cycle 1 for a given trt (eg None)</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>pcohort_first <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) </span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">#compute updated proportion at cycle 2 in same trt</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>pcohort_second <span class="ot">&lt;-</span> pcohort_first <span class="sc">%*%</span> trans_matrix_homo[<span class="st">"None"</span>, ,]</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">#compute updated proportion at cycle 3 in same trt</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>pcohort_third <span class="ot">&lt;-</span> pcohort_second <span class="sc">%*%</span> trans_matrix_homo[<span class="st">"None"</span>, ,] </span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">#etc... for successive cycles</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To avoid repeating the same code for each model cycle and treatment, we can compute the entire Markov trace in <code>R</code> by looping over cycles and treatments</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">#assign cycle names (from 0 up to n_cycle)</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>cycle_names <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"Cycle"</span>, <span class="dv">0</span><span class="sc">:</span>(n_cycle<span class="dv">-1</span>), <span class="at">sep =</span> <span class="st">" "</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">#zero-filled array </span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>Mtrace_homo <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, n_state), <span class="co">#n trt x n cycles x n states</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, state_names) <span class="co">#assign names to each dimension</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">#all individuals start in cycle 0 in Recurrence-free state</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>Mtrace_homo[, <span class="dv">1</span>, <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="co">#calculate trace entries at each cycle for each trt and state by looping product between trans matrix and value of trace at each cycle over cycles and trts</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n_cycle<span class="dv">-1</span>)){</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    Mtrace_homo[i_trt, i_cycle<span class="sc">+</span><span class="dv">1</span>, ] <span class="ot">&lt;-</span> Mtrace_homo[i_trt, i_cycle, ] <span class="sc">%*%</span> trans_matrix_homo[i_trt, , ]</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a><span class="co">#check that rows of trace at each cycle sum to 1</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(Mtrace_homo, <span class="fu">c</span>(<span class="dv">1</span>), rowSums)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>         None A AB
Cycle 0     1 1  1
Cycle 1     1 1  1
Cycle 2     1 1  1
Cycle 3     1 1  1
Cycle 4     1 1  1
Cycle 5     1 1  1
Cycle 6     1 1  1
Cycle 7     1 1  1
Cycle 8     1 1  1
Cycle 9     1 1  1
Cycle 10    1 1  1
Cycle 11    1 1  1
Cycle 12    1 1  1
Cycle 13    1 1  1
Cycle 14    1 1  1
Cycle 15    1 1  1
Cycle 16    1 1  1
Cycle 17    1 1  1
Cycle 18    1 1  1
Cycle 19    1 1  1
Cycle 20    1 1  1
Cycle 21    1 1  1
Cycle 22    1 1  1
Cycle 23    1 1  1
Cycle 24    1 1  1
Cycle 25    1 1  1
Cycle 26    1 1  1
Cycle 27    1 1  1
Cycle 28    1 1  1
Cycle 29    1 1  1
Cycle 30    1 1  1
Cycle 31    1 1  1
Cycle 32    1 1  1
Cycle 33    1 1  1
Cycle 34    1 1  1
Cycle 35    1 1  1
Cycle 36    1 1  1
Cycle 37    1 1  1
Cycle 38    1 1  1
Cycle 39    1 1  1
Cycle 40    1 1  1
Cycle 41    1 1  1
Cycle 42    1 1  1
Cycle 43    1 1  1
Cycle 44    1 1  1
Cycle 45    1 1  1
Cycle 46    1 1  1
Cycle 47    1 1  1
Cycle 48    1 1  1
Cycle 49    1 1  1</code></pre>
</div>
</div>
<p>In cohort Markov models, costs are typically simulated by associating them with each state rather than with each transition. In our example, the cost of one state (eg Recurrence-free) represents the on-going cost of having had a recurrence, rather than the one-off cost of the recurrence event itself. In such case, it is generally more plausible to associate the cost of recurrence with the Recurrence-free state but weight it by the probability of recurrence, thus producing on average the cost of recurrence events. This is shown in the following code, where the one-off cost of recurrence is counted in the Recurrence-free state, thus requiring to set to zero the cost of the recurrence state at each cycle. Similarly, the cost of the dead states at each cycle is set to zero.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled array for containing costs for each state and treatment</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>state_c <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim=</span><span class="fu">c</span>(n_trt, n_state),</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, state_names))</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">#set costs for recurrence-free state as cost of recurrence weighted by prob of recurrence from trans matrix for each treatment</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>state_c[, <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> trans_matrix_homo[, <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="sc">*</span> <span class="dv">35000</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co">#set other costs to zero</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>state_c[, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>state_c[, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>state_c[, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co">#show state and trt specific costs</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>state_c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Recurrence-free Recurrence Dead(all cause) Dead(cancer)
None            2205          0               0            0
A               2380          0               0            0
AB              1680          0               0            0</code></pre>
</div>
</div>
<p>Utilities can also be assigned to each state by multiplying each of these by the cycle length to obtain the associated QALYs accrued from spending one cycle in each state. When the cycle length is one year, as in our case, cycle-specific utilities and QALYs coincide.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create NA-filled array for containing utilities for each state</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>state_e <span class="ot">&lt;-</span> <span class="fu">array</span>(, <span class="at">dim=</span><span class="fu">c</span>(n_state), <span class="at">dimnames =</span> <span class="fu">list</span>(state_names))</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">#set utilities for all states</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>state_e[<span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="fl">0.8</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>state_e[<span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> <span class="fl">0.6</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>state_e[<span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>state_e[<span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="co">#show state and trt specific costs</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>state_e</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Recurrence-free      Recurrence Dead(all cause)    Dead(cancer) 
            0.8             0.6             0.0             0.0 </code></pre>
</div>
</div>
<p>When applicable, treatment-specific costs and QALYs loss should be added to the totals on each strategy. In our case, toxicity events lead to costs and disutilities which need to be added to the treatment outcomes. Toxicity probabilities differ by treatment and are used to calculate average costs and/or disutilities due to these toxicity events.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">#prob of toxicity on each trt</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>p_tox_A <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>p_tox_AB <span class="ot">&lt;-</span> <span class="fl">0.4</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>cost_tox <span class="ot">&lt;-</span> <span class="dv">2000</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>disu_tox <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">0.1</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co">#empty objects to contain costs and QALYs by trt</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>trt_cost <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim=</span><span class="fu">c</span>(n_trt), <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names))</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>trt_qaly <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim=</span><span class="fu">c</span>(n_trt), <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names))</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="co">#assign costs by trt</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>trt_cost[<span class="st">"None"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>trt_cost[<span class="st">"A"</span>] <span class="ot">&lt;-</span> <span class="dv">5000</span> <span class="sc">+</span> p_tox_A<span class="sc">*</span>cost_tox</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>trt_cost[<span class="st">"AB"</span>] <span class="ot">&lt;-</span> <span class="dv">10000</span> <span class="sc">+</span> p_tox_AB<span class="sc">*</span>cost_tox</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co">#assign qalys by trt</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>trt_qaly[<span class="st">"None"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>trt_qaly[<span class="st">"A"</span>] <span class="ot">&lt;-</span> p_tox_A<span class="sc">*</span>disu_tox</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>trt_qaly[<span class="st">"AB"</span>] <span class="ot">&lt;-</span> p_tox_AB<span class="sc">*</span>disu_tox</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="co">#show values</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>trt_cost</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> None     A    AB 
    0  5400 10800 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>trt_qaly</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> None     A    AB 
 0.00 -0.02 -0.04 </code></pre>
</div>
</div>
<p>The object <code>Mtrace_homo</code> is an array containing the proportions of the cohort in each of the <span class="math inline">\(4\)</span> states of the model, for <span class="math inline">\(3\)</span> treatments and over <span class="math inline">\(50\)</span> cycles. Given that the time horizon of the model goes beyond <span class="math inline">\(1\)</span> year, when computing total costs and QALYs we need to discount these outcomes at the recommended annual rate, which is typically set at the national level by HTA authorities. In the Netherlands, the indicated annual rate is <span class="math inline">\(3\%\)</span> for costs and <span class="math inline">\(1.5\%\)</span> for QALYs. We can generate the main results by implementing the Markov model across each treatment and using the Markov trace to generate discounted total outcomes summed over states and cycles. As an example, the following code shows how this can done.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set annual discount factor</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>disc_c <span class="ot">&lt;-</span> <span class="fl">0.03</span> <span class="co">#3% for costs</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>disc_e <span class="ot">&lt;-</span> <span class="fl">0.015</span> <span class="co">#1.5% for QALYs</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">#generate discounted rates at each cycle over the entire time horizon of the model</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>disc_c_seq <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>((<span class="dv">1</span><span class="sc">+</span>disc_c)<span class="sc">^</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>n_cycle)))</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>disc_e_seq <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>((<span class="dv">1</span><span class="sc">+</span>disc_e)<span class="sc">^</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>n_cycle)))</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="co">#assign memory of costs and QALYs for each trt in each cycle and total costs and QALYs for each trt</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty objects to contain treatment and cycle-specific costs and QALYs computed across states</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>cycle_c <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim=</span><span class="fu">c</span>(n_trt, n_cycle),</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names)</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>cycle_e <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim=</span><span class="fu">c</span>(n_trt, n_cycle),</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names)</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty objects to contain treatment specific costs and QALYs computed across states and cycles</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>total_c <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim=</span><span class="fu">c</span>(n_trt),</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names)</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>total_e <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim=</span><span class="fu">c</span>(n_trt),</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names)</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a><span class="co">#fill-in the above objects with cost and QALY values generated using the Markov trace of the model</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){<span class="co">#repeat computation for each trt</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">#costs depend on trt as they depend on risk of recurrence which differs by trt</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>  cycle_c[i_trt,] <span class="ot">&lt;-</span> Mtrace_homo[i_trt, , ] <span class="sc">%*%</span> state_c[i_trt, ]</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">#QALYs do not depend on trt </span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>  cycle_e[i_trt,] <span class="ot">&lt;-</span> Mtrace_homo[i_trt, , ] <span class="sc">%*%</span> state_e[]</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">#combine cycle and trt outcomes to obtain total outcomes using discount factor</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>  total_c[i_trt] <span class="ot">&lt;-</span> trt_cost[i_trt] <span class="sc">+</span> cycle_c[i_trt, ] <span class="sc">%*%</span> disc_c_seq</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>  total_e[i_trt] <span class="ot">&lt;-</span> trt_qaly[i_trt] <span class="sc">+</span> cycle_e[i_trt, ] <span class="sc">%*%</span> disc_e_seq</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a><span class="co">#compute NMB</span></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a><span class="co">#assume k value of 10000</span></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>v_nmb <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>total_e <span class="sc">-</span> total_c</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a><span class="co">#create data frame with results</span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>df_res_ce <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"Costs"</span><span class="ot">=</span><span class="fu">round</span>(total_c),</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"QALYs"</span><span class="ot">=</span><span class="fu">round</span>(total_e,<span class="dv">3</span>),</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"NMB"</span><span class="ot">=</span><span class="fu">round</span>(v_nmb))</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a><span class="co">#show results</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>df_res_ce</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Costs QALYs   NMB
None 10352 4.378 33430
A    16317 4.304 26719
AB   19285 4.720 27915</code></pre>
</div>
</div>
<p>We can then calculate incremental outcomes for both A and AB treatments compared to the no treatment option, and use these to get the respective ICER values.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute incremental outcomes for A or AB vs None</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>none_index <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">names</span>(total_c) <span class="sc">==</span> <span class="st">"None"</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>delta_c <span class="ot">&lt;-</span> total_c[<span class="sc">-</span>none_index] <span class="sc">-</span> total_c[<span class="st">"None"</span>]</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>delta_e <span class="ot">&lt;-</span> total_e[<span class="sc">-</span>none_index] <span class="sc">-</span> total_e[<span class="st">"None"</span>]</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="co">#compute icer for each comparison</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>icer <span class="ot">&lt;-</span> delta_c<span class="sc">/</span>delta_e</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co">#compute incremental NMB for each comparison (assume k=10000)</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>inmb <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>delta_e <span class="sc">-</span> delta_c</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="co">#combine CE results</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>res_ce <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Costs"</span><span class="ot">=</span><span class="fu">round</span>(total_c),</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>  <span class="st">"QALYs"</span><span class="ot">=</span><span class="fu">round</span>(total_e, <span class="dv">3</span>),</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_c"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_c)),</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_e"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_e, <span class="dv">3</span>)),</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ICER"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(icer)),</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>  <span class="st">"NMB"</span><span class="ot">=</span><span class="fu">round</span>(v_nmb),</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>  <span class="st">"INMB"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(inmb))</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a><span class="co">#print results</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>res_ce</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Costs QALYs Delta_c Delta_e   ICER   NMB  INMB
None 10352 4.378      NA      NA     NA 33430    NA
A    16317 4.304    5965  -0.075 -80010 26719 -6711
AB   19285 4.720    8933   0.342  26140 27915 -5515</code></pre>
</div>
</div>
</section>
<section id="time-inhomogeneous-markov-model" class="level2">
<h2 class="anchored" data-anchor-id="time-inhomogeneous-markov-model">Time-inhomogeneous Markov model</h2>
<p>In homogeneous Markov models, transition probabilities are constant over time. However, it is also possible to change the model structure to allow probabilities to be time-dependent, thus leading to a <em>time-inhomogeneous</em> model. In our application, we can for example consider the following time-dependency assumptions for transition probabilities:</p>
<ul>
<li>Recurrence probabilities depend on time since treatment initiation</li>
<li>All-cause death probabilities depend on age</li>
<li>Cancer-death probabilities depend on time since recurrence</li>
</ul>
<p>Given the cohort model structure, time can be recorded in terms of “time-in-model” (eg treatment initiation or age) but not in terms of “time-in-state” (eg time since recurrence). This means that, currently, we can only allow the first two types of probabilities to depend on time. To achieve this, we need to create time-inhomogeneous transition matrices, where probabilities between states need to be defined for each treatment and cycle.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled transition matrices </span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>trans_matrices <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>,</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">#array of dimensions 3 x 50 x 4 x 4                      </span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, n_state, n_state),</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#assign name to each dimension</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, state_names, state_names)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In order to allow these probabilities to very across cycles, rather then filling in a different value for each cycle based on some deterministic assumptions, it is generally more useful and practical to assume a time-dependency function which describes how these probabilities change over time in a probabilistic way. As long as the assumed function describes the time-trend of the probabilities in a plausible way, then the task of filling in cycle-specific probabilities for each transition can be considerably simplified and better justified.</p>
<p>For example, estimation of the time-dependency for transition probabilities involving a death state is typically obtained through survival analysis methods, where alternative survival (often parametric) functions are used to represent the relationship between mortality and time <span class="citation" data-cites="jackson2017extrapolating">(<a href="#ref-jackson2017extrapolating" role="doc-biblioref">Jackson et al. 2017</a>)</span>. Usually, a series of alternative models are fitted to the available or literature data (eg life tables) and their fit compared based on standard measures of model fit, such as the <em>Akaike Information Criterion</em> (AIC). The model with the best fit to the data is then selected as the winner and its cumulative hazard function is selected to represent the behaviour of mortality over time in the model. As an example, assume that from the literature we know that a Gompertz distribution provides the best fitting function to describe the time-dependency for the all-cause death transitions in the model target population. We can then extract from the literature (or estimate ourselves if data are available) the values of the parameters indexing this distribution (shape and rate) and use these to generate the values of the all-cause death transitions at each cycle in the model.</p>
<p>In a similar fashion, we may estimate time-dependent transition probabilities between non-death states using some (parametric) function based on some probabilistic model. As an example, the log-logistic mixture cure model can be used to estimate transition probabilities between the Recurrence-free and Recurrence states over time <span class="citation" data-cites="jensen2022fitting">(<a href="#ref-jensen2022fitting" role="doc-biblioref">Jensen et al. 2022</a>)</span>. Once estimates for the parameters of this model are obtained, these can be used in the Markov model to estimate probabilities of not being cured and of recurrence at each cycle, and use them to obtain the probabilities of moving from the Recurrence-free to the Recurrence state.</p>
<p>Finally, we fill-in values for the transition probabilities between Recurrence and death due to cancer, which are assumed to be time independent since the cohort Markov model does not allow to account for time-dependency in terms of time spent in a state. In our case, we use constant rates from an exponential distribution , which can be estimated, for example, from the log rates and rate ratios for the treatments. Again, once all transition probabilities from each state are filled-in, it is important to ensure that they must sum up to one. The following code shows how this can be done in <code>R</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">#assume to use a Gompertz distribution to describe all-cause mortality time-dependency, with an estimated shape value parameter of 0.0885 and rate value parameter of 0.0081 (assumed constant across treatments)</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>shape_death_all <span class="ot">&lt;-</span> <span class="fl">0.0885</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>rate_death_all <span class="ot">&lt;-</span> <span class="fl">0.0081</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="co">#define transition probabilities for all-cause death at first cycle using Gompertz cumulative hazard function and express death probability as 1 - survival</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>trans_matrices[, <span class="dv">1</span>, <span class="st">"Recurrence-free"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(<span class="dv">1</span>, shape_death_all, <span class="at">rate =</span> rate_death_all))</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>trans_matrices[, <span class="dv">1</span>, <span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(<span class="dv">1</span>, shape_death_all, <span class="at">rate =</span> rate_death_all))</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same at successive cycles by looping over them (time incorporated into function as number of cycle will affect the survival probability estimate through the Gompertz function)</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_cycle){</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">#ratio of cumulative Gompertz functions gives conditional death prob up to cycle i given death at cycle i-1 (expressed as 1 - survival)</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>  trans_matrices[, i_cycle, <span class="st">"Recurrence-free"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle, shape_death_all, <span class="at">rate =</span> rate_death_all)) <span class="sc">/</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle<span class="dv">-1</span>, shape_death_all, <span class="at">rate =</span> rate_death_all))</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">#assume same mortality pattern for Recurrence-free and Recurrence states</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>  trans_matrices[, i_cycle, <span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle, shape_death_all, <span class="at">rate =</span> rate_death_all)) <span class="sc">/</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle<span class="dv">-1</span>, shape_death_all, <span class="at">rate =</span> rate_death_all))</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="co">#use log-logistic mixture cure model to describe transition probability time-dependency between Recurrence-free and Recurrence states, by fixing the estimated parameters of the model separately for each treatment: log-odds of cure, shape and scale parameters</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>recurr_mean <span class="ot">&lt;-</span> <span class="fu">list</span>() <span class="co">#empty list to contain mean parameters from model</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in trt specific model parameter values</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"None"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.4398</span>, <span class="fl">0.4597</span>, <span class="fl">0.1379</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"A"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3661</span>, <span class="fl">0.5414</span>, <span class="fl">0.1007</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"AB"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.2965</span>, <span class="fl">0.5154</span>, <span class="fl">0.2704</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in prob values by looping over treatments</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(tname <span class="cf">in</span> trt_names){</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">#name entries in the above-created list</span></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(recurr_mean[[tname]]) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lodds"</span>,<span class="st">"shape"</span>,<span class="st">"scale"</span>)</span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill in prob between Recurrence-free and Recurrence at cycle 1 as product of prob of not being cured (expressed as 1 - prob of being cured) * prob of recurrence (expressed as 1 - prob of no recurrence) based on cumulative hazard function of log-logistic model</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>  trans_matrices[tname, <span class="dv">1</span>, <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">invlogit</span>(recurr_mean[[tname]][<span class="st">"lodds"</span>])) <span class="sc">*</span> </span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(<span class="dv">1</span>, <span class="at">shape =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"scale"</span>]))))</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same at successive cycles </span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_cycle){</span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">#assume same prob of not being cured</span></span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>  trans_matrices[tname, i_cycle, <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">invlogit</span>(recurr_mean[[tname]][<span class="st">"lodds"</span>])) <span class="sc">*</span> </span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">#obtain recurrence prob at cycle i conditional on no recurrence at cycle i-1 </span></span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(i_cycle, <span class="at">shape =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"scale"</span>]))) <span class="sc">/</span> </span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>       <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(i_cycle <span class="sc">-</span> <span class="dv">1</span>,  <span class="at">shape =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_mean[[tname]][<span class="st">"scale"</span>]))))</span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a><span class="co">#fix estimate from log rate and rate ratios for treatments</span></span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>lrate_cdeath_none <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">0.5734</span> <span class="co">#log rate of mortality for None</span></span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>lrate_cdeath_A <span class="ot">&lt;-</span> <span class="fl">0.0548</span> <span class="co">#log rate ratio of mortality for A and AB</span></span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a>lrate_cdeath_AB <span class="ot">&lt;-</span> <span class="fl">0.0548</span> <span class="co">#log rate ratio of mortality for A and AB</span></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a><span class="co">#compute transition probabilities for each treatment between Recurrence and Dead(cancer) by converting log estimates on rate scale to generate treatment-specific but time constant mortality rates (expressed as 1-survival rates)</span></span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>trans_matrices[<span class="st">"None"</span>, , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(lrate_cdeath_none))</span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>trans_matrices[<span class="st">"A"</span>, , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(lrate_cdeath_none <span class="sc">+</span> lrate_cdeath_A))</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>trans_matrices[<span class="st">"AB"</span>, , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(lrate_cdeath_none <span class="sc">+</span> lrate_cdeath_AB))</span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a><span class="co">#make sure rows sum up to 1, ie compute prob of remaining in current state at each cycle as 1 - prob of leaving state (expressed as sum of all other transition prob from that state at each cycle)</span></span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_state <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(state_names)){</span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a>  trans_matrices[, , i_state, i_state] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> </span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">#sum up probs from each to state to any other state across treatment dimension (index=1) and cycle dimension (index=2) ignoring possible NAs (na.rm=TRUE)</span></span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>    <span class="fu">apply</span>(trans_matrices[, , i_state, <span class="sc">-</span>i_state], <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), sum, <span class="at">na.rm =</span> <span class="cn">TRUE</span>) </span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a><span class="co">#run following code to check that all rows sum up to 1 (ie tranition prob from each state to any other state at a given cycle for each treatment)</span></span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a><span class="co">#apply(trans_matrices, c(1,2), rowSums)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once the time-dependent transition matrix is generated with all its entries, we can calculate the Markov trace of the model in a similar way to what done before for the time-homogeneous model. The main difference is that now a cycle index is also needed when accessing the entries from the transition matrix to generate the proportions of individuals from the cohort in each state at each cycle in each treatment.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled markov trace array object</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>Mtrace_inhomo <span class="ot">&lt;-</span> <span class="fu">array</span>(</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">#dimensions of 3 x 50 x 4</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, n_state),</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#assign names to each dimension</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, state_names)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="co">#set that everyone starts in Recurrence-free at cycle 1 (100% proportions)</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>Mtrace_inhomo[, <span class="dv">1</span>, <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co">#extract transition probs to fill-in values of trace at each cycle for each treatment</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n_cycle<span class="dv">-1</span>)){</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">#loop over cycles and trt and update proportions in each state from trace using probs between each state (matrix product between trace and trans matrix)</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>    Mtrace_inhomo[i_trt, i_cycle <span class="sc">+</span> <span class="dv">1</span>, ] <span class="ot">&lt;-</span> Mtrace_inhomo[i_trt, i_cycle, ] <span class="sc">%*%</span>  trans_matrices[i_trt, i_cycle, ,]</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="co">#check first few rows of trace for None treatment</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(Mtrace_inhomo[<span class="st">"None"</span>, ,])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>        Recurrence-free Recurrence Dead(all cause) Dead(cancer)
Cycle 0       1.0000000  0.0000000     0.000000000    0.0000000
Cycle 1       0.7205345  0.2710320     0.008433474    0.0000000
Cycle 2       0.5075350  0.3581256     0.017566054    0.1167733
Cycle 3       0.3823885  0.3202678     0.026273058    0.2710706
Cycle 4       0.3034384  0.2535136     0.033990907    0.4090571
Cycle 5       0.2497301  0.1913162     0.040671034    0.5182826</code></pre>
</div>
</div>
<p>With respect to the results from the time homogeneous version of the model, the state costs for Recurrence-free in the inhomogeneous version are also time-dependent, given that they are defined as a function of the underlying time-dependent probability of recurrence. In contrast, since utilities are fixed over time, these are assumed constant in a similar way to what assumed for the previous model version. In general, much of the code used to compute the model outcomes and CE results for the homogeneous version remains the same here.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled array objects to contain state cost values</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>state_c <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>,</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, n_state), <span class="co">#dimensions 3 x 50 x 4</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, state_names))</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in recurrence costs at each cycle for each treatment using transition matrix probs * assigned costs of recurrence (expressed as unit cost times prob of moving from recurrence-free to recurrence and setting cost of recurrence state to 0) </span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>state_c[, , <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> trans_matrices[, , <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="sc">*</span> <span class="dv">40000</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>state_c[, , <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="co">#set all other death state costs at 0</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>state_c[, , <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>state_c[, , <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty objects to contain memory costs and QALYs for each trt in each cycle across states</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>cycle_c <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle),</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names))</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>cycle_e <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle),</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names))</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty objects to contain total costs and QALYs for each trt across cycles and states</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>total_c <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt),</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names))</span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>total_e <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt),</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names))</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="co">#compute and fill-in the values for the cycle outcomes for each treatment as product between the Markov trace and state outcomes at each cycle </span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">#for costs need to take sum of values across states since outer product between matrices will return cycle-specific values for each state due to dependency of state costs on cycle</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>  cycle_c[i_trt, ] <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(Mtrace_inhomo[i_trt, , ] <span class="sc">*</span> state_c[i_trt, , ])</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">#for QALYs the matrix (inner) product directly gives the values across states since no dependency on cycles is assumed for this outcome</span></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>  cycle_e[i_trt, ] <span class="ot">&lt;-</span> Mtrace_inhomo[i_trt, , ] <span class="sc">%*%</span> state_e[]</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a><span class="co">#sum over outcomes for each treatment at different cycles to get total outcomes and apply discount factors (for costs also add initial trt costs to each group)</span></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>total_c[i_trt] <span class="ot">&lt;-</span> trt_cost[i_trt] <span class="sc">+</span> cycle_c[i_trt, ] <span class="sc">%*%</span> disc_c_seq</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a>total_e[i_trt] <span class="ot">&lt;-</span> cycle_e[i_trt, ] <span class="sc">%*%</span> disc_e_seq</span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can then check based on the quantities <span class="math inline">\(\Delta_e\)</span> and <span class="math inline">\(\Delta_c\)</span> the incremental mean cost and benefit values between each of the two treatments and the “no treatment” option, used as comparator. Similarly, we can then compute the respective ICER values for each comparison.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">#incremental cost results</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>delta_c <span class="ot">&lt;-</span> total_c[<span class="sc">-</span>none_index] <span class="sc">-</span> total_c[<span class="st">"None"</span>]</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">#incremental QALY results</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>delta_e <span class="ot">&lt;-</span> total_e[<span class="sc">-</span>none_index] <span class="sc">-</span> total_e[<span class="st">"None"</span>]</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">#icer for each comparison</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>icer <span class="ot">&lt;-</span> delta_c<span class="sc">/</span>delta_e</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="co">#nmb for each comparison assuming reference threshold value k=10000</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>v_nmb <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>total_e <span class="sc">-</span> total_c</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="co">#inmb for a k value of 10000</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>inmb <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>delta_e <span class="sc">-</span> delta_c</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a><span class="co">#combine CE results</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>res_ce <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Costs"</span><span class="ot">=</span><span class="fu">round</span>(total_c),</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>  <span class="st">"QALYs"</span><span class="ot">=</span><span class="fu">round</span>(total_e, <span class="dv">3</span>),</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_c"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_c)),</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_e"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_e, <span class="dv">3</span>)),</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ICER"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(icer)),</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>  <span class="st">"NMB"</span><span class="ot">=</span><span class="fu">round</span>(v_nmb),</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>  <span class="st">"INMB"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(inmb))</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a><span class="co">#print results</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>res_ce</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Costs QALYs Delta_c Delta_e   ICER   NMB  INMB
None 32311 4.770      NA      NA     NA 15388    NA
A    38135 4.568    5824  -0.202 -28846  7544 -7844
AB   38929 6.332    6619   1.563   4236 24395  9007</code></pre>
</div>
</div>
</section>
<section id="implementing-the-model-for-psa" class="level2">
<h2 class="anchored" data-anchor-id="implementing-the-model-for-psa">Implementing the model for PSA</h2>
<p>Until now we assumed the model parameters to be fixed, eg transition probabilities at a given time or state outcomes, but in HTA it is essential that uncertainty surrounding these parameters is appropriately quantified and its impact on the single point value model and CE results assessed through PSA. Thus, we will show how to adapt the Markov model to incorporate probabilistic modelling of the parameters to account for the related uncertainty, which is a compulsory requirement when reporting the results from these models under many HTA jurisdictions<span class="citation" data-cites="national2022nice nederland2024guideline">(<a href="#ref-national2022nice" role="doc-biblioref">Health and Excellence 2022</a>; <a href="#ref-nederland2024guideline" role="doc-biblioref">Nederland 2024</a>)</span>.</p>
<p>When running probabilistic analyses, it is important that the number of samples generated is sufficiently large to ensure proper quantification of the uncertainty around model parameters. Here we set the number of iterations to <span class="math inline">\(S=200\)</span> for demonstrative purposes but it is important that the number is set to a value sufficiently large to ensure that model results are not changed by simply slightly increasing this number.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="dv">200</span> <span class="co">#set number of iterations</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">4567</span>) <span class="co">#set rng for reproducibility</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A first change that we need to apply to the model code from the deterministic scenario is to modify the array of the transition matrices to include an extra dimension for the newly generated <span class="math inline">\(S\)</span> parameter samples (instead of one). A key element in probabilistic analysis is to choose an appropriate distribution for each parameter or set of parameters and to specify the parameter values of these assumed distributions. As an example, Beta distributions (defined on the interval <span class="math inline">\((0,1)\)</span>) is often advocated as reasonable for probabilities, and its canonical parameters (two different shape parameters) should be defined so that the generated samples of values follow expected behaviours informed from the literature or expert opinion. In a similar way, Gamma and LogNormal distributions are often advocated to generate samples of costs, Normal and Gamma distributions for utilities, LogNormal distributions for relative risks, and Logistic distributions for odds ratios.</p>
<p>In addition, the correlation between different (sets of) parameters may also be important to take into account, depending on the specific clinical context under consideration. When each parameter is sampled from a separate distribution, an implicit <em>independence assumption</em> between parameters is made which might not always be reasonable. The possibility to sample parameter values in a <em>joint</em> way would allow to take into account the possible association between them, but would require to also specify a plausible correlation/covariance parameter to be able to capture this dependence in a realistic way. In our example, the probability of recurrence was estimated using the log-logistic cure model, where the log-odds, shape and scale parameter values are likely to be correlated with each other. In our probabilistic analysis we may try to generate samples from this model using a multivariate Normal distribution to account for the association among them (under an independence assumption across treatments). In this way we can jointly sample these parameter values by specifying a mean vector and covariance matrices linking together their distributions.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">#empty array to contain a transition matrix for each trt, cycle and iteration</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">#dimensions 3 x 50 x 200 x 4 x 4</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, S, n_state, n_state),</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co">#set names of dimensions (no name for iterations)</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, <span class="cn">NULL</span>, state_names, state_names))</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="co">#recurrence prob assumed to come from log-logistic cure model separately for each trt according to values for log-odds, shape and scale parameters</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="co">#set empty lists to contain values for mean, covariance and sample values for these parameters when sampled jointly</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>recurr_mean <span class="ot">&lt;-</span> recurr_cov <span class="ot">&lt;-</span> recurr_sample <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in means for each trt using values from single point version of model</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"None"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.4398</span>, <span class="fl">0.4597</span>, <span class="fl">0.1379</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"A"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3661</span>, <span class="fl">0.5414</span>, <span class="fl">0.1007</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>recurr_mean[[<span class="st">"AB"</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.2965</span>, <span class="fl">0.5154</span>, <span class="fl">0.2704</span>) <span class="co">#log-odds, shape, scale</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in covariances among parameters for each trt (need to get these values from literature/experts or some reasonable guess)</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a><span class="co">#since three parameters are jointly modelled then we need 3*(3-1) = 6 values for their covariance matrix (Var(logodds), Var(shape), Var(scale), Cov(logodds,shape), Cov(logodds,scale), Cov(shape,scale))</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>recurr_cov[[<span class="st">"None"</span>]] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.0185</span>, <span class="fl">0.0035</span>, <span class="sc">-</span><span class="fl">0.0037</span>,</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>                                 <span class="fl">0.0035</span>, <span class="fl">0.0063</span>, <span class="sc">-</span><span class="fl">0.0026</span>,</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>                                 <span class="sc">-</span><span class="fl">0.0037</span>, <span class="sc">-</span><span class="fl">0.0026</span>, <span class="fl">0.0089</span>),</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>                               <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>recurr_cov[[<span class="st">"A"</span>]] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.0165</span>, <span class="fl">0.0025</span>, <span class="sc">-</span><span class="fl">0.0021</span>,</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>                                 <span class="fl">0.0025</span>, <span class="fl">0.0061</span>, <span class="sc">-</span><span class="fl">0.0018</span>,</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>                                 <span class="sc">-</span><span class="fl">0.0021</span>, <span class="sc">-</span><span class="fl">0.0018</span>, <span class="fl">0.0071</span>),</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>                               <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>recurr_cov[[<span class="st">"AB"</span>]] <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.0172</span>, <span class="fl">0.0037</span>, <span class="sc">-</span><span class="fl">0.0034</span>,</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>                                 <span class="fl">0.0037</span>, <span class="fl">0.0097</span>, <span class="sc">-</span><span class="fl">0.0036</span>,</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>                                 <span class="sc">-</span><span class="fl">0.0034</span>, <span class="sc">-</span><span class="fl">0.0036</span>, <span class="fl">0.0114</span>),</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>                               <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a><span class="co">#loop through treaments when sampling these parameter values and store them in empty list</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(tname <span class="cf">in</span> trt_names){<span class="co">#sample S parameter values from multivariate normals</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>  recurr_sample[[tname]] <span class="ot">&lt;-</span> <span class="fu">mvrnorm</span>(S, </span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>   <span class="at">mu =</span> recurr_mean[[tname]], <span class="at">Sigma =</span> recurr_cov[[tname]])</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a><span class="co">#assign list containing the sampled values with names   </span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(recurr_mean[[tname]]) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lodds"</span>,<span class="st">"shape"</span>,<span class="st">"scale"</span>)</span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(recurr_cov[[tname]]) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lodds"</span>,<span class="st">"shape"</span>,<span class="st">"scale"</span>)</span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(recurr_cov[[tname]]) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lodds"</span>,<span class="st">"shape"</span>,<span class="st">"scale"</span>)</span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(recurr_sample[[tname]]) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lodds"</span>,<span class="st">"shape"</span>,<span class="st">"scale"</span>)</span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a><span class="co">#fill-in transition matrices with sampled values and use Log-Logistic hazard function to generate, at each sampled parameter value, the probability values at first cycle for each trt between Recurrence-free and Recurrence in the model   </span></span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>    trans_matrices_psa[tname, <span class="dv">1</span>, , <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">invlogit</span>(recurr_sample[[tname]][,<span class="st">"lodds"</span>])) <span class="sc">*</span> </span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(<span class="dv">1</span>, <span class="at">shape =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"scale"</span>]))))</span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same at each successive cycle by computing conditional prob of recurrence at cycle i given no recurrence at i-1    </span></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_cycle){</span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a>      trans_matrices_psa[tname, i_cycle, , <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">invlogit</span>(recurr_sample[[tname]][,<span class="st">"lodds"</span>])) <span class="sc">*</span> </span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(i_cycle, <span class="at">shape =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"scale"</span>]))) <span class="sc">/</span> </span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a>           <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hllogis</span>(i_cycle <span class="sc">-</span> <span class="dv">1</span>, <span class="at">shape =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"shape"</span>]), <span class="at">scale =</span> <span class="fu">exp</span>(recurr_sample[[tname]][,<span class="st">"scale"</span>]))))</span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>From the single point value version of the model, we know that the transition probabilities involving all-cause mortality were obtained from the fit of a Gompertz distribution. In theory, we could replicate the same procedure adopted for the Recurrence probabilities and jointly sample the parameters indexing a Gompertz distribution and then use these values to generated corresponding values for the all-cause mortality transitions. To ease presentation of the model, under the assumption that point estimates for the Gompertz parameters are accurate with respect to the true population parameters of interest, we will not generate samples for these transition probabilities as use the same model specification as in the single point value version.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">#probabilities of death due to all cause generated using Gompertz hazard function and expressed as 1 - prob of surviving (still time-dependent)</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">#start at first cycle</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, <span class="dv">1</span>, , <span class="st">"Recurrence-free"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> trans_matrices_psa[, <span class="dv">1</span>, , <span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(<span class="dv">1</span>, <span class="at">shape =</span> <span class="fl">0.0885</span>, <span class="at">rate =</span> <span class="fl">0.0081</span>))</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co">#the compute conditional prob of death at cycle i given survival at i-1 (expressed as 1 -corresponding survival prob)</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_cycle){</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  trans_matrices_psa[, i_cycle, , <span class="st">"Recurrence-free"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> trans_matrices_psa[, i_cycle, , <span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle, <span class="at">shape =</span> <span class="fl">0.0885</span>, <span class="at">rate =</span> <span class="fl">0.0081</span>)) <span class="sc">/</span> </span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">exp</span>(<span class="sc">-</span><span class="fu">Hgompertz</span>(i_cycle <span class="sc">-</span> <span class="dv">1</span>, <span class="at">shape =</span> <span class="fl">0.0885</span>, <span class="at">rate =</span> <span class="fl">0.0081</span>))</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="co">#singe single point estimate use for parameters, then same transition probs used at each of the S samples</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With regard to cancer-related death, in the single point value version of the model, an exponential distribution was assumed for the corresponding rates based on estimates of the log rate for the None treatment and log rate ratios for the other two treatments. To account for the possible association among these parameters, in the probabilistic version we sample them jointly from a multivariate Normal distribution before converting them on the rate scale.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">#put point values for parameters in a mean vector</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>crr_lmean <span class="ot">&lt;-</span> <span class="fu">c</span>(lrate_cdeath_none, lrate_cdeath_A, lrate_cdeath_AB)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co">#create covariance matrix expressing association among these parameters (need to get these values from literature/experts or some reasonable guess)</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co">#since three parameters are jointly modelled then we need 3*(3-1) = 6 values for their covariance matrix (Var(lrateNone), Var(lrrA), Var(lrrAB), Cov(lrateNone,lrrA), Cov(lrateNone,lrrAB), Cov(lrrA,lrrAB))</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>crr_lcov <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fl">0.0065</span>, <span class="sc">-</span><span class="fl">0.0065</span>, <span class="sc">-</span><span class="fl">0.0065</span>,</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>                     <span class="sc">-</span><span class="fl">0.0065</span>, <span class="fl">0.0131</span>, <span class="fl">0.0065</span>,</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>                     <span class="sc">-</span><span class="fl">0.0065</span>, <span class="fl">0.0065</span>, <span class="fl">0.0157</span>), </span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a><span class="co">#sample S parameter values using multivariate normal</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>crr_lsample <span class="ot">&lt;-</span> <span class="fu">mvrnorm</span>(S, <span class="at">mu =</span> crr_lmean, <span class="at">Sigma =</span> crr_lcov)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a><span class="co">#give names to list elements</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(crr_lmean) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lrate None"</span>, <span class="st">"lrr A"</span>, <span class="st">"lrr AB"</span>)</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(crr_lcov) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lrate None"</span>, <span class="st">"lrr A"</span>, <span class="st">"lrr AB"</span>)</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(crr_lcov) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lrate None"</span>, <span class="st">"lrr A"</span>, <span class="st">"lrr AB"</span>)</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(crr_lsample) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lrate None"</span>, <span class="st">"lrr A"</span>, <span class="st">"lrr AB"</span>)</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="co">#use sampled values to generate transition prob to death-cancer state using exponential distribution on the rate scale (time-independent but varies across samples)</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in values in lists for each treatment</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[<span class="st">"None"</span>, , , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(crr_lsample[, <span class="st">"lrate None"</span>])), <span class="at">each =</span> n_cycle)</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[<span class="st">"A"</span>, , , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(crr_lsample[, <span class="st">"lrr A"</span>])), <span class="at">each =</span> n_cycle)</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[<span class="st">"AB"</span>, , , <span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">exp</span>(<span class="sc">-</span><span class="fu">exp</span>(crr_lsample[, <span class="st">"lrr AB"</span>])), <span class="at">each =</span> n_cycle)</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a><span class="co">#assume that cancer-related mortality is zero if in the Recurrence-free state for all treatments, cycles and samples</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Recurrence-free"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A possible risk in assuming that transition probabilities are independent is that their sum from a given state (for given treatment, cycle and sample) may not be equal to one. This also happens in our example for the two causes of death, with older individuals having higher all-cause mortality with the sum of cancer mortality exceeding one for some of the <span class="math inline">\(S\)</span> samples. The following code shows how this issue can be addressed using a crude approach and scaling the probabilities to ensure that they never exceed one for any sample.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">#ensure sum of probs of types of death never exceed one</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">#add death prob together with respect to treatments, cycles, and samples</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>sum_death_p <span class="ot">&lt;-</span> <span class="fu">apply</span>(trans_matrices_psa[, , , <span class="st">"Recurrence"</span>, <span class="fu">c</span>(<span class="st">"Dead(all cause)"</span>, <span class="st">"Dead(cancer)"</span>)], <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), sum)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co">#do not apply scale factor if sums &lt; 1</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>sum_death_p[sum_death_p<span class="sc">&lt;=</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co">#apply scale factors for each type of death (at each cycle, sample and trt) with respect to the sum total</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , ,<span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> trans_matrices_psa[, , ,<span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="sc">/</span> sum_death_p</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , ,<span class="st">"Recurrence"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> trans_matrices_psa[, , ,<span class="st">"Recurrence"</span>, <span class="st">"Dead(all cause)"</span>] <span class="sc">/</span> sum_death_p</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="co">#specify remaining transition probs under assumption of no recovery from recurrence at any cycle, trt and sample</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Recurrence"</span>, <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="co">#no transition out of death states</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Dead(all cause)"</span>, ] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Dead(cancer)"</span>, ] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Dead(all cause)"</span>, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[, , , <span class="st">"Dead(cancer)"</span>, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a><span class="co">#to avoid instability when probs estimated very close to 0, set them to 0</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>trans_matrices_psa[trans_matrices_psa <span class="sc">&lt;</span> <span class="dv">0</span>] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a><span class="co">#ensure probs from a state sum up to 1</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_state <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(state_names)){</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>  trans_matrices_psa[, , , i_state, i_state] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">apply</span>(trans_matrices_psa[, , , i_state, <span class="sc">-</span>i_state], <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), sum, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a><span class="co">#run following code to check that all rows sum up to 1 (ie transition prob from each state to any other state at a given cycle for each treatment and sample)</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a><span class="co">#apply(trans_matrices_psa, c(1,2,3), rowSums)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once the transition matrices are filled in with all sample values, we can now proceed to construct the probabilistic version of the Markov trace of the model in a similar way to what done for the single point value of the inhomogeneous version.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled array to store trace values at each cycle for each trt,  sample and state</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>Mtrace_inhomo_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, </span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, S, n_state),</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, <span class="cn">NULL</span>, state_names))</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="co">#assume everyone starts in the Recurrence-free state at cycle 1</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>Mtrace_inhomo_psa[, <span class="dv">1</span>, , <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#100% proportions</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in trace values </span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){ <span class="co">#loop over treatments</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(s <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>S){ <span class="co">#loop over samples</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i_cycle <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>n_cycle){ <span class="co">#loop over cycles</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">#update trace for each state as matrix product between trace values at previous cycle and transition probs at current cycle </span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>      Mtrace_inhomo_psa[i_trt, i_cycle, s, ] <span class="ot">&lt;-</span> Mtrace_inhomo_psa[i_trt, i_cycle <span class="sc">-</span> <span class="dv">1</span>, s, ] <span class="sc">%*%</span> trans_matrices_psa[i_trt, i_cycle, s, , ]</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next, we can generate the state costs and QALYs sing again a similar appraoch to the one shown for the single point value version of the model, which needs to be adapted to account for the fact that we have now <span class="math inline">\(S\)</span> different parameter values rather than only one.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">#state costs depend on cycle and trt given that recurrence-free costs depend on the time and trt dependent prob of recurrence</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled array for state costs for each trt, cycle, sample and state</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>state_c_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, S, n_state),</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, <span class="cn">NULL</span>, state_names))</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co">#compute cost of recurrence-free state as product between prob of having a recurrence and its related costs (and set costs of recurrence state to zero)</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>state_c_psa[, , , <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> trans_matrices_psa[, , , <span class="st">"Recurrence-free"</span>, <span class="st">"Recurrence"</span>] <span class="sc">*</span> <span class="dv">40000</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>state_c_psa[, , , <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="co">#set costs of death states to zero</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>state_c_psa[, , , <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>state_c_psa[, , , <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for utilities/QALYs but these are not time or trt-dependent</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="co">#create zero-filled array to contain utilities for each sample and state</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>state_e_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(S, n_state),</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>                     <span class="at">dimnames =</span> <span class="fu">list</span>(<span class="cn">NULL</span>, state_names))</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a><span class="co">#generate utility samples using normal distribution with state-specific information retrieved from literature or based on plausible guess</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>state_e_psa[, <span class="st">"Recurrence-free"</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="fl">0.8</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.8</span>)</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>state_e_psa[, <span class="st">"Recurrence"</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="fl">0.6</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.6</span>)</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>state_e_psa[, <span class="st">"Dead(all cause)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>state_e_psa[, <span class="st">"Dead(cancer)"</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can then calculate treatment costs and QALYs in a similar way to what done before</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set empty array to contain trt costs and QALYs for each sample</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>trt_cost_psa <span class="ot">&lt;-</span> trt_qaly_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, S),</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, <span class="cn">NULL</span>))</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co">#generate sample values for toxicity costs, disutility and probs based on information assuming using Normal distributions</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>p_tox_A_psa <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="fl">0.2</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.2</span>)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>p_tox_AB_psa <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="fl">0.4</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.4</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>cost_tox_psa <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="dv">2000</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="dv">2000</span>)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>disu_tox_psa <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(S, <span class="at">mean =</span> <span class="sc">-</span><span class="fl">0.1</span>, <span class="at">sd =</span> <span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span>)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="co">#assign trt costs and QALYs for all samples</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>trt_cost_psa[<span class="st">"None"</span>, ] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>trt_cost_psa[<span class="st">"A"</span>, ] <span class="ot">&lt;-</span> <span class="dv">5000</span> <span class="sc">+</span> p_tox_A_psa<span class="sc">*</span>cost_tox_psa</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>trt_cost_psa[<span class="st">"AB"</span>, ] <span class="ot">&lt;-</span> <span class="dv">10000</span> <span class="sc">+</span> p_tox_AB_psa<span class="sc">*</span>cost_tox_psa</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>trt_qaly_psa[<span class="st">"None"</span>, ] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>trt_qaly_psa[<span class="st">"A"</span>, ] <span class="ot">&lt;-</span> p_tox_A_psa<span class="sc">*</span>disu_tox_psa</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>trt_qaly_psa[<span class="st">"AB"</span>, ] <span class="ot">&lt;-</span> p_tox_AB_psa<span class="sc">*</span>disu_tox_psa</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Finally, we compute cycle and total outcomes from the probabilistic model</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set empty array to contain costs and QALYs accrued per cycle (for a given trt and sample) </span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>cycle_c_psa <span class="ot">&lt;-</span> cycle_e_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, n_cycle, S),</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, cycle_names, <span class="cn">NULL</span>))</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="co">#set empty array to contain total costs and QALYs accrued across cycles (for a given trt and sample) </span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>total_c_psa <span class="ot">&lt;-</span> total_e_psa <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="at">dim =</span> <span class="fu">c</span>(n_trt, S),</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimnames =</span> <span class="fu">list</span>(trt_names, <span class="cn">NULL</span>))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co">#fill in cycle and total outcome values into the arrays by looping over trt and samples</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_trt){</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(s <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>S){</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">#cycle costs by summing over costs across states for a given trt and sample</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  cycle_c_psa[i_trt, , s] <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(Mtrace_inhomo_psa[i_trt, , s, ] <span class="sc">*</span> state_c_psa[i_trt, , s, ])</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">#cycle QALYs from matrix x between trace and state QALYs at given sample</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>  cycle_e_psa[i_trt, , s] <span class="ot">&lt;-</span> Mtrace_inhomo_psa[i_trt, , s, ] <span class="sc">%*%</span> state_e_psa[s, ]</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute total costs and QALYs across cycles and applying discount factor</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>  total_c_psa[i_trt, s] <span class="ot">&lt;-</span> trt_cost_psa[i_trt, s] <span class="sc">+</span> cycle_c_psa[i_trt, , s] <span class="sc">%*%</span> disc_c_seq</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>  total_e_psa[i_trt, s] <span class="ot">&lt;-</span> trt_qaly_psa[i_trt, s] <span class="sc">+</span> cycle_e_psa[i_trt, , s] <span class="sc">%*%</span> disc_e_seq</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can now assess the economic results as per usual</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get incremental estimates (for each sample)</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>delta_c_psa <span class="ot">&lt;-</span> total_c_psa[<span class="sc">-</span>none_index,] <span class="sc">-</span> total_c_psa[none_index,]</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>delta_e_psa <span class="ot">&lt;-</span> total_e_psa[<span class="sc">-</span>none_index,] <span class="sc">-</span> total_e_psa[none_index,]</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="co">#nmb for each comparison with reference threshold value k=10000 (for each sample)</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>v_nmb_psa <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>total_e_psa <span class="sc">-</span> total_c_psa</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="co">#inmb for a k value of 10000 (for each sample)</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>inmb_psa <span class="ot">&lt;-</span> <span class="dv">10000</span><span class="sc">*</span>delta_e_psa <span class="sc">-</span> delta_c_psa</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="co">#combine CE results and show average results across samples</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>total_c_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(total_c_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>total_e_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(total_e_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>delta_c_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(delta_c_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>delta_e_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(delta_e_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>v_nmb_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(v_nmb_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>inmb_psa_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(inmb_psa, <span class="dv">1</span>, mean)</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>icer_psa <span class="ot">&lt;-</span> delta_c_psa_avg<span class="sc">/</span>delta_e_psa_avg</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>res_ce_psa <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Costs"</span><span class="ot">=</span><span class="fu">round</span>(total_c_psa_avg),</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>  <span class="st">"QALYs"</span><span class="ot">=</span><span class="fu">round</span>(total_e_psa_avg, <span class="dv">3</span>),</span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_c"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_c_psa_avg)),</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Delta_e"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(delta_e_psa_avg, <span class="dv">3</span>)),</span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ICER"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(icer_psa)),</span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>  <span class="st">"NMB"</span><span class="ot">=</span><span class="fu">round</span>(v_nmb_psa_avg),</span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>  <span class="st">"INMB"</span><span class="ot">=</span><span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">round</span>(inmb_psa_avg))</span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a><span class="co">#print results</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a>res_ce_psa</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>     Costs  QALYs Delta_c Delta_e   ICER   NMB  INMB
None 33865 10.401      NA      NA     NA 70148    NA
A    39291 10.234    5329  -0.154 -34524 63045 -6873
AB   39461 10.991    5693   0.577   9871 70453    74</code></pre>
</div>
</div>
<p>We can also use the functions from the <code>BCEA</code> package to generate standard CEA graphical tools to summarise the CE results.</p>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(BCEA) <span class="co">#load package</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="co">#generate CE output (also for multiple interventions with ref=assumed comparator)</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>ce_markov_bcea <span class="ot">&lt;-</span> <span class="fu">bcea</span>(<span class="at">eff =</span> <span class="fu">t</span>(total_e_psa), <span class="at">cost =</span> <span class="fu">t</span>(total_c_psa), <span class="at">ref =</span> <span class="dv">1</span>, <span class="at">interventions =</span> trt_names, <span class="at">Kmax =</span> <span class="dv">100000</span>)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="co">#scatter plot of delta_e and delta_c with assumed value k for wtp</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="co">#points in shaded area  / total points = prob of cost-effectiveness at k</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="fu">ceplane.plot</span>(ce_markov_bcea, <span class="at">wtp =</span> <span class="dv">10000</span>)</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span class="co">#prob of cost-effectiveness for a range of wtp values</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a><span class="fu">ceac.plot</span>(ce_markov_bcea)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-m1-1" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-m1-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-m1-1.png" id="fig-m1-1" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-m1-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4
</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-m1-2" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-m1-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-m1-2.png" id="fig-m1-2" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-m1-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5
</figcaption>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="conclusions-1" class="level2">
<h2 class="anchored" data-anchor-id="conclusions-1">Conclusions</h2>
<p>The <code>R</code> code provided in this section is related to a <span class="math inline">\(4\)</span>-state Markov model but is generalisable to any model structure and parameters. Different survival distributions were used for the transition probabilities, which were incorporated into the model through transformations. These could also be changed to other distributions when needed. We only focus on cohort models in discrete time under a Markov assumption, but the structure can also be extended to handle individual models in continuous time under a semi-Markov assumption. Modelling approaches that allow full individual level simulation, including <em>Discrete Event Simulations</em> (DSE), are preferred to cohort models if: events allow to better describe the progression of the disease rather than states; individual outcomes are heterogeneous; or individual disease history has a complex relationship with future disease course.</p>
<p>Point values for the parameters in the models in practice are often informed from the literature based on estimates retrieved from a trial or based on convention and the context of the analysis. If multiple studies are available, <em>Network Meta-Analysis</em> (NMA) may be used to combine evidence from multiple sources to derive the estimate for the parameters.</p>
<p>We have also not considered the topic of <em>Deterministic Sensitivity Analysis</em> (DSA), a type of analysis often conducted in HTA for assessing the robustness of the base-case results to deterministic variation of single parameter values. A typical example of DSA would be to re-run the single point value model using a lower and upper value for a given parameter, and then repeat the process for all key parameters in the model. Next, the CE results (eg ICER) associated with each different parameter values would be reported and compared to assess the impact of a single parameter change at a time on the final conclusions. Another type of sensitivity analysis consists not considered here would assess the robustness of the results to <em>structural</em> model changes, such as the choice of the distribution to obtain parameter values, number and types of allowed transitions between states or any other type of uncertainty that cannot be parameterised. Discrepancy or constraint approaches may also be used to perform these assessments by changing the input parameter distributions on transition probabilities, costs and utilities<span class="citation" data-cites="strong2012managing thom2017using">(<a href="#ref-strong2012managing" role="doc-biblioref">Strong, Oakley, and Chilcott 2012</a>; <a href="#ref-thom2017using" role="doc-biblioref">Thom et al. 2017</a>)</span>.</p>
</section>
</section>
<section id="sec-nma" class="level1">
<h1>Network Meta-Analysis</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Despite the fact that Randomised Controlled Trails (RCTs) are the gold standard for estimating treatment effects, head-to-head RCTs for each treatment comparison of interest may not always be available. When this is the case, <strong>Network Meta-Analysis</strong> (NMA) is the primary method for indirect treatment comparison recommended by many HTA authorities and international organisations<span class="citation" data-cites="hoaglin2011conducting national2022nice nederland2024guideline">(<a href="#ref-hoaglin2011conducting" role="doc-biblioref">Hoaglin et al. 2011</a>; <a href="#ref-national2022nice" role="doc-biblioref">Health and Excellence 2022</a>; <a href="#ref-nederland2024guideline" role="doc-biblioref">Nederland 2024</a>)</span>. NMA provides a way to indirectly compare treatments that are assessed in separate trials with respect to other treatment options, but for whom there is not direct head-to-head trial evidence. Different NMA approaches have been developed over the years, which will briefly summarised in this section together with their underlying rationale and assumptions.</p>
<p>Suppose interest is in the estimation of a treatment effect on a binary outcome (eg successful prevention of a pain crisis) between two alternative drugs, say treatment A and B, for which no head-to-head comparison evidence is available in the literature. However, the desired treatment effect in terms of <em>odds ratios</em> (OR) is available from two trials for the comparison of: treatment A to a third drug, say treatment C (<span class="math inline">\(\text{OR}_{\text{AC}}\)</span>); and treatment B and C (<span class="math inline">\(\text{OR}_{\text{BC}}\)</span>). We can use direct evidence about the comparison of A vs C and B vs C to indirectly compare A vs B.</p>
<p>An historical approach to perform this indirect comparison, known as the <em>Bucher method</em> <span class="citation" data-cites="bucher1997results">(<a href="#ref-bucher1997results" role="doc-biblioref">Bucher et al. 1997</a>)</span>, which calculates the odds ratio for A vs B as:</p>
<p><span class="math display">\[
\text{OR}_{\text{AB}} = \frac{\text{OR}_{\text{AC}}}{\text{OR}_{\text{BC}}},
\]</span> which, on the log-odds scale, could be linearly represented as <span class="math inline">\(\log(\text{OR}_{\text{AB}})=\log(\text{OR}_{\text{AC}})-\log(\text{OR}_{\text{BC}})\)</span>, with associated standard errors (assuming independence) <span class="math inline">\(\text{SE}(\log(\text{OR}_{\text{AB}}))=\sqrt{\text{SE}(\log(\text{OR}_{\text{AC}}))^2+\text{SE}(\log(\text{OR}_{\text{BC}}))^2}\)</span>. Now, let’s consider the case where a new drug, say treatment D, is only compared to treatment B in a new RCT, but for which there is interest to know how it would compare to treatment A. In this situation, the Bucher method would apply in steps: first derive <span class="math inline">\(\text{OR}_{\text{AB}}\)</span> using the direct evidence from the comparison between A vs C and B vs C; then use this result to obtain <span class="math inline">\(\text{OR}_{\text{AD}}\)</span> from the indirect evidence between A vs B and the direct evidence between B and D.</p>
<p>NMA can be thought of as a generalisation of the Bucher method for combining direct and indirect evidence on multiple treatment comparisons, each possibly coming from one or multiple studies. In addition, it allows to estimate the uncertainty from meta-analysing multiple RCTs and indirect comparisons under the so-called <em>consistency assumption</em>, ie that relative treatment effects can be added to correctly estimate another treatment effect of interest. Focus is mainly on binary outcomes <span class="math inline">\(r_{ik}\)</span> for a given treatment <span class="math inline">\(k\)</span> in study <span class="math inline">\(i\)</span>, which are usually modelled using a Binomial distribution</p>
<p><span class="math display">\[
r_{ik}\sim\text{Binomial}(p_{ik},n_{ik}),
\]</span> where <span class="math inline">\(p_{ik}\)</span> and <span class="math inline">\(n_{ik}\)</span> denote the probability of the event and the number of patients on treatment <span class="math inline">\(k\)</span> in study <span class="math inline">\(i\)</span>. Since probabilities are bounded between <span class="math inline">\([0,1]\)</span>, the consistency assumption would not hold when applied to their original scale. Thus, we typically apply a link function, such as the <em>logistic</em> function, to convert the probability scale to a transformed scaled defined on the real line:</p>
<p><span class="math display">\[
\text{logit}(p_{ik})=\log \biggl(\frac{p_{ik}}{1-p_{ik}}\biggl),
\]</span> which is the scale of the log odds and log odds ratios. We could then model the transformed probabilities using a linear predictor</p>
<p><span class="math display">\[
\text{logit}(p_{ik})=\mu_i + \delta_{ibk},
\]</span> where the subscript <span class="math inline">\(b\)</span> denotes the baseline or control arm of the trial, so that <span class="math inline">\(\delta_{ibk}\)</span> is the log odds ratios for treatment <span class="math inline">\(k\)</span> vs <span class="math inline">\(b\)</span> in trial <span class="math inline">\(i\)</span>. The main objective of using this specification is to relate study-specific log odds ratios between treatments in study arms to those relative to a common treatment, say treatment 1, often referred to as then <em>reference treatment</em>. We can achieve this by assuming either <em>fixed</em> or <em>random</em> effects across studies<span class="citation" data-cites="borenstein2010basic">(<a href="#ref-borenstein2010basic" role="doc-biblioref">Borenstein et al. 2010</a>)</span>. The first assumes the relative treatment effects to be the same across studies <span class="math inline">\(\delta_{ibk}=d_{i1k}-d_{i1b}\)</span>, where <span class="math inline">\(d_{i1k}\)</span> and <span class="math inline">\(d_{i1b}\)</span> denote the relative treatment effects between treatment 1 and treatments in arm <span class="math inline">\(k\)</span> and <span class="math inline">\(b\)</span> of trial <span class="math inline">\(i\)</span>, respectively. The second assumes instead the relative treatment effects to come from a Normal distribution <span class="math inline">\(\delta_{ibk}\sim \text{Normal}(d_{i1k}-d_{i1b},\sigma^2)\)</span>, with <span class="math inline">\(\sigma^2\)</span> being the <em>heterogeneity</em> variance.</p>
<p>Heterogeneity refers to the extent of variation between studies, often referred in NMA to variation in treatment effects across studies. Choice between assuming fixed or random effects should be guided by an assessment of the extent of heterogeneity, including: similarities of baseline characteristics, outcome definitions, time points, and other study design features. In general, a higher degree of heterogeneity suggests that a random effects assumption may be more appropriate. A quick assessment check consists in comparing the estimated heterogeneity standard deviation <span class="math inline">\(\sigma\)</span> to the estimated log odds ratios to provide an assessment of the heterogeneity relative to the size of the treatments: when <span class="math inline">\(\sigma\)</span> is considerably larger than the log odds ratios, then the impact of heterogeneity is likely to be relevant on estimation.</p>
</section>
<section id="estimation-and-assessment-methods" class="level2">
<h2 class="anchored" data-anchor-id="estimation-and-assessment-methods">Estimation and assessment methods</h2>
<p>NMA can be conducted using either Bayesian or frequentist statistical methods <span class="citation" data-cites="sadeghirad2023theory">(<a href="#ref-sadeghirad2023theory" role="doc-biblioref">Sadeghirad et al. 2023</a>)</span>. Under a Bayesian framework any parameters, including the relative treatment effects and heterogeneity variance in NMA, are viewed as random variables with associated probability distributions (eg Normals and Uniforms) called <em>prior distributions</em>, which represent the beliefs about the parameter values prior to observing the data. Often, prior distributions are specified as <em>vague</em> in the sense that they do not contain any specific external information about what the value of the parameter could be. In contrast, <em>informative</em> priors can be specified to incorporate into the model the existence of some clinical opinion on the parameter values. Once specified, prior distributions are combined with the data likelihood through <em>Bayes’ theorem</em> in the analysis stage to generate a <em>posterior distribution</em> for each model parameter. Several <code>R</code> packages exist to fit NMA under both a Bayesian or frequentist approach, such as the <code>multinma</code> and <code>netmeta</code> packages, which will be the focus of this chapter.</p>
<p>There are many tools to assess model fit in NMA under both the Bayesian and frequentist framework. Under a Bayesian setting, the absolute fit of a model to the observed data is often assessed in terms of <em>residual deviance</em>, measuring the difference between model predictions and actual observations<span class="citation" data-cites="dias2013evidence">(<a href="#ref-dias2013evidence" role="doc-biblioref">Dias et al. 2013</a>)</span>. The <em>Deviance Information Criterion</em> (DIC) is a Bayesian model assessment measure which assesses the model performance by trading off the fit, based on the deviance, and model complexity, based on an estimate of the effective number of parameters <span class="citation" data-cites="spiegelhalter2002bayesian">(<a href="#ref-spiegelhalter2002bayesian" role="doc-biblioref">Spiegelhalter et al. 2002</a>)</span>, with lower DIC values being associated with a better performance.</p>
<p>Under a frequentist setting, a key measure of model diagnostic is obtained from an estimate of the total heterogeneity in the network <span class="math inline">\(\text{Q}_{\text{tot}}\)</span><span class="citation" data-cites="higgins2003measuring">(<a href="#ref-higgins2003measuring" role="doc-biblioref">Higgins et al. 2003</a>)</span>, which is a generalised version of Cochran’s <span class="math inline">\(\text{Q}\)</span> used in conventional pairwise meta-analyses to test the between study heterogeneity. This measure can be used to derive a version of the <span class="math inline">\(I^2\)</span> statistic which is applicable to NMA models<span class="citation" data-cites="higgins2003measuring">(<a href="#ref-higgins2003measuring" role="doc-biblioref">Higgins et al. 2003</a>)</span>, which is bounded between <span class="math inline">\([0,100]\%\)</span> with higher values indicating a higher amount of heterogeneity in the model.</p>
<p>In the presence of substantial heterogeneity in treatment effects, <em>network meta-regression</em> may be used to attempt to explain this variation based on measured covariates<span class="citation" data-cites="dias2013evidence">(<a href="#ref-dias2013evidence" role="doc-biblioref">Dias et al. 2013</a>)</span>. Assume we are conducting a pairwise meta-analysis of three trials, where the treatment effect between treatment 1 and 2 is denoted with <span class="math inline">\(d_{12}\)</span> (on the log-odds ratio), and suppose the mean age of patients in trial <span class="math inline">\(i\)</span> is denoted with <span class="math inline">\(x_i\)</span>, which varies between trials. If age is a <em>treatment effect modifier</em>, ie trial-specific treatment effects are related to age, then the following simple meta-regression model applies</p>
<p><span class="math display">\[
\delta_{i12}=d_{12}+x_{i}\beta
\]</span> where <span class="math inline">\(\beta\)</span> is a regression coefficient that needs to be estimated. Extending the above framework to NMA for binary outcomes, we can specify a network meta-regression by including into the logistic model for the probability <span class="math inline">\(p_{ik}\)</span> a regression term</p>
<p><span class="math display">\[
\text{logit}(p_{ik})=\mu_i + \delta_{ibk} + x_{ik}\beta_{ibk},
\]</span> where <span class="math inline">\(x_{ik}\)</span> is the trial and arm-specific value of the covariate, while <span class="math inline">\(\beta_{ibk}\)</span> is the trial-specific interaction term between treatment and covariate, which can be expressed as</p>
<p><span class="math display">\[
\beta_{ibk} = \beta_{ik} - \beta_{ib},
\]</span> where usually <span class="math inline">\(\beta_{1}=0\)</span> so that only effects relative to control arms are affected. Different assumptions can be specified on the remaining treatment-specific regression coefficients <span class="math inline">\(\beta_z\)</span> for <span class="math inline">\(z\neq 1\)</span>, such as assuming exchangeability of the interaction terms across treatments:</p>
<p><span class="math display">\[
\beta_z \sim \text{Normal}(B,\sigma_{\beta}),
\]</span> or assume a common interaction term across treatments, ie <span class="math inline">\(\beta_2=\ldots,\beta_{ni}=B\)</span>.</p>
</section>
<section id="implementation-in-r-1" class="level2">
<h2 class="anchored" data-anchor-id="implementation-in-r-1">Implementation in <code>R</code></h2>
<p>In this section we will show some examples on how to conduct a NMA using either a Bayesian or frequentist approach and relying on existing <code>R</code> package functions, namely the <code>multinma</code> and <code>netmeta</code> packages, which were specifically developed for this purpose. We will apply the methods to some example data taken from a published NMA of irrigation and intracavity lavage techniques to prevent surgical site infections or SSIs <span class="citation" data-cites="thom2021intra">(<a href="#ref-thom2021intra" role="doc-biblioref">Thom et al. 2021</a>)</span>, which are wound infections occurring after an operative procedure. The data are stored in the <code>R</code> object <code>icl_data_long</code>, whose first few rows look like this</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>           study              trt  r   n contamination_level surgery_type
1 Al-shehri 1994 nonantibacterial  7 134                   1            0
2 Al-shehri 1994       antibiotic  1 120                   1            0
3     Baker 1994 nonantibacterial 17 150                   0            0
4     Baker 1994       antibiotic 17 150                   0            0
5      Carl 2000 nonantibacterial  1  20                   0            0
6      Carl 2000       antibiotic  1  20                   0            0</code></pre>
</div>
</div>
<p>The data are stored in a long format, where each row represents a different arm for each of the <span class="math inline">\(39\)</span> studies included, and with the reference treatment being nonactibacterial irrigation. In the data set, the variable names denote the study name (<code>Study</code>), treatment arm (<code>trt</code>), number of SSIs (<code>r</code>), number of patients (<code>n</code>), and two binary covariates, namely the contamination status (<code>contamination_level</code>) and the surgery type (<code>surgery_type</code>).</p>
<section id="bayesian-nma" class="level3">
<h3 class="anchored" data-anchor-id="bayesian-nma">Bayesian NMA</h3>
<p>We start by using the package <code>multinma</code>, which allows to implement NMAs through the Bayesian software <em>Stan</em><span class="citation" data-cites="carpenter2017stan">(<a href="#ref-carpenter2017stan" role="doc-biblioref">Carpenter et al. 2017</a>)</span>, which is called in the background. After loading the package, we first have a look at the available evidence network represented by the data.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(multinma) <span class="co">#load package</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">#aggregated data on study arm</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>icl_network <span class="ot">&lt;-</span> <span class="fu">set_agd_arm</span>(icl_data_long, <span class="at">study =</span> study, <span class="at">trt =</span> trt, </span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">r =</span> r, <span class="at">n =</span> n, </span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">trt_class =</span> <span class="fu">as.numeric</span>(trt <span class="sc">!=</span> <span class="st">"nonantibacterial"</span>)) <span class="co">#put all non-reference arms into a class</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="co">#show network info</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>icl_network</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A network with 39 AgD studies (arm-based).

------------------------------------------------------- AgD studies (arm-based) ---- 
 Study                  Treatment arms                     
 Al-shehri 1994         2: nonantibacterial | antibiotic   
 Baker 1994             2: nonantibacterial | antibiotic   
 Carl 2000              2: nonantibacterial | antibiotic   
 Case 1987              2: nonantibacterial | antibiotic   
 cervantes-sanchez 2000 2: nonantibacterial | no irrigation
 Cheng 2005             2: nonantibacterial | antiseptic   
 cho 2004               2: nonantibacterial | no irrigation
 Dashow 1986            2: nonantibacterial | antibiotic   
 de jong 1982           2: antiseptic | no irrigation      
 elliott 1986           2: antibiotic | no irrigation      
 ... plus 29 more studies

 Outcome type: count
------------------------------------------------------------------------------------
Total number of treatments: 4, in 2 classes
Total number of studies: 39
Reference treatment is: nonantibacterial
Network is connected</code></pre>
</div>
</div>
<p>The information provided includes: number of studies, type of outcome, number of treatment and classes. The function also tests whether the network is <em>connected</em>, ie any treatment can be compared to the reference through either a direct or indirect path of studies. The evidence network can be shown graphically using the <code>plot</code>, as shown in <a href="#fig-nma1" class="quarto-xref">Figure&nbsp;6</a>, where nodes represent the treatments, whose size is related to the number of patients, and edges which represent the studies comparing the respective treatments, whose thickness is related to the number of studies on the comparison.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">#plot network</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(icl_network, </span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">weight_nodes =</span> <span class="cn">TRUE</span>, <span class="co">#weight node size by n patients </span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">weight_edges =</span> <span class="cn">TRUE</span>) <span class="co">#weight edge thickness by n studies</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-nma1" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nma1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-nma1-1.png" id="fig-nma1" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-nma1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6
</figcaption>
</figure>
</div>
</div>
</div>
<p>We can fit fixed or random effects NMAs using the function <code>nma()</code> and the argument <code>trt_effects</code>. Prior distributions are specified using the arguments <code>prior_intercept</code> and <code>prior_trt</code>, while for random effects NMAs, priors on heterogeneity standard deviation are specified using the <code>prior_het</code> argument.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit fixed effects NMA</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>icl_nma_fe <span class="ot">&lt;-</span> <span class="fu">nma</span>(icl_network, <span class="at">trt_effects =</span> <span class="st">"fixed"</span>,</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_intercept =</span> <span class="fu">normal</span>(<span class="at">scale=</span><span class="dv">100</span>), <span class="co">#normal(mu=0,sigma=100) - for log odds</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_trt =</span> <span class="fu">normal</span>(<span class="at">scale =</span> <span class="dv">100</span>)) <span class="co">#normal(mu=0,sigma=100) - for log odds ratios</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 4.7e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.47 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.23 seconds (Warm-up)
Chain 1:                0.202 seconds (Sampling)
Chain 1:                0.432 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 2.2e-05 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.22 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.247 seconds (Warm-up)
Chain 2:                0.191 seconds (Sampling)
Chain 2:                0.438 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 1.7e-05 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.17 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.215 seconds (Warm-up)
Chain 3:                0.188 seconds (Sampling)
Chain 3:                0.403 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 1.9e-05 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.19 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.23 seconds (Warm-up)
Chain 4:                0.2 seconds (Sampling)
Chain 4:                0.43 seconds (Total)
Chain 4: </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit random effects NMA</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>icl_nma_re <span class="ot">&lt;-</span> <span class="fu">nma</span>(icl_network, <span class="at">trt_effects =</span> <span class="st">"random"</span>,</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_intercept =</span> <span class="fu">normal</span>(<span class="at">scale=</span><span class="dv">100</span>),</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_trt =</span> <span class="fu">normal</span>(<span class="at">scale =</span> <span class="dv">100</span>),</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_het =</span> <span class="fu">half_normal</span>(<span class="at">scale =</span> <span class="fl">2.5</span>)) <span class="co">#normal(mu=0,sigma=2.5)[0,] - for heterogeneity sd</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 3.7e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.37 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 1.377 seconds (Warm-up)
Chain 1:                0.927 seconds (Sampling)
Chain 1:                2.304 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 2.4e-05 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.24 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 1.349 seconds (Warm-up)
Chain 2:                1.562 seconds (Sampling)
Chain 2:                2.911 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 2.1e-05 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.21 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 1.233 seconds (Warm-up)
Chain 3:                0.977 seconds (Sampling)
Chain 3:                2.21 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 2.6e-05 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.26 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 1.19 seconds (Warm-up)
Chain 4:                0.935 seconds (Sampling)
Chain 4:                2.125 seconds (Total)
Chain 4: </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get summary results for FE model</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>icl_nma_fe</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A fixed effects NMA with a binomial likelihood (logit link).
Inference for Stan model: binomial_1par.
4 chains, each with iter=2000; warmup=1000; thin=1; 
post-warmup draws per chain=1000, total post-warmup draws=4000.

                     mean se_mean   sd     2.5%      25%      50%      75%
d[antibiotic]       -0.76    0.00 0.13    -1.01    -0.85    -0.76    -0.67
d[antiseptic]       -0.33    0.00 0.12    -0.57    -0.41    -0.33    -0.24
d[no irrigation]    -0.13    0.00 0.13    -0.39    -0.22    -0.14    -0.05
lp__             -3239.34    0.11 4.62 -3249.26 -3242.29 -3239.12 -3236.05
                    97.5% n_eff Rhat
d[antibiotic]       -0.51  4981    1
d[antiseptic]       -0.08  2584    1
d[no irrigation]     0.12  2542    1
lp__             -3231.16  1654    1

Samples were drawn using NUTS(diag_e) at Fri Nov  7 17:30:30 2025.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get summary results for RE model</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>icl_nma_re</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A random effects NMA with a binomial likelihood (logit link).
Inference for Stan model: binomial_1par.
4 chains, each with iter=2000; warmup=1000; thin=1; 
post-warmup draws per chain=1000, total post-warmup draws=4000.

                     mean se_mean   sd     2.5%      25%      50%      75%
d[antibiotic]       -0.83    0.00 0.21    -1.25    -0.97    -0.82    -0.68
d[antiseptic]       -0.59    0.01 0.28    -1.14    -0.77    -0.58    -0.40
d[no irrigation]    -0.05    0.01 0.28    -0.61    -0.23    -0.05     0.13
lp__             -3235.26    0.25 7.84 -3251.26 -3240.32 -3234.94 -3229.82
tau                  0.67    0.00 0.16     0.39     0.55     0.65     0.76
                    97.5% n_eff Rhat
d[antibiotic]       -0.40  2498    1
d[antiseptic]       -0.07  1718    1
d[no irrigation]     0.49  1993    1
lp__             -3220.73  1018    1
tau                  1.03  1365    1

Samples were drawn using NUTS(diag_e) at Fri Nov  7 17:30:42 2025.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).</code></pre>
</div>
</div>
<p>In the above outputs, for each parameter, the value of the <em>effective sample size</em> (<code>n_eff</code>) and the <em>potential scale reduction factor</em> (<code>Rhat</code>) are provided as standard <em>Markov Chain Monte Carlo</em> (MCMC) convergence checks<span class="citation" data-cites="brooks2011handbook">(<a href="#ref-brooks2011handbook" role="doc-biblioref">Brooks et al. 2011</a>)</span>. These are related to an estimate of the number of independent MCMC iterations and whether multiple MCMC chains seemed to have converged to the same target distribution, respectively.</p>
<p>Model choice can be informed based on the DIC value, including information on the estimated residual deviance and the effective number of parameters for each model</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute fit assessment measures for each model (lower DICs means better fit)</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dic</span>(icl_nma_fe)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Residual deviance: 138.9 (on 80 data points)
               pD: 43.2
              DIC: 182.1</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dic</span>(icl_nma_re)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Residual deviance: 85.9 (on 80 data points)
               pD: 60.1
              DIC: 146</code></pre>
</div>
</div>
<p>After checking model convergence and fit, we can look at the estimates of the chosen model for the treatment effects. We can, for example, compute relative effects against the reference treatment, here assumed to be nonantibacterial irrigation, using the <code>relative_effects()</code> function.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute relative trt effects for each arm vs reference on log odds ratio scale</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>icl_trt_re <span class="ot">&lt;-</span> <span class="fu">relative_effects</span>(icl_nma_re, <span class="at">trt_ref =</span> <span class="st">"nonantibacterial"</span>)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="co">#store in array and take exp to get odds ratio</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>or_array <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">as.array</span>(icl_trt_re))</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="co">#show results</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>icl_or_re <span class="ot">&lt;-</span> <span class="fu">summary</span>(or_array)</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>icl_or_re</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                 mean   sd 2.5%  25%  50%  75% 97.5% Bulk_ESS Tail_ESS Rhat
d[antibiotic]    0.45 0.10 0.29 0.38 0.44 0.51  0.67     2516     2580    1
d[antiseptic]    0.58 0.16 0.32 0.46 0.56 0.67  0.94     1766     2025    1
d[no irrigation] 0.99 0.28 0.55 0.79 0.95 1.14  1.64     2026     2392    1</code></pre>
</div>
</div>
<p>We can also plot the results using again the <code>plot</code> function. In addition, we can also create forest plots using these estimates using the <code>forestplot()</code> function from the <code>forestplot</code> package, as shown in <a href="#fig-nma2" class="quarto-xref">Figure&nbsp;7</a>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co">#convert estimates into data frame object</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>icl_or_re_fp <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(icl_or_re)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="co">#extract information to be plotted in forestplot and display means (2.5% and 97.5%) intervals</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>icl_or_re_fp<span class="sc">$</span>estci <span class="ot">&lt;-</span> <span class="fu">sprintf</span>(<span class="st">"%.2f (%.2f, %.2f)"</span>,</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  icl_or_re_fp<span class="sc">$</span>mean, icl_or_re_fp<span class="sc">$</span><span class="st">`</span><span class="at">2.5%</span><span class="st">`</span>, icl_or_re_fp<span class="sc">$</span><span class="st">`</span><span class="at">97.5%</span><span class="st">`</span>)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(forestplot) <span class="co">#load package</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="co">#forest plot</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="fu">forestplot</span>(icl_or_re_fp, </span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>           <span class="at">mean =</span> mean,  <span class="co">#mean value</span></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>           <span class="at">lower =</span> <span class="st">`</span><span class="at">2.5%</span><span class="st">`</span>, <span class="at">upper =</span> <span class="st">`</span><span class="at">97.5%</span><span class="st">`</span>, <span class="co">#95% interval bounds</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>           <span class="at">labeltext =</span> <span class="fu">c</span>(parameter, estci), <span class="co">#text for labels</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>           <span class="at">boxsize =</span> <span class="fl">0.1</span>, <span class="at">xlog =</span> <span class="cn">TRUE</span>) <span class="co">#size of squares and show ticks on x axis on log scale</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-nma2" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nma2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-nma2-1.png" id="fig-nma2" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-nma2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7
</figcaption>
</figure>
</div>
</div>
</div>
<p>We can also check how treatments are performing overall, rather than based on pairwise comparisons. We can do this in terms of treatment rankings using the function <code>posterior_ranks()</code>, and with the function <code>posterior_rank_probs()</code> we can compute the posterior probabilities for each treatment of occupying a given rank. We can also plot the probabilities graphically through a <em>rankogram</em>, as shown in <a href="#fig-nma3" class="quarto-xref">Figure&nbsp;8</a>, with the usual function <code>plot</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get mean ranks and summaries for each trt</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>icl_rank_re <span class="ot">&lt;-</span> <span class="fu">posterior_ranks</span>(icl_nma_re)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>icl_rank_re</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                       mean   sd 2.5% 25% 50% 75% 97.5% Bulk_ESS Tail_ESS Rhat
rank[nonantibacterial] 3.56 0.52    3   3   4   4     4     2471       NA    1
rank[antibiotic]       1.25 0.46    1   1   1   1     2     2284     2176    1
rank[antiseptic]       1.82 0.52    1   2   2   2     3     2804     2617    1
rank[no irrigation]    3.37 0.58    2   3   3   4     4     2445       NA    1</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co">#get probs of occupying each rank for each trt</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>icl_rank_probs_re <span class="ot">&lt;-</span> <span class="fu">posterior_rank_probs</span>(icl_nma_re)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>icl_rank_re</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                       mean   sd 2.5% 25% 50% 75% 97.5% Bulk_ESS Tail_ESS Rhat
rank[nonantibacterial] 3.56 0.52    3   3   4   4     4     2471       NA    1
rank[antibiotic]       1.25 0.46    1   1   1   1     2     2284     2176    1
rank[antiseptic]       1.82 0.52    1   2   2   2     3     2804     2617    1
rank[no irrigation]    3.37 0.58    2   3   3   4     4     2445       NA    1</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co">#show rankogram</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(icl_rank_probs_re)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-nma3" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nma3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-nma3-1.png" id="fig-nma3" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-nma3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8
</figcaption>
</figure>
</div>
</div>
</div>
<p>An important covariate in the data set is <code>contamination_level</code> (0=clean, 1=contaminated), which may represent a treatment effect modifier. We can attempt to take this into account through a meta-regression by appropriately customising the arguments of the <code>nma()</code> function</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit RE meta-regression to account for contamination level as trt interaction term</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>icl_nma_re_mr <span class="ot">&lt;-</span> <span class="fu">nma</span>(icl_network, <span class="at">trt_effects =</span> <span class="st">"random"</span>,</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">regression =</span> <span class="sc">~</span>.trt<span class="sc">:</span>contamination_level, <span class="co">#include interaction term</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">class_interactions =</span> <span class="st">"common"</span>, <span class="co">#assume same interaction term for all non-reference groups</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_intercept =</span> <span class="fu">normal</span>(<span class="at">scale=</span><span class="dv">100</span>), </span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_trt =</span> <span class="fu">normal</span>(<span class="at">scale =</span> <span class="dv">100</span>),</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_het =</span> <span class="fu">half_normal</span>(<span class="at">scale =</span> <span class="fl">2.5</span>),</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior_reg =</span> <span class="fu">normal</span>(<span class="at">scale =</span> <span class="dv">100</span>), <span class="co">#normal(mu=0,sigma=100) - for log odds ratios for interaction</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">chains =</span> <span class="dv">2</span>, <span class="at">iter =</span> <span class="dv">200</span> <span class="co">#set n chains and iterations</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 2.7e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.27 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: WARNING: There aren't enough warmup iterations to fit the
Chain 1:          three stages of adaptation as currently configured.
Chain 1:          Reducing each adaptation stage to 15%/75%/10% of
Chain 1:          the given number of warmup iterations:
Chain 1:            init_buffer = 15
Chain 1:            adapt_window = 75
Chain 1:            term_buffer = 10
Chain 1: 
Chain 1: Iteration:   1 / 200 [  0%]  (Warmup)
Chain 1: Iteration:  20 / 200 [ 10%]  (Warmup)
Chain 1: Iteration:  40 / 200 [ 20%]  (Warmup)
Chain 1: Iteration:  60 / 200 [ 30%]  (Warmup)
Chain 1: Iteration:  80 / 200 [ 40%]  (Warmup)
Chain 1: Iteration: 100 / 200 [ 50%]  (Warmup)
Chain 1: Iteration: 101 / 200 [ 50%]  (Sampling)
Chain 1: Iteration: 120 / 200 [ 60%]  (Sampling)
Chain 1: Iteration: 140 / 200 [ 70%]  (Sampling)
Chain 1: Iteration: 160 / 200 [ 80%]  (Sampling)
Chain 1: Iteration: 180 / 200 [ 90%]  (Sampling)
Chain 1: Iteration: 200 / 200 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.216 seconds (Warm-up)
Chain 1:                0.176 seconds (Sampling)
Chain 1:                0.392 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'binomial_1par' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 2e-05 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.2 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: WARNING: There aren't enough warmup iterations to fit the
Chain 2:          three stages of adaptation as currently configured.
Chain 2:          Reducing each adaptation stage to 15%/75%/10% of
Chain 2:          the given number of warmup iterations:
Chain 2:            init_buffer = 15
Chain 2:            adapt_window = 75
Chain 2:            term_buffer = 10
Chain 2: 
Chain 2: Iteration:   1 / 200 [  0%]  (Warmup)
Chain 2: Iteration:  20 / 200 [ 10%]  (Warmup)
Chain 2: Iteration:  40 / 200 [ 20%]  (Warmup)
Chain 2: Iteration:  60 / 200 [ 30%]  (Warmup)
Chain 2: Iteration:  80 / 200 [ 40%]  (Warmup)
Chain 2: Iteration: 100 / 200 [ 50%]  (Warmup)
Chain 2: Iteration: 101 / 200 [ 50%]  (Sampling)
Chain 2: Iteration: 120 / 200 [ 60%]  (Sampling)
Chain 2: Iteration: 140 / 200 [ 70%]  (Sampling)
Chain 2: Iteration: 160 / 200 [ 80%]  (Sampling)
Chain 2: Iteration: 180 / 200 [ 90%]  (Sampling)
Chain 2: Iteration: 200 / 200 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.162 seconds (Warm-up)
Chain 2:                0.178 seconds (Sampling)
Chain 2:                0.34 seconds (Total)
Chain 2: </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co">#show results</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>icl_nma_re_mr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A random effects NMA with a binomial likelihood (logit link).
Regression model: ~.trt:contamination_level.
Centred covariates at the following overall mean values:
contamination_level 
               0.45 
Inference for Stan model: binomial_1par.
2 chains, each with iter=200; warmup=100; thin=1; 
post-warmup draws per chain=100, total post-warmup draws=200.

                                         mean se_mean   sd     2.5%      25%
beta[.trtclass1:contamination_level]     0.24    0.02 0.36    -0.44     0.02
d[antibiotic]                           -0.83    0.01 0.22    -1.24    -0.96
d[antiseptic]                           -0.64    0.02 0.31    -1.27    -0.82
d[no irrigation]                        -0.05    0.02 0.28    -0.63    -0.25
lp__                                 -3234.53    0.77 6.90 -3249.19 -3239.39
tau                                      0.70    0.02 0.16     0.44     0.58
                                          50%      75%    97.5% n_eff Rhat
beta[.trtclass1:contamination_level]     0.22     0.43     1.00   213 1.00
d[antibiotic]                           -0.84    -0.69    -0.38   305 1.00
d[antiseptic]                           -0.65    -0.42    -0.10   157 1.00
d[no irrigation]                        -0.07     0.14     0.49   229 1.01
lp__                                 -3234.03 -3229.71 -3223.91    80 1.01
tau                                      0.70     0.81     1.02    97 1.01

Samples were drawn using NUTS(diag_e) at Fri Nov  7 17:30:45 2025.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).</code></pre>
</div>
</div>
<p>From the above output, we can see that posterior summaries for the regression coefficient suggest no evidence of effect modification, with also a DIC value that is very similar to the one of the random effects model without interaction term, thus suggesting no improvement</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co">#DIC for meta-regression model</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dic</span>(icl_nma_re_mr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Residual deviance: 85.4 (on 80 data points)
               pD: 61.1
              DIC: 146.5</code></pre>
</div>
</div>
</section>
<section id="frequentist-nma" class="level3">
<h3 class="anchored" data-anchor-id="frequentist-nma">Frequentist NMA</h3>
<p>We proceed to show how NMA may be implemented in <code>R</code> with the package <code>netmeta</code> under a frequentist framework using the same data set. However, in order to use the package, some changes to the current data format are necessary and shown in the following (folded) code part.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">#load data structured in matrices for the variables r, n and t (events, petients, trt) with the vector na with number of arms per study  </span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="co">#load("C:/Users/Andrea/Documents/talks/HSR_2025/appendix/icl_data.rda")</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"~/talks/HSR_2025/appendix/icl_data.rda"</span>)</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="co">#assign trt names</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>t_names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"nonantibacterial"</span>, <span class="st">"no irrigation"</span>, <span class="st">"antiseptic"</span>, <span class="st">"antibiotic"</span>)</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="co">#merge arms on the same treatment</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_study <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>icl_data<span class="sc">$</span>ns){ <span class="co">#loop over studies</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>  study_trt <span class="ot">&lt;-</span> <span class="fu">unique</span>(icl_data<span class="sc">$</span>t[i_study, ]) <span class="co">#trt assessed in each study</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i_trt <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>study_trt[<span class="sc">!</span><span class="fu">is.na</span>(study_trt)]){ <span class="co">#loop over trt</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>    arm_index <span class="ot">&lt;-</span> icl_data<span class="sc">$</span>t[i_study, ] <span class="sc">==</span> i_trt <span class="co">#get index of arm for each trt</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>    arm_index[<span class="fu">is.na</span>(arm_index)] <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">sum</span>(arm_index) <span class="sc">&gt;</span> <span class="dv">1</span>){</span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">#merge to one arm for each trt</span></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>      icl_data<span class="sc">$</span>t[i_study, arm_index] <span class="ot">&lt;-</span> <span class="fu">c</span>(i_trt, <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="fu">sum</span>(arm_index) <span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>      icl_data<span class="sc">$</span>na[i_study] <span class="ot">&lt;-</span> icl_data<span class="sc">$</span>na[i_study] <span class="sc">-</span> <span class="fu">sum</span>(arm_index) <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">#r and n are sum of events and patients across all arms</span></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a>      icl_data<span class="sc">$</span>r[i_study, arm_index] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">sum</span>(icl_data<span class="sc">$</span>r[i_study, arm_index]), </span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a>                                          <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="fu">sum</span>(arm_index) <span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>      icl_data<span class="sc">$</span>n[i_study, arm_index] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">sum</span>(icl_data<span class="sc">$</span>n[i_study, arm_index]), </span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>                                          <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="fu">sum</span>(arm_index) <span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a><span class="co">#assign strings as trt names</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a>temp <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="st">""</span>, <span class="at">nrow =</span> <span class="fu">dim</span>(icl_data<span class="sc">$</span>t)[<span class="dv">1</span>], <span class="at">ncol =</span> <span class="fu">dim</span>(icl_data<span class="sc">$</span>t)[<span class="dv">2</span>])</span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(temp) <span class="ot">&lt;-</span> <span class="fu">rownames</span>(icl_data<span class="sc">$</span>t)</span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i_study <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">dim</span>(temp)[<span class="dv">1</span>]){</span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>  temp[i_study, ] <span class="ot">&lt;-</span> t_names[icl_data<span class="sc">$</span>t[i_study, ]]</span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>icl_data<span class="sc">$</span>t <span class="ot">&lt;-</span> temp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The created list object <code>icl_data</code> contains the re-structured SSI data into a format compatible with <code>netmeta</code>. For example, we can access information on each variable (eg number of event, patients, etc.) per study from separate elements within the <code>icl_data</code> list. As an example, by typing <code>icl_data$r</code> the first few rows related to the number of events per study are shown as</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>                       [,1] [,2] [,3] [,4] [,5]
Al-shehri 1994            7    1   NA   NA   NA
Baker 1994               17   17   NA   NA   NA
Carl 2000                 1    1   NA   NA   NA
Case 1987                 1    0   NA   NA   NA
cervantes-sanchez 2000   11   39   NA   NA   NA
Cheng 2005                7    0   NA   NA   NA</code></pre>
</div>
</div>
<p>After re-structuring the data set, we can use the function <code>pairwise()</code> from <code>netmeta</code> to transform the data from arm-based to contrast-based format, automatically calculating odds ratios in each trial with respect to the reference</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(netmeta) <span class="co">#load package</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="co">#transform data in contrast-based format (merge info from each list elements)</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>icl_network2 <span class="ot">&lt;-</span> <span class="fu">pairwise</span>(<span class="at">treat =</span> <span class="fu">list</span>(t[, <span class="dv">1</span>], t[, <span class="dv">2</span>], t[, <span class="dv">3</span>]), <span class="co">#1=study,2=base trt,3=other trt</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">event =</span> <span class="fu">list</span>(r[, <span class="dv">1</span>], r[, <span class="dv">2</span>], r[, <span class="dv">3</span>]), <span class="co">#1=study,2=events for base trt,3=events for other trt</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">n =</span> <span class="fu">list</span>(n[, <span class="dv">1</span>], n[, <span class="dv">2</span>], n[, <span class="dv">3</span>]), <span class="co">#1=study,2=patients for base trt,3=patients for other trt</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> icl_data, <span class="co">#arm-based data set</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">sm =</span> <span class="st">"OR"</span>, <span class="at">studlab =</span> <span class="fu">names</span>(na)) <span class="co">#compute OR and get names of studies</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The first few rows and columns of the transformed contrast-based data set now appear as</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>                 studlab           treat1        treat2         TE      seTE
1         Al-shehri 1994 nonantibacterial    antibiotic  1.8808466 1.0766311
2             Baker 1994 nonantibacterial    antibiotic  0.0000000 0.3642590
3              Carl 2000 nonantibacterial    antibiotic  0.0000000 1.4509525
4              Case 1987 nonantibacterial    antibiotic  0.8712224 1.6562361
5 cervantes-sanchez 2000 nonantibacterial no irrigation -1.2570826 0.3656745
6             Cheng 2005 nonantibacterial    antiseptic  2.7521750 1.4639474</code></pre>
</div>
</div>
<p>We can now proceed to fit a fixed or random effects NMA using the function <code>netmeta()</code>, taking as inputs the treatment effects, standard errors, treatment and study labels. We can then print the results of these analyses and use summary statistics to compare them.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit FE and RE NMA models</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>icl_nma_fe2 <span class="ot">&lt;-</span> <span class="fu">netmeta</span>(<span class="at">TE =</span> TE, <span class="at">seTE =</span> seTE, <span class="co">#trt effect estimates and standard errors</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">treat1 =</span> treat1, <span class="at">treat2 =</span> treat2, <span class="co">#trt names</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">studlab =</span> studlab, <span class="at">data =</span> icl_network2, <span class="co">#study names and data set</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">common =</span> <span class="cn">TRUE</span>, <span class="at">random =</span> <span class="cn">FALSE</span>, <span class="co">#fit a fixed effects model</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>                       <span class="at">reference.group =</span> <span class="st">"nonantibacterial"</span>) <span class="co">#choose reference trt</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>icl_nma_re2 <span class="ot">&lt;-</span> <span class="fu">netmeta</span>(<span class="at">TE =</span> TE, <span class="at">seTE =</span> seTE, <span class="co">#trt effect estimates and standard errors</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>                       <span class="at">treat1 =</span> treat1, <span class="at">treat2 =</span> treat2, <span class="co">#trt names</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>                       <span class="at">studlab =</span> studlab, <span class="at">data =</span> icl_network2, <span class="co">#study names and data set</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>                       <span class="at">common =</span> <span class="cn">FALSE</span>, <span class="at">random =</span> <span class="cn">TRUE</span>, <span class="co">#fit a random effects model</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>                       <span class="at">reference.group =</span> <span class="st">"nonantibacterial"</span>) <span class="co">#choose reference trt</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a><span class="co">#print results</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>icl_nma_fe2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Number of studies: k = 39
Number of pairwise comparisons: m = 43
Number of treatments: n = 4
Number of designs: d = 6

Common effects model

Treatment estimate (sm = 'OR', comparison: other treatments vs 'nonantibacterial'):
                     OR           95%-CI     z  p-value
antibiotic       0.5032 [0.3914; 0.6470] -5.36 &lt; 0.0001
antiseptic       0.7887 [0.6087; 1.0220] -1.80   0.0726
no irrigation    0.9140 [0.7012; 1.1914] -0.66   0.5061
nonantibacterial      .                .     .        .

Quantifying heterogeneity / inconsistency:
tau^2 = 0.2163; tau = 0.4651; I^2 = 46.6% [22.2%; 63.3%]

Tests of heterogeneity (within designs) and inconsistency (between designs):
                    Q d.f. p-value
Total           71.14   38  0.0009
Within designs  60.70   34  0.0032
Between designs 10.44    4  0.0337

Details of network meta-analysis methods:
- Frequentist graph-theoretical approach
- DerSimonian-Laird estimator for tau^2
- Calculation of I^2 based on Q</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>icl_nma_re2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Number of studies: k = 39
Number of pairwise comparisons: m = 43
Number of treatments: n = 4
Number of designs: d = 6

Random effects model

Treatment estimate (sm = 'OR', comparison: other treatments vs 'nonantibacterial'):
                     OR           95%-CI     z  p-value
antibiotic       0.4845 [0.3410; 0.6884] -4.04 &lt; 0.0001
antiseptic       0.6808 [0.4423; 1.0480] -1.75   0.0806
no irrigation    0.9863 [0.6375; 1.5259] -0.06   0.9507
nonantibacterial      .                .     .        .

Quantifying heterogeneity / inconsistency:
tau^2 = 0.2163; tau = 0.4651; I^2 = 46.6% [22.2%; 63.3%]

Tests of heterogeneity (within designs) and inconsistency (between designs):
                    Q d.f. p-value
Total           71.14   38  0.0009
Within designs  60.70   34  0.0032
Between designs 10.44    4  0.0337

Details of network meta-analysis methods:
- Frequentist graph-theoretical approach
- DerSimonian-Laird estimator for tau^2
- Calculation of I^2 based on Q</code></pre>
</div>
</div>
<p>A <em>network diagram</em> can be generated based on the model results using the function <code>netgraph()</code>, as shown in <a href="#fig-nma4" class="quarto-xref">Figure&nbsp;9</a>, while also displaying the number of studies contributing to each contrast</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co">#plot network diagram</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="fu">netgraph</span>(icl_nma_re2, </span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">points =</span> <span class="cn">TRUE</span>, <span class="at">cex.points =</span> <span class="dv">2</span>, <span class="at">cex =</span> <span class="fl">1.2</span>, <span class="co">#aesthetics </span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">multiarm =</span> <span class="cn">TRUE</span>, <span class="at">number.of.studies =</span> <span class="cn">TRUE</span>) <span class="co">#allow for display of multi-arm and n studies </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-nma4" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nma4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-nma4-1.png" id="fig-nma4" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-nma4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9
</figcaption>
</figure>
</div>
</div>
</div>
<p>The probability (called <em>p-score</em>) that each treatment is ranked best can be computed using the <code>netrank()</code> function, while a rankogram, as shown in <a href="#fig-nma5" class="quarto-xref">Figure&nbsp;10</a>, can be plotted using the <code>rankogram()</code> and <code>plot</code> functions.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute prob for each trt to be the first</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="fu">netrank</span>(icl_nma_re2, </span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">small.values =</span> <span class="st">"good"</span>) <span class="co">#small trt effects indicate desirable effect</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                 P-score
antibiotic        0.9612
antiseptic        0.6705
no irrigation     0.1964
nonantibacterial  0.1719</code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co">#plot rankogram</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">rankogram</span>(icl_nma_re2, <span class="at">small.values =</span> <span class="st">"good"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-nma5" class="quarto-float quarto-figure quarto-figure-center anchored" width="672">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nma5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="code2_files/figure-html/fig-nma5-1.png" id="fig-nma5" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-nma5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10
</figcaption>
</figure>
</div>
</div>
</div>
<p>Finally, <em>Surface Under Cumulative Ranking Area</em> (SUCRA) scores, representing the sum of the area under the cumulative rankograms, can also be estimated, with favoured treatments having a value closer to one.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co">#estimate SUCRA scores</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="fu">netrank</span>(icl_nma_re2, <span class="at">small.values =</span> <span class="st">"good"</span>, <span class="at">method =</span> <span class="st">"SUCRA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                  SUCRA
antibiotic       0.9663
antiseptic       0.6610
no irrigation    0.2107
nonantibacterial 0.1620

- based on 1000 simulations</code></pre>
</div>
</div>
</section>
</section>
<section id="conclusions-2" class="level2">
<h2 class="anchored" data-anchor-id="conclusions-2">Conclusions</h2>
<p>The content of this section focussed on an introduction to the NMA topic and thus only considered an application to binary outcomes but, in general, NMAs can be implemented on many different data types using different distributional assumptions and link functions (see the <code>multinma</code> <a href="https://cran.r-project.org/web/packages/multinma/vignettes/vignette_overview.html">vignette</a> for some examples). For instance, continous outcomes can be modelled using Normal distributions and identity link functions, count data using Binomial distributions with cloglog link functions or ordinal multinomial distributions with probit link functions. Different techniques have also been developed for survival outcomes, including models based on parametric distributions, fractional polynomials, piecewise constant assumptions, and Royston-Parmar splines<span class="citation" data-cites="phillippo2024multinma">(<a href="#ref-phillippo2024multinma" role="doc-biblioref">Phillippo et al. 2024</a>)</span>.</p>
<p>Another topic not covered here was that of disconnected networks, in which case the most commonly used methods are some forms of unanchored <em>Matching Adjusted Indirect Comparison</em> (MAIC) or <em>Simulated Treatment Comparison</em> (STC), which however require individual-level data from at least one study<span class="citation" data-cites="phillippo2018methods">(<a href="#ref-phillippo2018methods" role="doc-biblioref">Phillippo et al. 2018</a>)</span>.</p>
</section>
</section>
<section id="references" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-baio2015probabilistic" class="csl-entry" role="listitem">
Baio, Gianluca, and A Philip Dawid. 2015. <span>“Probabilistic Sensitivity Analysis in Health Economics.”</span> <em>Statistical Methods in Medical Research</em> 24 (6): 615–34.
</div>
<div id="ref-borenstein2010basic" class="csl-entry" role="listitem">
Borenstein, Michael, Larry V Hedges, Julian PT Higgins, and Hannah R Rothstein. 2010. <span>“A Basic Introduction to Fixed-Effect and Random-Effects Models for Meta-Analysis.”</span> <em>Research Synthesis Methods</em> 1 (2): 97–111.
</div>
<div id="ref-briggs2012model" class="csl-entry" role="listitem">
Briggs, Andrew H, Milton C Weinstein, Elisabeth AL Fenwick, Jonathan Karnon, Mark J Sculpher, and A David Paltiel. 2012. <span>“Model Parameter Estimation and Uncertainty Analysis: A Report of the ISPOR-SMDM Modeling Good Research Practices Task Force Working Group–6.”</span> <em>Medical Decision Making</em> 32 (5): 722–32.
</div>
<div id="ref-briggs2006decision" class="csl-entry" role="listitem">
Briggs, Andrew, Mark Sculpher, and Karl Claxton. 2006. <em>Decision Modelling for Health Economic Evaluation</em>. Oup Oxford.
</div>
<div id="ref-brooks2011handbook" class="csl-entry" role="listitem">
Brooks, Steve, Andrew Gelman, Galin Jones, and Xiao-Li Meng. 2011. <em>Handbook of Markov Chain Monte Carlo</em>. CRC press.
</div>
<div id="ref-bucher1997results" class="csl-entry" role="listitem">
Bucher, Heiner C, Gordon H Guyatt, Lauren E Griffith, and Stephen D Walter. 1997. <span>“The Results of Direct and Indirect Treatment Comparisons in Meta-Analysis of Randomized Controlled Trials.”</span> <em>Journal of Clinical Epidemiology</em> 50 (6): 683–91.
</div>
<div id="ref-caro2012modeling" class="csl-entry" role="listitem">
Caro, J Jaime, Andrew H Briggs, Uwe Siebert, and Karen M Kuntz. 2012. <span>“Modeling Good Research Practices—Overview: A Report of the ISPOR-SMDM Modeling Good Research Practices Task Force–1.”</span> <em>Medical Decision Making</em> 32 (5): 667–77.
</div>
<div id="ref-carpenter2017stan" class="csl-entry" role="listitem">
Carpenter, Bob, Andrew Gelman, Matthew D Hoffman, Daniel Lee, Ben Goodrich, Michael Betancourt, Marcus Brubaker, Jiqiang Guo, Peter Li, and Allen Riddell. 2017. <span>“Stan: A Probabilistic Programming Language.”</span> <em>Journal of Statistical Software</em> 76: 1–32.
</div>
<div id="ref-dias2013evidence" class="csl-entry" role="listitem">
Dias, Sofia, Alex J Sutton, Nicky J Welton, and AE23804507 Ades. 2013. <span>“Evidence Synthesis for Decision Making 3: Heterogeneity—Subgroups, Meta-Regression, Bias, and Bias-Adjustment.”</span> <em>Medical Decision Making</em> 33 (5): 618–40.
</div>
<div id="ref-el2022scoping" class="csl-entry" role="listitem">
El Alili, Mohamed, Johanna M van Dongen, Jonas L Esser, Martijn W Heymans, Maurits W van Tulder, and Judith E Bosmans. 2022. <span>“A Scoping Review of Statistical Methods for Trial-Based Economic Evaluations: The Current State of Play.”</span> <em>Health Economics</em> 31 (12): 2680–99.
</div>
<div id="ref-filipovic2016markov" class="csl-entry" role="listitem">
Filipovic-Pierucci, A, K Zarca, and IJViH Durand-Zaleski. 2016. <span>“Markov Models for Health Economic Evaluation Modelling in r with the Heemod Package.”</span> <em>Value in Health</em> 19 (7): A369.
</div>
<div id="ref-national2022nice" class="csl-entry" role="listitem">
Health, National Institute for, and Care Excellence. 2022. <span>“NICE Health Technology Evaluations: The Manual.”</span> <em>Process and Methods [PMG36]</em>.
</div>
<div id="ref-higgins2003measuring" class="csl-entry" role="listitem">
Higgins, Julian PT, Simon G Thompson, Jonathan J Deeks, and Douglas G Altman. 2003. <span>“Measuring Inconsistency in Meta-Analyses.”</span> <em>Bmj</em> 327 (7414): 557–60.
</div>
<div id="ref-hoaglin2011conducting" class="csl-entry" role="listitem">
Hoaglin, David C, Neil Hawkins, Jeroen P Jansen, David A Scott, Robbin Itzler, Joseph C Cappelleri, Cornelis Boersma, et al. 2011. <span>“Conducting Indirect-Treatment-Comparison and Network-Meta-Analysis Studies: Report of the ISPOR Task Force on Indirect Treatment Comparisons Good Research Practices: Part 2.”</span> <em>Value in Health</em> 14 (4): 429–37.
</div>
<div id="ref-incerti2021hesim" class="csl-entry" role="listitem">
Incerti, Devin, and Jeroen P Jansen. 2021. <span>“Hesim: Health Economic Simulation Modeling and Decision Analysis.”</span> <em>arXiv Preprint arXiv:2102.09437</em>.
</div>
<div id="ref-jackson2011multi" class="csl-entry" role="listitem">
Jackson, Christopher. 2011. <span>“Multi-State Models for Panel Data: The Msm Package for r.”</span> <em>Journal of Statistical Software</em> 38: 1–28.
</div>
<div id="ref-jackson2017extrapolating" class="csl-entry" role="listitem">
Jackson, Christopher, John Stevens, Shijie Ren, Nick Latimer, Laura Bojke, Andrea Manca, and Linda Sharples. 2017. <span>“Extrapolating Survival from Randomized Trials Using External Data: A Review of Methods.”</span> <em>Medical Decision Making</em> 37 (4): 377–90.
</div>
<div id="ref-jensen2022fitting" class="csl-entry" role="listitem">
Jensen, Rasmus Kuhr, Mark Clements, Lars Klingen Gjærde, and Lasse Hjort Jakobsen. 2022. <span>“Fitting Parametric Cure Models in r Using the Packages cuRe and Rstpm2.”</span> <em>Computer Methods and Programs in Biomedicine</em> 226: 107125.
</div>
<div id="ref-krijkamp2018microsimulation" class="csl-entry" role="listitem">
Krijkamp, Eline M, Fernando Alarid-Escudero, Eva A Enns, Hawre J Jalal, MG Myriam Hunink, and Petros Pechlivanoglou. 2018. <span>“Microsimulation Modeling for Health Decision Sciences Using r: A Tutorial.”</span> <em>Medical Decision Making</em> 38 (3): 400–422.
</div>
<div id="ref-nederland2024guideline" class="csl-entry" role="listitem">
Nederland, Zorginstituut. 2024. <span>“Guideline for Economic Evaluations in Healthcare (2024 Version).”</span> <em>Zorginstituut Nederland: Diemen</em>.
</div>
<div id="ref-phillippo2018methods" class="csl-entry" role="listitem">
Phillippo, David M, Anthony E Ades, Sofia Dias, Stephen Palmer, Keith R Abrams, and Nicky J Welton. 2018. <span>“Methods for Population-Adjusted Indirect Comparisons in Health Technology Appraisal.”</span> <em>Medical Decision Making</em> 38 (2): 200–211.
</div>
<div id="ref-phillippo2024multinma" class="csl-entry" role="listitem">
Phillippo, David M, Ayman S Sadek, Hugo Pedder, Sofia Dias, AE Ades, and Nicky J Welton. 2024. <span>“Multinma: A Comprehensive r Package for Network Meta-Analysis of Survival Outcomes with Aggregate Data, Individual Patient Data, or a Mixture of Both.”</span> In <em>45th Annual Conference of the International Society for Clinical Biostatistics</em>.
</div>
<div id="ref-sadeghirad2023theory" class="csl-entry" role="listitem">
Sadeghirad, Behnam, Farid Foroutan, Michael J Zoratti, Jason W Busse, Romina Brignardello-Petersen, Gordon Guyatt, and Lehana Thabane. 2023. <span>“Theory and Practice of Bayesian and Frequentist Frameworks for Network Meta-Analysis.”</span> <em>BMJ Evidence-Based Medicine</em> 28 (3): 204–9.
</div>
<div id="ref-siebert2012state" class="csl-entry" role="listitem">
Siebert, Uwe, Oguzhan Alagoz, Ahmed M Bayoumi, Beate Jahn, Douglas K Owens, David J Cohen, and Karen M Kuntz. 2012. <span>“State-Transition Modeling: A Report of the ISPOR-SMDM Modeling Good Research Practices Task Force–3.”</span> <em>Medical Decision Making</em> 32 (5): 690–700.
</div>
<div id="ref-spiegelhalter2002bayesian" class="csl-entry" role="listitem">
Spiegelhalter, David J, Nicola G Best, Bradley P Carlin, and Angelika Van Der Linde. 2002. <span>“Bayesian Measures of Model Complexity and Fit.”</span> <em>Journal of the Royal Statistical Society: Series b (Statistical Methodology)</em> 64 (4): 583–639.
</div>
<div id="ref-strong2012managing" class="csl-entry" role="listitem">
Strong, Mark, Jeremy E Oakley, and Jim Chilcott. 2012. <span>“Managing Structural Uncertainty in Health Economic Decision Models: A Discrepancy Approach.”</span> <em>Journal of the Royal Statistical Society Series C: Applied Statistics</em> 61 (1): 25–45.
</div>
<div id="ref-thom2017using" class="csl-entry" role="listitem">
Thom, Howard, Chris Jackson, Nicky Welton, and Linda Sharples. 2017. <span>“Using Parameter Constraints to Choose State Structures in Cost-Effectiveness Modelling.”</span> <em>Pharmacoeconomics</em> 35 (9): 951–62.
</div>
<div id="ref-thom2021intra" class="csl-entry" role="listitem">
Thom, Howard, Gill Norman, Nicky J Welton, Emma J Crosbie, Jane Blazeby, and Jo C Dumville. 2021. <span>“Intra-Cavity Lavage and Wound Irrigation for Prevention of Surgical Site Infection: Systematic Review and Network Meta-Analysis.”</span> <em>Surgical Infections</em> 22 (2): 144–67.
</div>
<div id="ref-yang2019use" class="csl-entry" role="listitem">
Yang, Yaling, Lucy Abel, James Buchanan, Thomas Fanshawe, and Bethany Shinkins. 2019. <span>“Use of Decision Modelling in Economic Evaluations of Diagnostic Tests: An Appraisal and Review of Health Technology Assessments in the UK.”</span> <em>PharmacoEconomics-Open</em> 3 (3): 281–91.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>