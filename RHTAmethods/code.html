<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andrea Gabrio">
<meta name="dcterms.date" content="2025-10-21">

<title>Statistical methods for trial-based HTA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="code_files/libs/clipboard/clipboard.min.js"></script>
<script src="code_files/libs/quarto-html/quarto.js"></script>
<script src="code_files/libs/quarto-html/popper.min.js"></script>
<script src="code_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="code_files/libs/quarto-html/anchor.min.js"></script>
<link href="code_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="code_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="code_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="code_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="code_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Statistical methods for trial-based HTA</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://angabrio.github.io/agabriosite2/">Andrea Gabrio</a> <a href="mailto:a.gabrio@maastrichtuniversity.nl" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0002-7650-4534" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <a href="https://www.maastrichtuniversity.nl/research/methodology-and-statistics">
            Maastricht University
            </a>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 21, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This document provides the full code used to simulate some artificial trial-based HTA data and implement different types of statistical methods to analyse them. The methods listed here are based on a selection made according to recommendations from the current literature <span class="citation" data-cites="el2022scoping">(<a href="#ref-el2022scoping" role="doc-biblioref">El Alili et al. 2022</a>)</span> and national guidelines from the <em>ZorgInstituut Nederland</em><span class="citation" data-cites="nederland2024guideline">(<a href="#ref-nederland2024guideline" role="doc-biblioref">Nederland 2024</a>)</span> about the statistical analysis of (empirical) trial-based health economic evaluations in the Netherlands.</p>
<p>The code is presented with some comments and brief descriptions using an HTML interface generated via <a href="https://quarto.org/"><em>quarto</em></a> and <a href="https://posit.co/download/rstudio-desktop/"><em>Rstudio</em></a> to ease accessibility. The raw code is provided in a separate file in the same <a href="https://github.com/AnGabrio/Code/tree/master/RHTAmethods">GitHub repository</a>.</p>
<section id="sec-baseadj" class="level1">
<h1>Regression Adjustment for Baseline Imbalances</h1>
<p>We start by considering the problem of the possible occurrence of some imbalances between treatment arms in some baseline variables. In the context of randomised trial-based CUAs, a typical example of these variables are baseline utilities <span class="citation" data-cites="manca2005estimating">(<a href="#ref-manca2005estimating" role="doc-biblioref">Manca, Hawkins, and Sculpher 2005</a>)</span> or costs <span class="citation" data-cites="van2009deal">(<a href="#ref-van2009deal" role="doc-biblioref">Van Asselt et al. 2009</a>)</span>. Despite randomisation, some baseline imbalances are likely to occur, especially in those baseline variables that are likely strongly associated with the main outcomes of interest for the analysis, i.e.&nbsp;QALYs and Total Costs. This is a particular issue for baseline utilities, which are directly used in the calculation of QALYs through the <em>Area Under the Curve</em> (AUC) method <span class="citation" data-cites="drummond2015methods">(<a href="#ref-drummond2015methods" role="doc-biblioref">Drummond et al. 2015</a>)</span>. If these imbalances are not adjusted for, estimates from the main analysis are likely to be affected (eg mean QALY difference or ICER estimates), especially in the event of substantial differences, and possibly lead to misleading CE conclusions.</p>
<section id="data-generation" class="level2">
<h2 class="anchored" data-anchor-id="data-generation">Data generation</h2>
<p>The following (folded) code is simply used to generate some artificial CEA data for exemplary purposes to demonstrate how regression adjustment may be conducted in <code>R</code>. If not of interest, you may skip the folded code and jump to the actual implementation code in the next section.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#generate multivariate trial CUA data (utilities)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm) <span class="co">#load library to generate multivariate normal data</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>n0 <span class="ot">&lt;-</span> n1 <span class="ot">&lt;-</span> <span class="dv">2000</span> <span class="co">#sample size for control (0) and new trt (1)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>time <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co">#n of time points</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#mean utilities at each time in control</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>mu0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.63</span>,<span class="fl">0.63</span>,<span class="fl">0.67</span>) </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#covariance matrix for utilities in control</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Sigma0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">3</span>)  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(Sigma0) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>rho0 <span class="ot">&lt;-</span> <span class="fl">0.85</span> <span class="co">#correlation across time in control</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>Sigma0[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma0[<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> rho0<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>Sigma0[<span class="dv">3</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> Sigma0[<span class="dv">1</span>,<span class="dv">3</span>] <span class="ot">&lt;-</span> rho0<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>Sigma0[<span class="dv">3</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma0[<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">&lt;-</span> rho0<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">#mean utilities at each time in new trt</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>mu1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.55</span>,<span class="fl">0.63</span>,<span class="fl">0.67</span>) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>Sigma1 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">3</span>) </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(Sigma1) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>) </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>rho1 <span class="ot">&lt;-</span> <span class="fl">0.85</span> <span class="co">#correlation across time in new trt</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">#covariance matrix for utilities in new trt</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>Sigma1[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma1[<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> rho1<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>Sigma1[<span class="dv">3</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> Sigma1[<span class="dv">1</span>,<span class="dv">3</span>] <span class="ot">&lt;-</span> rho1<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>Sigma1[<span class="dv">3</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma1[<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">&lt;-</span> rho1<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="fl">0.1</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng seed for reproducibility</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate data by arm</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>u0 <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(n0, <span class="at">mean =</span> mu0, <span class="at">sigma =</span> Sigma0)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>u1 <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(n1, <span class="at">mean =</span> mu1, <span class="at">sigma =</span> Sigma1)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co">#compute QALYs via AUC by arm</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>QALY0 <span class="ot">&lt;-</span> ((u0[,<span class="dv">1</span>]<span class="sc">+</span>u0[,<span class="dv">2</span>])<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>(<span class="dv">6</span><span class="sc">/</span><span class="dv">12</span>) <span class="sc">+</span> ((u0[,<span class="dv">2</span>]<span class="sc">+</span>u0[,<span class="dv">3</span>])<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>(<span class="dv">6</span><span class="sc">/</span><span class="dv">12</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>QALY1 <span class="ot">&lt;-</span> ((u1[,<span class="dv">1</span>]<span class="sc">+</span>u1[,<span class="dv">2</span>])<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>(<span class="dv">6</span><span class="sc">/</span><span class="dv">12</span>) <span class="sc">+</span> ((u1[,<span class="dv">2</span>]<span class="sc">+</span>u1[,<span class="dv">3</span>])<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>(<span class="dv">6</span><span class="sc">/</span><span class="dv">12</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">#rename variables and create dataset</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>u_base <span class="ot">&lt;-</span> <span class="fu">c</span>(u0[,<span class="dv">1</span>],u1[,<span class="dv">1</span>])</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>u_6m <span class="ot">&lt;-</span> <span class="fu">c</span>(u0[,<span class="dv">2</span>],u1[,<span class="dv">2</span>])</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>u_12m <span class="ot">&lt;-</span> <span class="fu">c</span>(u0[,<span class="dv">3</span>],u1[,<span class="dv">3</span>])</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>QALY <span class="ot">&lt;-</span> <span class="fu">c</span>(QALY0, QALY1)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>trt <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"old"</span>,n0),<span class="fu">rep</span>(<span class="st">"new"</span>,n1))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>dataset <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(u_base,u_6m,u_12m,QALY,trt)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co">#make trt a factor variable (old,new)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>dataset<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">factor</span>(trt, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"old"</span>, <span class="st">"new"</span>))</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co">#randomly shuffle rows of the dataset</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>dataset <span class="ot">&lt;-</span> dataset[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(dataset)), ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can inspect the first few rows of the generated data stored in the <code>R</code> object <code>dataset</code>, for example by typing the following command</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dataset, <span class="at">n=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        u_base      u_6m     u_12m      QALY trt
1851 0.6649710 0.6695179 0.6385095 0.6606291 old
3885 0.5024305 0.6252957 0.6733950 0.6066042 new
2100 0.5250719 0.6123696 0.6940127 0.6109560 new
1430 0.6435694 0.6345586 0.6374612 0.6375370 old
2705 0.4929146 0.5621082 0.5388496 0.5389951 new
2774 0.6824814 0.7805227 0.8651590 0.7771715 new
537  0.5938100 0.5543479 0.6344838 0.5842474 old
3667 0.4878960 0.5223296 0.6684593 0.5502536 new</code></pre>
</div>
</div>
<p>which shows for a few rows (individuals) their related values for the following hypothetical variables: baseline utility, 6 and 12 months follow-up utility, QALY and treatment allocation.</p>
</section>
<section id="method-application" class="level2">
<h2 class="anchored" data-anchor-id="method-application">Method application</h2>
<p>Regression adjustment is a technique which allows to obtained estimates of parameters of interest, i.e.&nbsp;mean QALY differential <span class="math inline">\(\Delta_e=\text{E}[\text{QALY}\mid \text{New}]-\text{E}[\text{QALY}\mid \text{old}]\)</span>, while also controlling for possible imbalances in some baseline variables. Although alternative adjustment methods exist, regression-based adjustment is by far the most popular and recommended in the literature since it can be easily implemented and can provide valid adjusted estimates with respect to multiple baseline variables <span class="citation" data-cites="manca2005estimating">(<a href="#ref-manca2005estimating" role="doc-biblioref">Manca, Hawkins, and Sculpher 2005</a>)</span>.</p>
<p>Usually, estimates for <span class="math inline">\(\Delta_e\)</span> are retrieved after fitting a standard <em>Ordinary Least Square</em> (OLS) linear regression to QALYs using the treatment arm indicator as the key independent variable into the model.</p>
<p><span id="eq-1"><span class="math display">\[
\text{QALY}_i = \beta_0+\beta_1\times \text{arm}_i + \varepsilon_i
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(\text{QALY}_i\)</span> and <span class="math inline">\(\text{arm}_i\)</span> denote the outcome and treatment indicator value for individual <span class="math inline">\(i=1,\ldots,N\)</span> in the trial, while <span class="math inline">\(\varepsilon_i\)</span> denote the individual-level error term assumed to follow a Normal distribution with mean <span class="math inline">\(0\)</span> and variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p>Estimates of the regression coefficients <span class="math inline">\(\hat{\beta}=(\hat{\beta}_0,\hat{\beta}_1)\)</span> in <a href="#eq-1" class="quarto-xref">Equation&nbsp;1</a> can then be used to derive the <strong>unadjusted</strong> mean QALYs in each treatment group</p>
<p><span class="math display">\[
\begin{aligned}
\text{E}[\text{QALY}\mid \text{arm}=\text{old}] &amp;= \hat{\beta}_0\\
\text{E}[\text{QALY}\mid \text{arm}=\text{new}] &amp;= \hat{\beta}_0+\hat{\beta}_1,\\
\end{aligned}
\]</span> with <span class="math inline">\(\hat{\beta}_1\)</span> representing the mean difference between the reference group (eg New) with respect to the comparator (eg Old).</p>
<p>Adjustment for some baseline variable, eg baseline utilities <span class="math inline">\(u_{i0}\)</span>, can be easily achieved by including the corresponding baseline variable into the regression as an additional independent variable. Thus, the model regression becomes</p>
<p><span id="eq-2"><span class="math display">\[
\text{QALY}_i = \beta_0+\beta_1\times \text{arm}_i + \beta_2\times \text{u}_{i0}+ \varepsilon_i
\tag{2}\]</span></span></p>
<p>where <span class="math inline">\(\hat{\beta}_2\)</span> represents the coefficient associated with <span class="math inline">\(u_{i0}\)</span> (ie how much QALY changes for a unit change in baseline utility). By simply including <span class="math inline">\(u_{i0}\)</span> into the model, <strong>adjusted</strong> estimates for <span class="math inline">\(\hat{\beta}_1\)</span> from <a href="#eq-2" class="quarto-xref">Equation&nbsp;2</a> can be obtained in a similar way to the unadjusted model. The only difference is in case we need to estimate mean QALYs in each treatment group:</p>
<p><span id="eq-3"><span class="math display">\[
\begin{aligned}
\text{E}[\text{QALY}\mid \text{arm}=\text{old}] &amp;= \hat{\beta}_0+\hat{\beta}_2\times \bar{\text{u}}_{0}\\
\text{E}[\text{QALY}\mid \text{arm}=\text{new}] &amp;= \hat{\beta}_0+\hat{\beta}_1+\hat{\beta}_2\times \bar{\text{u}}_{0},\\
\end{aligned}
\tag{3}\]</span></span></p>
<p>which can be obtained after setting the value of <span class="math inline">\(\text{u}_{i0}\)</span> to its sample mean across treatment groups (denoted with <span class="math inline">\(\bar{\text{u}}_{0}\)</span>).</p>
<p>Now, let’s all do this in <code>R</code>. First, let’s fit the adjusted model and summarise the output</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit OLS regression adjusting for baseline utility</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>lm_adj <span class="ot">&lt;-</span> <span class="fu">lm</span>(QALY <span class="sc">~</span> trt <span class="sc">+</span> u_base, <span class="at">data =</span> dataset)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">#summarise output</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(lm_adj)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = QALY ~ trt + u_base, data = dataset)

Residuals:
      Min        1Q    Median        3Q       Max 
-0.133578 -0.023659 -0.000639  0.023359  0.116394 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 0.084463   0.003556   23.75   &lt;2e-16 ***
trtnew      0.051304   0.001178   43.56   &lt;2e-16 ***
u_base      0.880692   0.005528  159.31   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.03454 on 3997 degrees of freedom
Multiple R-squared:  0.8653,    Adjusted R-squared:  0.8652 
F-statistic: 1.284e+04 on 2 and 3997 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>We can see in the coefficients “Estimate” column the values for: <span class="math inline">\(\hat{\beta}_0=0.084\)</span>, <span class="math inline">\(\hat{\beta}_1=0.051\)</span> and <span class="math inline">\(\hat{\beta}_2=0.881\)</span>. In addition, we can also find the value for the “Residual standard error” <span class="math inline">\(\sigma=0.035\)</span>.</p>
<p>In the following (folded) code part I will show how to manually compute the estimates in <a href="#eq-3" class="quarto-xref">Equation&nbsp;3</a> based on the regression output.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract regression coefficients</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>betas <span class="ot">&lt;-</span> <span class="fu">coef</span>(lm_adj)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#extract error standard deviation</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="fu">summary</span>(lm_adj)<span class="sc">$</span>sigma</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">#extract all independent variables</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Xs <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(lm_adj)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">#compute matrix multiplication </span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>XtX.inv <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(Xs) <span class="sc">%*%</span> Xs) </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#select profile to be estimated in terms of: intercept, trt, u_base</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>prof_old <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>u_base)) <span class="co">#1=intercept,0=trt,u_base=mean(u)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>prof_new <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>u_base)) <span class="co">#1=intercept,1=trt,u_base=mean(u)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">#compute linear combination of regression parameters</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>mean_old <span class="ot">&lt;-</span> betas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> betas[<span class="st">"u_base"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>u_base)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>mean_new <span class="ot">&lt;-</span> betas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> betas[<span class="st">"trtnew"</span>] <span class="sc">+</span> betas[<span class="st">"u_base"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>u_base)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">#compute associated standard errors</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>std.err_old <span class="ot">&lt;-</span> sigma <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_old) <span class="sc">%*%</span> XtX.inv <span class="sc">%*%</span> prof_old)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>std.err_new <span class="ot">&lt;-</span> sigma <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_new) <span class="sc">%*%</span> XtX.inv <span class="sc">%*%</span> prof_new)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">#compute associated confidence intervals </span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>alpha<span class="ot">&lt;-</span><span class="fl">0.05</span> <span class="co">#95% CI</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">dim</span>(dataset)[<span class="dv">1</span>] <span class="co">#total sample size</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> n<span class="sc">-</span><span class="fu">c</span>(<span class="fu">length</span>(betas)<span class="sc">-</span><span class="dv">1</span>) <span class="co">#degrees of freedom</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>t.critic <span class="ot">&lt;-</span> <span class="fu">qt</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>,<span class="at">df=</span>df) <span class="co">#critical value for t distribution and 95% CI</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>mean_old_lower.CI <span class="ot">&lt;-</span> mean_old <span class="sc">-</span> t.critic<span class="sc">*</span>std.err_old</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>mean_old_upper.CI <span class="ot">&lt;-</span> mean_old <span class="sc">+</span> t.critic<span class="sc">*</span>std.err_old</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>mean_new_lower.CI <span class="ot">&lt;-</span> mean_new <span class="sc">-</span> t.critic<span class="sc">*</span>std.err_new</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>mean_new_upper.CI <span class="ot">&lt;-</span> mean_new <span class="sc">+</span> t.critic<span class="sc">*</span>std.err_new</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co">#combine all results</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>mean_old_summary <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_old,std.err_old,mean_old_lower.CI,mean_old_upper.CI)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>mean_new_summary <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_new,std.err_new,mean_new_lower.CI,mean_new_upper.CI)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co">#attach names to each value</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_old_summary) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_new_summary) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can also rely on the pre-built function <code>emmean</code> from the <code>R</code> package <code>emmeans</code> to compute the mean QALYs in each treatment group in a more automatic way. For example, we can type the following</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans) <span class="co">#load library to obtain marginal means</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>lm_adj_em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(lm_adj, <span class="sc">~</span> trt) <span class="co">#compute mean outcome by level of trt</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>lm_adj_em</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> trt emmean       SE   df lower.CL upper.CL
 old 0.6023 0.000803 3997   0.6007   0.6039
 new 0.6536 0.000803 3997   0.6520   0.6552

Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>to directly obtain estimates of the mean QALYs, their standard errors and <span class="math inline">\(95\%\)</span> confidence intervals by treatment group (hopefully they are the same as those computed manually before!). In addition, it is also possible to use the function <code>contrast</code> to derive estimates of any linear combination of the quantities above. For example, we may obtain estimates for the mean QALY difference (New - Old) by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#take difference as - Old + New = New - Old</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>QALY_new_vs_old <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"New vs Old"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#compute linear combination</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>lm_adj_em_delta_e <span class="ot">&lt;-</span> <span class="fu">contrast</span>(lm_adj_em, QALY_new_vs_old) </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#obtain results in terms of confidence intervals</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">confint</span>(lm_adj_em_delta_e, <span class="at">level =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> contrast   estimate      SE   df lower.CL upper.CL
 New vs Old   0.0513 0.00118 3997    0.049   0.0536

Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>Although I have not shown here an application of regression adjustment to control for baseline costs when deriving Total Costs mean and mean differential estimates, these can be easily obtained in a similar way to what shown for QALYs and baseline utilities. In the following sections I will show how these computations can be embedded within a bootstrapping procedure for both outcome variables and how to obtain bootstrapped estimates for the quantities of interest for the CEA.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>In general, it is good to keep in mind the following features when implementing regression-based adjustment:</p>
<ul>
<li><p><strong>Advantages</strong>:</p>
<ul>
<li>Easy to implement</li>
<li>Allow to control for multiple variables</li>
<li>Assess impact of specific variables on marginal CE outcomes (eg via interaction terms)</li>
</ul></li>
<li><p><strong>Drawbacks</strong>:</p>
<ul>
<li>Assume variables’ distribution is the same across arms</li>
<li>Adjusting for many variables may result in “overfitting”</li>
</ul></li>
</ul>
<p>There are also alternatives to regression-based adjustment, although these have been less used in the CEA literature and have their own advantages and drawbacks. Examples include: <em>Propensity score adjustment</em> <span class="citation" data-cites="indurkhya2006using">(<a href="#ref-indurkhya2006using" role="doc-biblioref">Indurkhya, Mitra, and Schrag 2006</a>)</span>, <em>Propensity Score Matching</em> &amp; <em>Genetic Matching</em> <span class="citation" data-cites="sekhon2012matching">(<a href="#ref-sekhon2012matching" role="doc-biblioref">Sekhon and Grieve 2012</a>)</span></p>
</section>
</section>
<section id="sec-corr" class="level1">
<h1>Correlation between CE outcomes</h1>
<p>A typical feature of trial-based CE data is the presence of some form of correlation between the effect and cost variables. This may happen because: new treatments come from intensive research and are <em>positively</em> associated with higher unit costs, or new treatments <em>negatively</em> affect care pathway costs (eg fewer hospitalisations, side effects, etc.). When this association, either positive or negative, is substantial, simply running separate OLS models for each outcome (as in <a href="#sec-baseadj" class="quarto-xref">Section&nbsp;1</a>) will provide <em>inefficient</em> estimates in the sense that the level of uncertainty around the parameter estimates will be <strong>overestimated</strong>, thus resulting in higher standard errors and wider confidence intervals.</p>
<p>To address this problem, <strong>joint modelling</strong> of both outcome variables is typically recommended to properly characterise the level of uncertainty around parameter estimates and CE results <span class="citation" data-cites="o2001framework">(<a href="#ref-o2001framework" role="doc-biblioref">O’Hagan and Stevens 2001</a>)</span>. Indeed, by simultaneously modelling both outcomes within a <em>multivariate</em> analysis it is possible to borrow information across variables to estimate variance components and standard errors more efficiently with respect to separate univariate analyses. A general issue, however, is that multivariate modelling, while also allowing for regression adjustment for each outcome separately (ie using different baseline variables per outcome), is not straightforward to implement using standard software packages, especially wihtin a frequentist statistical framework.</p>
<p>To overcome this practical issue, correlation between outcomes can also be taken into account using alternative approaches, which have become increasingly popular in trial-based CEA. These include: <strong>Seemingly Unrelated Regression</strong> (SUR) equations framework <span class="citation" data-cites="willan2004regression">(<a href="#ref-willan2004regression" role="doc-biblioref">Willan, Briggs, and Hoch 2004</a>)</span>, (non-parametric) <strong>bootstrapping</strong> procedure <span class="citation" data-cites="nixon2010non">(<a href="#ref-nixon2010non" role="doc-biblioref">Nixon, Wonderling, and Grieve 2010</a>)</span>, or even a combination of these two methods.</p>
<section id="data-generation-1" class="level2">
<h2 class="anchored" data-anchor-id="data-generation-1">Data generation</h2>
<p>As usual, let’s start by generating some artificial data that will be used to show how to implement the methods in <code>R</code>. The code used to generate these data is provided in the following (folded) code part and, if not of interest, you may skip it and jump to the actual implementation code in the next section.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#remove scientific notation to be displayed by R</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">options</span>(<span class="at">scipen=</span><span class="dv">999</span>) </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#generate data</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm) <span class="co">#load package to generate multivariate normal data</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>n0 <span class="ot">&lt;-</span> n1 <span class="ot">&lt;-</span> <span class="dv">150</span> <span class="co">#arm-specific sample sizes (0=old,1=new)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>mu0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.58</span>,<span class="dv">3</span>) <span class="co">#mean QALY and TC in old arm</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">#2x2 Covariance matrix for QALY and TC in old arm</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>Sigma0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">2</span>) </span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(Sigma0) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span><span class="sc">^</span><span class="dv">2</span>) <span class="co">#set variances for each outcome in old arm</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>rho0 <span class="ot">&lt;-</span> <span class="fl">0.75</span> <span class="co">#set correlation between outcomes in old arm</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>Sigma0[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma0[<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> rho0<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="dv">1</span> <span class="co">#set covariances in old arm</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for new arm</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>mu1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.65</span>,<span class="dv">3</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>Sigma1 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="dv">2</span>) </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(Sigma1) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span><span class="sc">^</span><span class="dv">2</span>,<span class="dv">1</span><span class="sc">^</span><span class="dv">2</span>) </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>rho1 <span class="ot">&lt;-</span> <span class="fl">0.75</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>Sigma1[<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">&lt;-</span> Sigma1[<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">&lt;-</span> rho1<span class="sc">*</span><span class="fl">0.1</span><span class="sc">*</span><span class="dv">1</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co">#generate QALY and TC data by arm</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>ec0 <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(n0, <span class="at">mean =</span> mu0, <span class="at">sigma =</span> Sigma0)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>ec1 <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(n1, <span class="at">mean =</span> mu1, <span class="at">sigma =</span> Sigma1)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">#extract each outcome variable by arm</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>QALY0 <span class="ot">&lt;-</span> ec0[,<span class="dv">1</span>]</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>QALY1 <span class="ot">&lt;-</span> ec1[,<span class="dv">1</span>]</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>TC0 <span class="ot">&lt;-</span> ec0[,<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span> <span class="co">#rescale costs</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>TC1 <span class="ot">&lt;-</span> ec1[,<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span> <span class="co">#rescale costs</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">#generate baseline values for each outcome and arm</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>u0 <span class="ot">&lt;-</span> <span class="fl">0.1</span> <span class="sc">+</span> <span class="fl">0.001</span><span class="sc">*</span>QALY0 <span class="sc">+</span> <span class="fu">rnorm</span>(n0,<span class="dv">0</span>,<span class="fl">0.25</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>u1 <span class="ot">&lt;-</span> <span class="fl">0.1</span> <span class="sc">+</span> <span class="fl">0.001</span><span class="sc">*</span>QALY1 <span class="sc">+</span> <span class="fu">rnorm</span>(n1,<span class="dv">0</span>,<span class="fl">0.25</span>)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>c0 <span class="ot">&lt;-</span> <span class="dv">100</span> <span class="sc">+</span> <span class="fl">0.001</span><span class="sc">*</span>TC0 <span class="sc">+</span> <span class="fu">rnorm</span>(n0,<span class="dv">0</span>,<span class="dv">85</span>)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>c1 <span class="ot">&lt;-</span> <span class="dv">100</span> <span class="sc">+</span> <span class="fl">0.001</span><span class="sc">*</span>TC1 <span class="sc">+</span> <span class="fu">rnorm</span>(n1,<span class="dv">0</span>,<span class="dv">85</span>)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co">#combine variables into a dataframe</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>QALY <span class="ot">&lt;-</span> <span class="fu">c</span>(QALY0, QALY1)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>TC <span class="ot">&lt;-</span> <span class="fu">c</span>(TC0, TC1)</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>u <span class="ot">&lt;-</span> <span class="fu">c</span>(u0,u1)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>c <span class="ot">&lt;-</span> <span class="fu">c</span>(c0,c1)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>trt <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"old"</span>,n0),<span class="fu">rep</span>(<span class="st">"new"</span>,n1))</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>dataset <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(QALY,TC,u,c,trt)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>dataset<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">factor</span>(trt, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"old"</span>, <span class="st">"new"</span>))</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span class="co">#randomly shuffle rows of the dataset</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>dataset <span class="ot">&lt;-</span> dataset[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(dataset)), ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Again, let’s inspect the first few rows of the newly-generated data by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dataset, <span class="at">n=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         QALY       TC           u         c trt
16  0.5702695 324.0702 -0.13975216  23.94076 old
77  0.6240807 412.6261  0.57226207  51.83082 old
83  0.5269099 281.0698  0.07965101  90.18762 old
112 0.4696755 186.8044  0.22252636 135.76419 old
66  0.5655207 313.6860 -0.14142596  24.48376 old
80  0.5576176 366.6674 -0.22197673 -37.31306 old
107 0.7560502 291.5428 -0.15671117 156.94553 old
84  0.5313837 297.7465  0.45782877 120.80797 old</code></pre>
</div>
</div>
<p>We can also check the level of <em>Pearson</em>’s correlation between QALY and TC variables by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(dataset<span class="sc">$</span>QALY,dataset<span class="sc">$</span>TC, <span class="at">method =</span> <span class="st">"pearson"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6244816</code></pre>
</div>
</div>
</section>
<section id="method-application-1" class="level2">
<h2 class="anchored" data-anchor-id="method-application-1">Method application</h2>
<p><strong>Seemingly Unrelated Regression</strong> consists in an approximation to joint of different outcome variables while also allowing separate regression model specifications for each outcome variable. The modelling approach is similar to that of OLS (see <a href="#eq-1" class="quarto-xref">Equation&nbsp;1</a>), where each outcome is regressed on given sets of independent variables. For example, considering the case of regression adjustment for baseline utilities (<span class="math inline">\(u_{i0}\)</span>) and costs (<span class="math inline">\(c_{i0}\)</span>), the SUR model would look like:</p>
<p><span id="eq-4"><span class="math display">\[
\begin{aligned}
\text{QALY}_i &amp;= \beta_0 + \beta_1\times \text{arm}_i + \beta_2\times u_{i0} + \varepsilon_{ie} \\
\text{TC}_i &amp;= \alpha_0 + \alpha_1\times \text{arm}_i + \alpha_2\times c_{i0} + \varepsilon_{ic} \\
\end{aligned}
\tag{4}\]</span></span></p>
<p>The main difference compared to running separate OLS models is that correlation between the error terms of the two equations is taken into account by assuming they follow a multivariate normal distribution:</p>
<p><span class="math display">\[
\begin{aligned}
\begin{pmatrix}
\varepsilon_{ie}\\
\varepsilon_{ic}\\
\end{pmatrix} &amp;\sim  \text{Normal}
\begin{bmatrix}
\mu=
\begin{pmatrix}
0\\
0
\end{pmatrix}\!\!,&amp;
\Sigma =\begin{pmatrix}
\sigma^2_e &amp; \rho\sigma_e\sigma_c\\
\rho\sigma_c\sigma_e &amp; \sigma^2_c
\end{pmatrix}
\end{bmatrix},
\end{aligned}
\]</span></p>
<p>with mean vector <span class="math inline">\(\mu\)</span> and covariance matrix <span class="math inline">\(\Sigma\)</span>, where: <span class="math inline">\(\sigma^2_e\)</span> and <span class="math inline">\(\sigma^2_c\)</span> denote the variances of the QALY and TC variables, while <span class="math inline">\(\rho\)</span> represents the correlation parameter capturing the association between the outcomes.</p>
<p>In <code>R</code>, the following code may be used to fit SUR equations as shown in <a href="#eq-4" class="quarto-xref">Equation&nbsp;4</a> to the generated data and summarise the output:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(systemfit) <span class="co">#load package to fit SUR</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">#fit SUR to QALY and TC separate regressions</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>sur_ec <span class="ot">&lt;-</span> <span class="fu">systemfit</span>(<span class="fu">list</span>(<span class="at">QALYreg =</span> QALY<span class="sc">~</span>trt <span class="sc">+</span> u, <span class="at">TCreg =</span> TC<span class="sc">~</span>trt <span class="sc">+</span> c), </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">method=</span><span class="st">"SUR"</span>, <span class="at">data=</span>dataset)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">#summarise output</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(sur_ec)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
systemfit results 
method: SUR 

         N  DF     SSR detRCov   OLS-R2 McElroy-R2
system 600 594 2266697  36.535 0.000907   0.135509

          N  DF           SSR         MSE      RMSE       R2    Adj R2
QALYreg 300 297       2.61745    0.008813  0.093877 0.144406  0.138645
TCreg   300 297 2266694.46182 7631.967885 87.361135 0.000907 -0.005821

The covariance matrix of the residuals used for estimation
          QALYreg     TCreg
QALYreg 0.0088027    5.5284
TCreg   5.5283958 7631.5290

The covariance matrix of the residuals
           QALYreg      TCreg
QALYreg 0.00881297    5.54305
TCreg   5.54304723 7631.96788

The correlations of the residuals
         QALYreg    TCreg
QALYreg 1.000000 0.675879
TCreg   0.675879 1.000000


SUR estimates for 'QALYreg' (equation 1)
Model Formula: QALY ~ trt + u

               Estimate  Std. Error  t value               Pr(&gt;|t|)    
(Intercept)  0.57629408  0.00781616 73.73115 &lt; 0.000000000000000222 ***
trtnew       0.07641998  0.01083463  7.05331      0.000000000012319 ***
u           -0.02836204  0.01656608 -1.71205                0.08793 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.093877 on 297 degrees of freedom
Number of observations: 300 Degrees of Freedom: 297 
SSR: 2.617453 MSE: 0.008813 Root MSE: 0.093877 
Multiple R-Squared: 0.144406 Adjusted R-Squared: 0.138645 


SUR estimates for 'TCreg' (equation 2)
Model Formula: TC ~ trt + c

               Estimate  Std. Error  t value             Pr(&gt;|t|)    
(Intercept) 294.9174847   8.7883442 33.55780 &lt; 0.0000000000000002 ***
trtnew        1.8624126  10.1335467  0.18379              0.85431    
c             0.0242418   0.0462881  0.52371              0.60087    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 87.361135 on 297 degrees of freedom
Number of observations: 300 Degrees of Freedom: 297 
SSR: 2266694.461815 MSE: 7631.967885 Root MSE: 87.361135 
Multiple R-Squared: 0.000907 Adjusted R-Squared: -0.005821 </code></pre>
</div>
</div>
<p>We can see in for the first equation (<code>QALYreg</code>) the coefficients “Estimate” column shows the values for: <span class="math inline">\(\hat{\beta}_0=0.576\)</span>, <span class="math inline">\(\hat{\beta}_1=0.076\)</span> and <span class="math inline">\(\hat{\beta}_2=-0.028\)</span>. In addition, we can also find the value for the “Residual standard error” <span class="math inline">\(\sigma=0.094\)</span>. Similarly for the second equation (<code>TCreg</code>) we have: <span class="math inline">\(\hat{\alpha}_0=294.917\)</span>, <span class="math inline">\(\hat{\alpha}_1=1.862\)</span>, <span class="math inline">\(\hat{\alpha}_2=0.024\)</span> and <span class="math inline">\(\sigma_c=87.361\)</span>. Finally, we also have estimates for the “covariance matrix of the residuals” and the “correlations of the residuals” (with an estimated correlation of <span class="math inline">\(0.676\)</span>) which we would not be able to get from fitting separate OLS models.</p>
<p>In the following (folded) code part I will show how to manually compute the estimates for mean QALY and TC variables by treatment group from the models’ regression coefficients as specified in <a href="#eq-4" class="quarto-xref">Equation&nbsp;4</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract regression coefficients for QALY model</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>betas <span class="ot">&lt;-</span> <span class="fu">coef</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#extract error standard deviation for QALY model</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="fu">summary</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>sigma</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">#extract all independent variables for QALY model</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>Xs_e <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">#compute matrix multiplication </span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>XtX.inv_e <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(Xs_e) <span class="sc">%*%</span> Xs_e) </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">#select profile to be estimated in terms of: intercept, trt, u</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>prof_old_e <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>u)) <span class="co">#1=intercept,0=trt,u=mean(u)</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>prof_new_e <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>u)) <span class="co">#1=intercept,1=trt,u=mean(u)</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">#compute linear combination of regression parameters</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>mean_old_e <span class="ot">&lt;-</span> betas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> betas[<span class="st">"u"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>u)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>mean_new_e <span class="ot">&lt;-</span> betas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> betas[<span class="st">"trtnew"</span>] <span class="sc">+</span> betas[<span class="st">"u"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>u)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co">#compute associated standard errors</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>std.err_old_e <span class="ot">&lt;-</span> sigma_e <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_old_e) <span class="sc">%*%</span> XtX.inv_e <span class="sc">%*%</span> prof_old_e)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>std.err_new_e <span class="ot">&lt;-</span> sigma_e <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_new_e) <span class="sc">%*%</span> XtX.inv_e <span class="sc">%*%</span> prof_new_e)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="co">#compute associated confidence intervals </span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>alpha<span class="ot">&lt;-</span><span class="fl">0.05</span> <span class="co">#95% CI</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>n_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(dataset)[<span class="dv">1</span>] <span class="co">#total sample size</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>df_e <span class="ot">&lt;-</span> n_e<span class="sc">-</span><span class="fu">c</span>(<span class="fu">length</span>(betas)<span class="sc">-</span><span class="dv">1</span>) <span class="co">#degrees of freedom</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>t.critic_e <span class="ot">&lt;-</span> <span class="fu">qt</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>,<span class="at">df=</span>df_e) <span class="co">#critical value for t distribution and 95% CI</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>mean_old_lower.CI_e <span class="ot">&lt;-</span> mean_old_e <span class="sc">-</span> t.critic_e<span class="sc">*</span>std.err_old_e</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>mean_old_upper.CI_e <span class="ot">&lt;-</span> mean_old_e <span class="sc">+</span> t.critic_e<span class="sc">*</span>std.err_old_e</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>mean_new_lower.CI_e <span class="ot">&lt;-</span> mean_new_e <span class="sc">-</span> t.critic_e<span class="sc">*</span>std.err_new_e</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>mean_new_upper.CI_e <span class="ot">&lt;-</span> mean_new_e <span class="sc">+</span> t.critic_e<span class="sc">*</span>std.err_new_e</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="co">#combine all results</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>mean_old_summary_e <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_old_e,std.err_old_e,mean_old_lower.CI_e,mean_old_upper.CI_e)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>mean_new_summary_e <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_new_e,std.err_new_e,mean_new_lower.CI_e,mean_new_upper.CI_e)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a><span class="co">#attach names to each value</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_old_summary_e) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_new_summary_e) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for TC model</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>alphas <span class="ot">&lt;-</span> <span class="fu">coef</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="fu">summary</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>sigma</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>Xs_c <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>XtX.inv_c <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(Xs_c) <span class="sc">%*%</span> Xs_c) </span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>prof_old_c <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>c)) <span class="co">#1=intercept,0=trt,c=mean(c)</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>prof_new_c <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="fu">mean</span>(dataset<span class="sc">$</span>c)) <span class="co">#1=intercept,1=trt,c=mean(c)</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>mean_old_c <span class="ot">&lt;-</span> alphas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> alphas[<span class="st">"c"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>c)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>mean_new_c <span class="ot">&lt;-</span> alphas[<span class="st">"(Intercept)"</span>] <span class="sc">+</span> alphas[<span class="st">"trtnew"</span>] <span class="sc">+</span> alphas[<span class="st">"c"</span>]<span class="sc">*</span><span class="fu">mean</span>(dataset<span class="sc">$</span>c)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>std.err_old_c <span class="ot">&lt;-</span> sigma_c <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_old_c) <span class="sc">%*%</span> XtX.inv_c <span class="sc">%*%</span> prof_old_c)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>std.err_new_c <span class="ot">&lt;-</span> sigma_c <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="fu">t</span>(prof_new_c) <span class="sc">%*%</span> XtX.inv_c <span class="sc">%*%</span> prof_new_c)</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>alpha<span class="ot">&lt;-</span><span class="fl">0.05</span> <span class="co">#95% CI</span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>n_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(dataset)[<span class="dv">1</span>] <span class="co">#total sample size</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>df_c <span class="ot">&lt;-</span> n_c<span class="sc">-</span><span class="fu">c</span>(<span class="fu">length</span>(alphas)<span class="sc">-</span><span class="dv">1</span>) <span class="co">#degrees of freedom</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>t.critic_c <span class="ot">&lt;-</span> <span class="fu">qt</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>,<span class="at">df=</span>df_c) <span class="co">#critical value for t distribution and 95% CI</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>mean_old_lower.CI_c <span class="ot">&lt;-</span> mean_old_c <span class="sc">-</span> t.critic_c<span class="sc">*</span>std.err_old_c</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>mean_old_upper.CI_c <span class="ot">&lt;-</span> mean_old_c <span class="sc">+</span> t.critic_c<span class="sc">*</span>std.err_old_c</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>mean_new_lower.CI_c <span class="ot">&lt;-</span> mean_new_c <span class="sc">-</span> t.critic_c<span class="sc">*</span>std.err_new_c</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>mean_new_upper.CI_c <span class="ot">&lt;-</span> mean_new_c <span class="sc">+</span> t.critic_c<span class="sc">*</span>std.err_new_c</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>mean_old_summary_c <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_old_c,std.err_old_c,mean_old_lower.CI_c,mean_old_upper.CI_c)</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>mean_new_summary_c <span class="ot">&lt;-</span> <span class="fu">c</span>(mean_new_c,std.err_new_c,mean_new_lower.CI_c,mean_new_upper.CI_c)</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_old_summary_c) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(mean_new_summary_c) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Unfortunately, the convenient functions to automatically derive marginal mean estimates from regression models in the <code>R</code> package <code>emmeans</code> are not compatible with <code>R</code> objects generated via functions from the <code>systemfit</code> package. This means that estimates for the marginal means of each outcome need to be derived manually as shown in the (folded) code part above. As a quick example, I will show now how estimates and related measures of uncertainty may be derived for the mean QALY/TC difference represented by the parameters <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(\alpha_1\)</span> in <a href="#eq-4" class="quarto-xref">Equation&nbsp;4</a>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">#extract coefficient for QALY difference from model</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>beta1 <span class="ot">&lt;-</span> <span class="fu">coef</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])[<span class="st">"trtnew"</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#extract standard error for QALY difference from model</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>SE_beta1 <span class="ot">&lt;-</span> <span class="fu">summary</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[<span class="st">"trtnew"</span>,<span class="st">"Std. Error"</span>]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">#extract CI bounds for for QALY difference from model</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>CI_lower_beta1 <span class="ot">&lt;-</span> <span class="fu">confint</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]], <span class="at">level =</span> <span class="fl">0.95</span>)[<span class="st">"trtnew"</span>,<span class="dv">1</span>]</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>CI_upper_beta1 <span class="ot">&lt;-</span> <span class="fu">confint</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]], <span class="at">level =</span> <span class="fl">0.95</span>)[<span class="st">"trtnew"</span>,<span class="dv">2</span>]</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">#combine all estimates in a single object</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>delta_e_sur <span class="ot">&lt;-</span> <span class="fu">c</span>(beta1,SE_beta1,CI_lower_beta1,CI_upper_beta1)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">#rename elements of object</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(delta_e_sur) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">#do the same for TC difference </span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>alpha1 <span class="ot">&lt;-</span> <span class="fu">coef</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])[<span class="st">"trtnew"</span>]</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>SE_alpha1 <span class="ot">&lt;-</span> <span class="fu">summary</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[<span class="st">"trtnew"</span>,<span class="st">"Std. Error"</span>]</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>CI_lower_alpha1 <span class="ot">&lt;-</span> <span class="fu">confint</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]], <span class="at">level =</span> <span class="fl">0.95</span>)[<span class="st">"trtnew"</span>,<span class="dv">1</span>]</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>CI_upper_alpha1 <span class="ot">&lt;-</span> <span class="fu">confint</span>(sur_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]], <span class="at">level =</span> <span class="fl">0.95</span>)[<span class="st">"trtnew"</span>,<span class="dv">2</span>]</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>delta_c_sur <span class="ot">&lt;-</span> <span class="fu">c</span>(alpha1,SE_alpha1,CI_lower_alpha1,CI_upper_alpha1)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(delta_c_sur) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Estimate"</span>,<span class="st">"SE"</span>,<span class="st">"CI(low)"</span>,<span class="st">"CI(high)"</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co">#print results</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>delta_e_sur</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  Estimate         SE    CI(low)   CI(high) 
0.07641998 0.01083463 0.05509761 0.09774235 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>delta_c_sur</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  Estimate         SE    CI(low)   CI(high) 
  1.862413  10.133547 -18.080240  21.805066 </code></pre>
</div>
</div>
<p>Another approach which has been suggested in the literature for “indirectly” taking into account the correlation between outcomes is the so-called (non-parametric) <strong>paired bootstrapping</strong> <span class="citation" data-cites="nixon2010non">(<a href="#ref-nixon2010non" role="doc-biblioref">Nixon, Wonderling, and Grieve 2010</a>)</span>. The underlying procedure is as follows:</p>
<ol type="1">
<li>Generate a “bootstrap” sample by <em>sampling with replacement</em> QALY and TC individual values together from the original dataset</li>
<li>Fit the desired model to the newly obtained bootstrap sample to derive bootstrap estimates for the quantities of interest (eg mean outcome differences), for example using OLS or SUR models (ie <span class="math inline">\(\hat{\beta}^b_1\)</span> and <span class="math inline">\(\hat{\alpha}^b_1\)</span>)</li>
<li>Repeat step 1-2 for a large number of bootstrap iterations <span class="math inline">\(B\)</span> (eg <span class="math inline">\(5000\)</span>) and store the results to generate a set of <span class="math inline">\(B\)</span> bootstrap estimates for <span class="math inline">\(b=1,\ldots,B\)</span></li>
<li>Use the stored sets of bootstrap estimates (ie <span class="math inline">\(\hat{\beta}^b_1\)</span> and <span class="math inline">\(\hat{\alpha}^b_1\)</span>) to <em>empirically</em> approximate the sampling distribution of the parameters of interest.</li>
<li>Use this distribution of estimates to quantify the level of uncertainty around the quantities of interest, eg in terms of confidence intervals.</li>
</ol>
<p>Since at each bootstrap iteration, in step 1, the outcome values are sampled “together” for the same individual, then correlation between the variables is preserved in the newly drawn bootstrapped samples. The following (folded) code part shows how to construct an <code>R</code> function which allows to implement a non-parametric bootstrap procedure for QALY and TC variables and derive bootstrapped estimates for marginal and incremental mean estimates by fitting a OLS or SUR model to each bootstrapped sample.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table) <span class="co">#package to handle datasets more efficiently</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bootstrap) <span class="co">#package to use bootstrap procedure </span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rlang)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>boot_ec <span class="ot">&lt;-</span> <span class="cf">function</span>(data, B, QALYreg, TCreg, <span class="at">method =</span> <span class="st">"OLS"</span>,</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">profile_QALY=</span><span class="st">"default"</span>, <span class="at">profile_TC=</span><span class="st">"default"</span>, <span class="at">trt_pos =</span> <span class="dv">2</span>){</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.data.frame</span>(data)){<span class="fu">stop</span>(<span class="st">"data needs to be a data frame object"</span>)}</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(B)){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(B<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> <span class="sc">!</span>B<span class="sc">%%</span><span class="dv">1</span><span class="sc">==</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY model"</span>)}</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC model"</span>)}</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>method <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"OLS"</span>,<span class="st">"SUR"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method name"</span>)}</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(trt_pos) <span class="sc">|</span> <span class="fu">length</span>(trt_pos)<span class="sc">!=</span><span class="dv">1</span> <span class="sc">|</span> trt_pos<span class="sc">&lt;=</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide valid trt indicator position in regressions"</span>)}</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>] <span class="co">#original sample size</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">#n covariates </span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>  nX_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(QALYreg, data))[<span class="dv">2</span>]</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>  nX_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(TCreg, data))[<span class="dv">2</span>]</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator and outcomes from provided formula</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(trt_name_e <span class="sc">!=</span> trt_name_c){<span class="fu">stop</span>(<span class="st">"please provide same trt variable name and position in QALY and TC formuale"</span>)}</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>  QALY_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[<span class="dv">1</span>]</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>  TC_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[<span class="dv">1</span>]</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check if trt indicator is factor and store its levels</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.factor</span>(data[,trt_name_e])){</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">levels</span>(data[,trt_name_e])} <span class="cf">else</span> {</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">unique</span>(data[,trt_name_e])}</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(trt_lev)<span class="sc">!=</span><span class="dv">2</span>){<span class="fu">stop</span>(<span class="st">"The function only allows comparison between two trt groups"</span>)}  </span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check that correct profile provided or set default</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(profile_QALY <span class="sc">!=</span> <span class="st">"default"</span>){</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.vector</span>(profile_QALY) <span class="sc">|</span> <span class="fu">length</span>(profile_QALY)<span class="sc">!=</span>nX_e){<span class="fu">stop</span>(<span class="st">"provide valid profile for QALYreg"</span>)}}</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(profile_TC <span class="sc">!=</span> <span class="st">"default"</span>){</span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.vector</span>(profile_TC) <span class="sc">|</span> <span class="fu">length</span>(profile_TC)<span class="sc">!=</span>nX_c){<span class="fu">stop</span>(<span class="st">"provide valid profile for TCreg"</span>)}}</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare empty objects to contain bootstrapped estimates</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>  data_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>  coeff_e <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>  coeff_c <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>  em_e_ctr <span class="ot">&lt;-</span> em_e_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>  em_c_ctr <span class="ot">&lt;-</span> em_c_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>  dataset.dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(data) <span class="co">#convert data into data.table object</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){</span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">#sample with replacement</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>    data_ec_b_list[[i]] <span class="ot">&lt;-</span> dataset.dt[<span class="fu">sample</span>(.N, n, <span class="at">replace =</span> T)]</span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">#fit model</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>    model_ec <span class="ot">&lt;-</span> <span class="fu">systemfit</span>(<span class="fu">list</span>(<span class="at">QALYreg =</span> QALYreg, <span class="at">TCreg =</span> TCreg), </span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method=</span>method, <span class="at">data=</span>data_ec_b_list[[i]])</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract covariate values</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>    X_e <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    X_c <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">#define QALYreg profile</span></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(profile_QALY <span class="sc">==</span> <span class="st">"default"</span>){</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>     profile_b_QALY <span class="ot">&lt;-</span> <span class="fu">apply</span>(X_e, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T)</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {profile_b_QALY <span class="ot">&lt;-</span> profile_QALY}</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_ctr <span class="ot">&lt;-</span> profile_b_QALY_int <span class="ot">&lt;-</span> profile_b_QALY</span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_ctr[trt_pos] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set profile for comparator</span></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_int[trt_pos] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#set profile for reference</span></span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">#define TCreg profile</span></span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(profile_TC <span class="sc">==</span> <span class="st">"default"</span>){</span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a>     profile_b_TC <span class="ot">&lt;-</span> <span class="fu">apply</span>(X_c, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T)</span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {profile_b_TC <span class="ot">&lt;-</span> profile_TC}</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_ctr <span class="ot">&lt;-</span> profile_b_TC_int <span class="ot">&lt;-</span> profile_b_TC</span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_ctr[trt_pos] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set profile for comparator</span></span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_int[trt_pos] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#set profile for reference</span></span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract coefficient estimates from each model</span></span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>    coeff_e[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a>    coeff_c[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute linear combination of parameters</span></span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a>    em_e_ctr[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_QALY_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a>    em_e_int[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_QALY_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a>    em_c_ctr[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_TC_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a>    em_c_int[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_TC_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create list objects to store all results </span></span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a>  res_e_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>coeff_e,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>em_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>em_e_int)</span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a>  res_c_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_c"</span><span class="ot">=</span>coeff_c,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>em_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>em_c_int)</span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>  input_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"data"</span><span class="ot">=</span>data, <span class="st">"method"</span><span class="ot">=</span>method, <span class="st">"trt_pos"</span><span class="ot">=</span>trt_pos, <span class="st">"QALYreg"</span><span class="ot">=</span>QALYreg,</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TCreg"</span><span class="ot">=</span>TCreg,<span class="st">"profile_QALY_ctr"</span><span class="ot">=</span>profile_b_QALY_ctr,</span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"profile_QALY_int"</span><span class="ot">=</span>profile_b_QALY_int,<span class="st">"profile_TC_ctr"</span><span class="ot">=</span>profile_b_TC_ctr,</span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"profile_TC_int"</span><span class="ot">=</span>profile_b_TC_int)</span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute overall list and return it as output from the function</span></span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a>  res_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"QALY_boot"</span><span class="ot">=</span>res_e_b_list,<span class="st">"TC_boot"</span><span class="ot">=</span>res_c_b_list,<span class="st">"inputs"</span><span class="ot">=</span>input_list)</span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(res_ec_b_list) <span class="ot">&lt;-</span> <span class="st">"bootCE"</span></span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_ec_b_list)</span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can now apply the newly created bootstrap function called <code>boot_res</code> to our generated dataset to obtain <span class="math inline">\(B=200\)</span> bootstrapped estimates for the parameters of interest, which are here stored in a list object called <code>boot_res</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to dataset</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>boot_res <span class="ot">&lt;-</span> <span class="fu">boot_ec</span>(<span class="at">data =</span> dataset, <span class="at">QALYreg =</span> QALY <span class="sc">~</span> trt <span class="sc">+</span> u,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">TCreg =</span> TC <span class="sc">~</span> trt <span class="sc">+</span> c, <span class="at">method =</span> <span class="st">"OLS"</span>, <span class="at">B=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can access the bootstrapped estimates for a given quantity, eg mean QALY and TC difference between treatment groups (New vs Old), by typing <code>boot_res$QALY_boot$Delta_e</code> and <code>boot_res$QALY_boot$Delta_c</code>, respectively. Once extracted, we can then inspect the distribution of <span class="math inline">\(\Delta_e\)</span>, for example, with an histogram.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="code_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid figure-img" width="480"></p>
</figure>
</div>
</div>
</div>
<p>In a similar way, the function also produces bootstrapped estimates for the mean QALY values in the comparator (Old) and reference (New) arm by typing <code>boot_res$QALY_boot$mu_e_ctr</code> and <code>boot_res$QALY_boot$mu_e_int</code>, which were derived at each bootstrap iteration using the same approach as in <a href="#sec-baseadj" class="quarto-xref">Section&nbsp;1</a>. Similar results with respect to the TC parameters can be obtained using the corresponding list names <code>Delta_c</code>,<code>mu_c_ctr</code> and <code>mu_c_int</code>.</p>
<p><strong>Important Disclaimer</strong>. The above bootstrap function is quite flexible in that it allows to derive bootstrapped estimates for different CE quantities. However, it should <strong>NOT</strong> be implemented blindly. For example, when computing these quantities, it assumes that the treatment indicator is always placed as the first independent variable in both QALY and TC regression model formulae. If this is not true, then the estimates produced will be <strong>incorrect</strong> since they will correspond to the coefficients of some other independent variable! The position of the treatment indicator may be changed through a specific (optional) argument called <code>trt_pos</code>, by default set to <span class="math inline">\(2\)</span> (since position <span class="math inline">\(1\)</span> corresponds to the intercept in both models). In addition, mean outcome values for each treatment group are obtained as linear combination of the QALY/TC regression parameters in combination with specific covariate profiles (ie one for the comparator and one for the reference intervention). These profiles are computed under the assumption that, except the treatment indicator, all other independent variables should be set at their mean value. This is generally ok when interest is in the average estimates but makes little sense when interest is instead in retrieving estimates for specific covariate profiles. A typical example of this would be when a categorical or factor covariate (eg gender) is included in the models and that estimates for mean QALY/TC values should be produced for a given value for that variable (eg only for males). In this latter case, estimates produced by the default settings of the function will be <strong>incorrect</strong> since they are evaluated at the mean values for all covariates (except the treatment indicator). The function is provided with (optional) arguments called <code>profile_QALY</code> and <code>profile_TC</code> which allow the user to specify a custom covariate profile for each regression but, unless the user is familiar with how to correctly specify these profiles, care should be used in the interpretation of the generated estimates. <strong>All this to say, be careful about blindly using non-standard functions as, if you do not know how they work or how to interpret the output they produce, you may run the risk of generating completely nonsensical results!</strong>.</p>
<p>The entire bootstrap distribution of mean QALY/TC difference and/or those for the mean outcomes in each treatment group obtained through the function <code>boot_ec</code> may be used to generate standard CEA graphs such as the CE plane <span class="citation" data-cites="black1990plane">(<a href="#ref-black1990plane" role="doc-biblioref">Black 1990</a>)</span> and CE acceptability curve <span class="citation" data-cites="fenwick2001representing">(<a href="#ref-fenwick2001representing" role="doc-biblioref">Fenwick, Claxton, and Sculpher 2001</a>)</span>. However, for the purpose of summarising uncertainty about the derived quantities, standard statistical measures such as confidence intervals should also be produced. Alternative ways to compute CIs based on bootstrapped estimates for a given quantity have been developed and compared, including in the context of CEA <span class="citation" data-cites="briggs1997pulling briggs1999constructing">(<a href="#ref-briggs1997pulling" role="doc-biblioref">Briggs, Wonderling, and Mooney 1997</a>; <a href="#ref-briggs1999constructing" role="doc-biblioref">Briggs, Mooney, and Wonderling 1999</a>)</span>. Although initial methods focussed on the computation of CIs for Incremental <em>Cost-Effectiveness Ratio</em> (ICER), its ratio nature makes it quite difficult to provide sensible interpretations to confidence bounds in many scenarios <span class="citation" data-cites="glick2014economic">(<a href="#ref-glick2014economic" role="doc-biblioref">Glick et al. 2014</a>)</span>. As a result, interest has been shifted towards the quantification of uncertainty via CIs for alternative quantities, such as the <em>Net Monetary Benefit</em> (NMB) which is a linear function of the mean differences in QALYs and TCs <span class="citation" data-cites="stinnett1998net">(<a href="#ref-stinnett1998net" role="doc-biblioref">Stinnett and Mullahy 1998</a>)</span>.</p>
<p>The following (folded) code part shows how to obtain confidence intervals for any of the quantity derived from the <code>boot_ec</code> function using two popular approaches in the CEA literature: the <em>empirical percentile</em> (perc) method and the <em>bias-corrected and accelerated</em> (BCa) method. Although other approaches exist to derive confidence intervals for bootstrapped estimates, and a clear “best” approach in all possible scenarios has not been identified, these two approaches are by far those most commonly implemented in trial-based CEAs. In general, the perc approach is very easy to implement but has well known limitations, especially in small samples, in that it produces intervals that tend to be too narrow. The BCa approach, conversely, is generally regarded as a more robust version for computing intervals as it computes the CI bounds while introducing a bias and skewness correction term to improve the coverage performance in many scenarios <span class="citation" data-cites="briggs1997pulling">(<a href="#ref-briggs1997pulling" role="doc-biblioref">Briggs, Wonderling, and Mooney 1997</a>)</span>. I have coded two functions, one called <code>jk_ec</code>, which is used to obtain jackknife estimates based on the original sample (needed to compute the BCa intervals), and another called <code>boot_ci</code>, which is the main function used to get the intervals. At the moment, both need to be loaded into the <code>R</code> workspace in order to compute the intervals and they also require as input the results generated by the previous function <code>boot_ec</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">#jackknife sampling function (used to compute BCa interval inside main boot_ci function)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>jk_ec <span class="ot">&lt;-</span> <span class="cf">function</span>(data,QALYreg,TCreg,trt_pos,profile_QALY_ctr,profile_QALY_int,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                   profile_TC_ctr,profile_TC_int,or_method){</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare objects to store results</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  jk_delta_c_i <span class="ot">&lt;-</span> jk_delta_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  jk_mu0_c_i <span class="ot">&lt;-</span> jk_mu0_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  jk_mu1_c_i <span class="ot">&lt;-</span> jk_mu1_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife re-sampling</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    data_i <span class="ot">&lt;-</span> data[<span class="sc">-</span>i,]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain estimates of interest</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    model_ec_i <span class="ot">&lt;-</span> <span class="fu">systemfit</span>(<span class="fu">list</span>(<span class="at">QALYreg =</span> QALYreg, <span class="at">TCreg =</span> TCreg), </span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method=</span>or_method, <span class="at">data=</span>data_i)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    jk_delta_e_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    jk_delta_c_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    jk_mu0_e_i[i] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_QALY_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    jk_mu1_e_i[i] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_QALY_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    jk_mu0_c_i[i] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_TC_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    jk_mu1_c_i[i] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_TC_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec_i<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>  jk_est_i <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(jk_delta_e_i,jk_delta_c_i,jk_mu0_e_i,jk_mu1_e_i,jk_mu0_c_i,jk_mu1_c_i)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(jk_est_i) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"jk_Delta_e"</span>,<span class="st">"jk_Delta_c"</span>,<span class="st">"jk_mu_e_ctr"</span>,<span class="st">"jk_mu_e_int"</span>,<span class="st">"jk_mu_c_ctr"</span>,<span class="st">"jk_mu_c_int"</span>)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(jk_est_i)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>boot_ci <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">method =</span> <span class="st">"perc"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>){</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">inherits</span>(x, <span class="fu">c</span>(<span class="st">"bootCE"</span>,<span class="st">"tsbootCE"</span>))) {<span class="fu">stop</span>(<span class="st">"Only objects of class 'bootCE' or can 'tsbootCE' be used"</span>)}</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>method <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"perc"</span>,<span class="st">"BCa"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method name"</span>)}</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(confidence)){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(confidence<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> confidence<span class="sc">&gt;=</span><span class="dv">1</span>){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract information from inputs</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>  B <span class="ot">&lt;-</span> <span class="fu">length</span>(x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e)</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>  mu_e_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_ctr</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>  mu_e_int <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_int</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>  Delta_e <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>  mu_c_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_ctr</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>  mu_c_int <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_int</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>  Delta_c <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>Delta_c</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> confidence</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute CI bounds according to method chosen</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"perc"</span>){</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"BCa"</span>){</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    or_method <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>method</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>data</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    trt_pos <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>trt_pos</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    QALYreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALYreg</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>    TCreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TCreg</span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>    profile_QALY_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>profile_QALY_ctr</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>    profile_QALY_int <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>profile_QALY_int</span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>    profile_TC_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>profile_TC_ctr</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>    profile_TC_int <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>profile_TC_int</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain avg BCa estimates based on original sample</span></span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a>    model_ec <span class="ot">&lt;-</span> <span class="fu">systemfit</span>(<span class="fu">list</span>(<span class="at">QALYreg =</span> QALYreg, <span class="at">TCreg =</span> TCreg), </span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method=</span>or_method, <span class="at">data=</span>data)</span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_e <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_c <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_QALY_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_int <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_QALY_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_TC_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_int <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">t</span>(profile_TC_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>])</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute proportion of samples below avg estimates</span></span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>    plower_Delta_e <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_e[Delta_e<span class="sc">&lt;</span>avg_BCa_Delta_e])<span class="sc">/</span>B</span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>    plower_Delta_c <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_c[Delta_c<span class="sc">&lt;</span>avg_BCa_Delta_c])<span class="sc">/</span>B</span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_ctr[mu_e_ctr<span class="sc">&lt;</span>avg_BCa_mu_e_ctr])<span class="sc">/</span>B</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_int[mu_e_int<span class="sc">&lt;</span>avg_BCa_mu_e_int])<span class="sc">/</span>B</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_ctr[mu_c_ctr<span class="sc">&lt;</span>avg_BCa_mu_c_ctr])<span class="sc">/</span>B</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_int[mu_c_int<span class="sc">&lt;</span>avg_BCa_mu_c_int])<span class="sc">/</span>B</span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute bias-correction term</span></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a>    z0_Delta_e <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_e, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-79"><a href="#cb25-79" aria-hidden="true" tabindex="-1"></a>    z0_Delta_c <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_c, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-80"><a href="#cb25-80" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife sampling functions to get jeckknife estimates</span></span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a>    jk_res <span class="ot">&lt;-</span> <span class="fu">jk_ec</span>(<span class="at">data =</span> data, <span class="at">QALYreg=</span>QALYreg,<span class="at">TCreg=</span>TCreg,<span class="at">trt_pos=</span>trt_pos,</span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a>                        <span class="at">profile_QALY_ctr=</span>profile_QALY_ctr,<span class="at">profile_QALY_int=</span>profile_QALY_int,</span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a>                        <span class="at">profile_TC_ctr=</span>profile_TC_ctr,<span class="at">profile_TC_int=</span>profile_TC_int,<span class="at">or_method=</span>or_method)</span>
<span id="cb25-88"><a href="#cb25-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute avg of jk estimates</span></span>
<span id="cb25-89"><a href="#cb25-89" aria-hidden="true" tabindex="-1"></a>    jk_res_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(jk_res, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T) </span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute skewness correction term</span></span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a>    a_Delta_e <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a>    a_Delta_c <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a>    a_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a>    a_mu_e_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a>    a_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>    a_mu_c_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))    </span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute adjusted probs for getting desired confidence level</span></span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a>    z_alpha1 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>    z_alpha2 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb25-100"><a href="#cb25-100" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-101"><a href="#cb25-101" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain quantiles on original scale</span></span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_ctr,ci_u_mu_e_ctr))</span>
<span id="cb25-114"><a href="#cb25-114" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_int,ci_u_mu_e_int))</span>
<span id="cb25-115"><a href="#cb25-115" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_e,ci_u_Delta_e))</span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_ctr,ci_u_mu_c_ctr))</span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_int,ci_u_mu_c_int))</span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_c,ci_u_Delta_c))</span>
<span id="cb25-119"><a href="#cb25-119" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb25-120"><a href="#cb25-120" aria-hidden="true" tabindex="-1"></a>  <span class="co">#organise and return results</span></span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a>  res_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>ci_Delta_e,<span class="st">"Delta_c"</span><span class="ot">=</span>ci_Delta_c,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>ci_mu_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>ci_mu_e_int,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>ci_mu_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>ci_mu_c_int)</span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_list)</span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As an example, we can now apply the newly created bootstrap function called <code>boot_ci</code> to our bootstrap results stored in the object <code>boot_res</code> to compute bootstrapped confidence intervals for all stored quantities using either the percentile or BCa approach (selected through the argument <code>method</code>).</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to bootstrap results</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>boot_ci_bca <span class="ot">&lt;-</span> <span class="fu">boot_ci</span>(<span class="at">x =</span> boot_res, <span class="at">method =</span> <span class="st">"BCa"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>boot_ci_bca</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$Delta_e
 2.655003%  97.64746% 
0.05583106 0.09830066 

$Delta_c
1.886311% 96.72076% 
-15.25787  21.70418 

$mu_e_ctr
 3.48715% 98.23841% 
0.5612709 0.5915057 

$mu_e_int
2.478735% 97.47866% 
0.6361601 0.6636482 

$mu_c_ctr
2.907112% 97.85471% 
 283.1276  309.8906 

$mu_c_int
3.023147% 97.94824% 
 285.7260  313.8358 </code></pre>
</div>
</div>
<p>The above code computes and displays <span class="math inline">\(95\%\)</span> BCa intervals for each store quantity from the previous bootstrap function, namely the mean QALY and TC difference (<span class="math inline">\(\Delta_e, \Delta_c\)</span>), and the mean QALY/TC in each treatment group (<span class="math inline">\(\mu_e,\mu_c\)</span>), here referred to as “control” (ctr) and “intervetion” (int).</p>
</section>
<section id="summary-1" class="level2">
<h2 class="anchored" data-anchor-id="summary-1">Summary</h2>
<p>While <strong>SUR</strong> has been widely applied in trial-based CEA to account for the correlation between outcomes, mainly for its ease of implementation, its standalone implementation still has similar limitations to those of standard OLS approaches, eg reliance on Normality assumptions (see <a href="#sec-baseadj" class="quarto-xref">Section&nbsp;1</a>). For this reason it has been advocated the use of non-parametric <strong>bootstrapping</strong> as an alternative approach, which have been shown to produce adequate inferences while also retaining the correlation structure in the data through paired resampling methods. In addition, it is also possible to combine SUR and bootstrapping together within a single procedure, as also the code developed in this section showed.</p>
<p>However, due to its simulation-based nature, the performance of non-parametric bootstrapping in CEA for handling correlation <strong>has not been fully assessed</strong> and some areas of uncertainty remains. These include:</p>
<ul>
<li><p>Performance of bootstrapping with respect to <strong>proper joint models</strong>, which can formally take into account the correlation among multivariate outcomes. While joint models typically perform better for handling normally distributed outcomes, their relative performance with respect to non-parametric bootstrapping for non-normally distributed outcomes in small samples is still unclear.</p></li>
<li><p>Alternative approaches for confidence intervals computation. Although, in the use of <strong>BCa</strong> methods is recommended, the relative performance of alternative approaches in general scenarios has not been fully assessed. In some case, eg small samples and high degree of skewness, some approaches to CI computation can lead to quite different results and are potentially biased/inefficient <span class="citation" data-cites="briggs1997pulling briggs1999constructing">(<a href="#ref-briggs1997pulling" role="doc-biblioref">Briggs, Wonderling, and Mooney 1997</a>; <a href="#ref-briggs1999constructing" role="doc-biblioref">Briggs, Mooney, and Wonderling 1999</a>)</span>.</p></li>
</ul>
<p>Despite the performance of bootstrapping not being fully assessed, its use in CEA is needed in that CE results need to be expressed in the form of “distributions” for the parameters of interest, eg mean QALY/TC incrementals and, within a frequentist framework, resampling methods allow to obtain empirical estimates of these distributions which can then be used to generate standard CEA output (eg CE plane). We note that, when a Bayesian framework is used instead, implementation of non-normal joint models becomes considerably easier and have been shown to perform quite well in the context of CEA <span class="citation" data-cites="nixon2005methods lambert2008estimating conigliani2009bayesian gabrio2019full achana2021multivariate">(<a href="#ref-nixon2005methods" role="doc-biblioref">Nixon and Thompson 2005</a>; <a href="#ref-lambert2008estimating" role="doc-biblioref">Lambert et al. 2008</a>; <a href="#ref-conigliani2009bayesian" role="doc-biblioref">Conigliani and Tancredi 2009</a>; <a href="#ref-gabrio2019full" role="doc-biblioref">Gabrio, Mason, and Baio 2019</a>; <a href="#ref-achana2021multivariate" role="doc-biblioref">Achana et al. 2021</a>)</span>.</p>
</section>
</section>
<section id="sec-skew" class="level1">
<h1>Skewness in CE outcomes</h1>
<p>A general concern in trial-based CEA is the presence of high degrees of skewness in the outcome variables, especially costs. This is due to the specific nature of outcome data:</p>
<ul>
<li><p>Costs are bounded below at <span class="math inline">\(0\)</span> and in many cases are characterised by empirical distributions that are highly <strong>skewed to the right</strong> (positively skewed), with many individuals associated with no or very low costs and a few individuals associated with very high costs.</p></li>
<li><p>QoL utilities (used to construct QALYs) are bounded above at <span class="math inline">\(1\)</span> and, especially in the context of non-life threatening interventions, are characterised by empirical distributions that are <strong>skewed to the left</strong> (negatively skewed), with many individuals associated with a perfect or high utility score (health state) and a few individuals associated with lower scores.</p></li>
</ul>
<p>These features of CE data pose a threat to the validity of results derived from methods that rely on <em>normality assumptions</em> such as OLS and SUR models, or even parametric (eg Central Limit Theorem) and non-parametric (non-parametric tests or bootstrapping) methods that rely on <em>asymptotic results</em>, especially in the presence of high degree of skeweness and small samples <span class="citation" data-cites="thompson2000should o2003assessing nixon2010non">(<a href="#ref-thompson2000should" role="doc-biblioref">Thompson and Barber 2000</a>; <a href="#ref-o2003assessing" role="doc-biblioref">O’Hagan and Stevens 2003</a>; <a href="#ref-nixon2010non" role="doc-biblioref">Nixon, Wonderling, and Grieve 2010</a>)</span>. The main problem is related to the definition of “too high” degree of skewness or “too small” sample size, on which a general consensus is lacking since performance of the methods can be highly affected by the specific combination of these two elements. In addition, options such as <strong>data transformation</strong> (eg take log) are not desirable since CE inference should be made on the arithmetic mean of the outcome variables on their original scale, which are usually not easily accessible when applying some transformation to the data <span class="citation" data-cites="barber2000analysis">(<a href="#ref-barber2000analysis" role="doc-biblioref">J. A. Barber and Thompson 2000</a>)</span>.</p>
<p>To deal with skewness in small samples in CEA, the recommended approach in the literature consists in some form of <strong>Generalised Linear Model</strong> (GLM) regression framework <span class="citation" data-cites="thompson2005sensitive barber2004multiple">(<a href="#ref-thompson2005sensitive" role="doc-biblioref">Thompson and Nixon 2005</a>; <a href="#ref-barber2004multiple" role="doc-biblioref">J. Barber and Thompson 2004</a>)</span>, which allow to choose alternative parametric distributional assumptions (eg Gamma) about the individual residuals to formally account for high levels of skewness. Although <em>(non-parametric) bootstrapping</em> is often advocated as a possible approach to handle skewness, its performance has been shown to be not optimal when facing high degrees of skewness in small samples <span class="citation" data-cites="nixon2010non">(<a href="#ref-nixon2010non" role="doc-biblioref">Nixon, Wonderling, and Grieve 2010</a>)</span>. However, it is important to remember that, within a frequentist framework for CEA, use of bootstrapping is often required in order to generate approximate empirical distributions of the quantities of interest and use them to obtain standard CE output.</p>
<section id="data-generation-2" class="level2">
<h2 class="anchored" data-anchor-id="data-generation-2">Data generation</h2>
<p>In this section I will once more generate some artificial data that will be used to show how the desired methods can be implemented in <code>R</code>. The code used to generate these data is provided in the following (folded) code part and, if not of interest, you may skip it and jump to the actual implementation code in the next section.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set parameter values for generating data</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>n_sam <span class="ot">&lt;-</span> <span class="dv">20</span> <span class="co">#sample size</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>mu_u <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.86</span>,<span class="fl">0.9</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>sigma_u <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.2</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>tau_u <span class="ot">&lt;-</span> (mu_u<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>mu_u)<span class="sc">/</span>sigma_u<span class="sc">^</span><span class="dv">2-1</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>shape1_u <span class="ot">&lt;-</span> mu_u<span class="sc">*</span>tau_u</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>shape2_u <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">-</span>mu_u)<span class="sc">*</span>tau_u</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>mu_c <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">100</span>,<span class="dv">125</span>) </span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>sigma_c <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">17</span>,<span class="dv">17</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>shape_c <span class="ot">&lt;-</span> mu_c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>sigma_c<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>scale_c <span class="ot">&lt;-</span> sigma_c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>mu_c</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co">#generaten QALY and TC data assuming Beta and Gamma distributions by arm</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>sam0_u <span class="ot">&lt;-</span> <span class="fu">rbeta</span>(n_sam<span class="sc">/</span><span class="dv">2</span>,<span class="at">shape1 =</span> shape1_u[<span class="dv">1</span>], <span class="at">shape2 =</span> shape2_u[<span class="dv">1</span>])</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>sam1_u <span class="ot">&lt;-</span> <span class="fu">rbeta</span>(n_sam<span class="sc">/</span><span class="dv">2</span>,<span class="at">shape1 =</span> shape1_u[<span class="dv">2</span>], <span class="at">shape2 =</span> shape2_u[<span class="dv">2</span>])</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>sam0_c <span class="ot">&lt;-</span> <span class="fu">rgamma</span>(n_sam<span class="sc">/</span><span class="dv">2</span>, <span class="at">shape =</span> shape_c[<span class="dv">1</span>], <span class="at">scale =</span> scale_c[<span class="dv">1</span>])</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>sam1_c <span class="ot">&lt;-</span> <span class="fu">rgamma</span>(n_sam<span class="sc">/</span><span class="dv">2</span>, <span class="at">shape =</span> shape_c[<span class="dv">2</span>], <span class="at">scale =</span> scale_c[<span class="dv">2</span>])</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="co">#combine arm data and generate baseline u and c values</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>sam_u <span class="ot">&lt;-</span> <span class="fu">c</span>(sam0_u,sam1_u)</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>base_u <span class="ot">&lt;-</span> <span class="fl">0.75</span> <span class="sc">+</span> <span class="fl">0.5</span><span class="sc">*</span>sam_u <span class="sc">+</span> <span class="fu">rnorm</span>(n_sam, <span class="dv">0</span>, <span class="fl">0.05</span>) </span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>sam_c <span class="ot">&lt;-</span> <span class="fu">c</span>(sam0_c,sam1_c)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>base_c <span class="ot">&lt;-</span> <span class="dv">50</span> <span class="sc">+</span> <span class="fl">0.01</span><span class="sc">*</span>sam_c <span class="sc">+</span> <span class="fu">rnorm</span>(n_sam, <span class="dv">0</span>, <span class="fl">0.5</span>) </span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="co">#create trt indicator</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>trt <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"old"</span>,n_sam<span class="sc">/</span><span class="dv">2</span>),<span class="fu">rep</span>(<span class="st">"new"</span>,n_sam<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="co">#combine variables into a dataframe</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>dataset_sam_skew.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(sam_u,sam_c,base_u,base_c,trt)</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(dataset_sam_skew.df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"QALY"</span>,<span class="st">"TC"</span>,<span class="st">"u"</span>,<span class="st">"c"</span>,<span class="st">"trt"</span>)</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="co">#randomly shuffle rows of the dataset</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>dataset_sam_skew.df <span class="ot">&lt;-</span> dataset_sam_skew.df[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(dataset_sam_skew.df)), ]</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="co">#define trt indicator as factor</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>dataset_sam_skew.df<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">factor</span>(dataset_sam_skew.df<span class="sc">$</span>trt, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"old"</span>,<span class="st">"new"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can inspect the first few rows of the newly-generated data by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dataset_sam_skew.df, <span class="at">n=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        QALY        TC        u        c trt
16 0.9966611 118.19067 1.315029 51.47245 new
14 0.9970156 107.64264 1.253033 50.77574 new
12 0.9457835 132.33424 1.196667 51.32995 new
10 0.9496251  87.06468 1.294377 51.07543 old
3  0.9652897 102.36302 1.273476 51.03935 old
13 0.8985183 149.15977 1.259549 52.20984 new
4  0.6181245  86.65457 1.023924 50.95642 old
1  0.9931256 120.79056 1.229032 50.91415 old</code></pre>
</div>
</div>
<p>As an example, we can visually check the level of <em>skewness</em> for QALYs using boxplots, by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(dataset_sam_skew.df<span class="sc">$</span>QALY, <span class="at">ylab=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"QALY"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="code_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="method-application-2" class="level2">
<h2 class="anchored" data-anchor-id="method-application-2">Method application</h2>
<p><strong>Generalised Linear Models</strong> (GLM) share a similar regression framework to those of OLS and SUR (<a href="#sec-baseadj" class="quarto-xref">Section&nbsp;1</a> and <a href="#sec-corr" class="quarto-xref">Section&nbsp;2</a>), where a given dependent variable, eg QALY or TC, is assumed to be a function of some independent variables through some regression coefficients <span class="math inline">\(\beta\)</span> and some random error term <span class="math inline">\(\varepsilon_i\)</span>. A (simplified) representation of the GLM regression equations for the two CE outcomes may look something like:</p>
<p><span id="eq-5"><span class="math display">\[
\begin{aligned}
\text{E}[\text{QALY}_i] &amp;= g_e(\beta_0 + \beta_1\times \text{arm}_i + \beta_2\times u_{i0})^{-1} \\
\text{E}[\text{TC}_i] &amp;= g_c(\alpha_0 + \alpha_1\times \text{arm}_i + \alpha_2\times c_{i0})^{-1} \\
\end{aligned}
\tag{5}\]</span></span></p>
<p>where <span class="math inline">\(\text{E}[\text{QALY}_i]\)</span> and <span class="math inline">\(\text{E}[\text{TC}_i]\)</span> denote the expected value of the two variables, expressed as a function of some regression coefficients and independent variables. Compared to standard regression, there are two main differences:</p>
<ul>
<li><p>The expected value is not a direct linear function of the parameters and variables, which are included linearly in the equation after some function <span class="math inline">\(g(\cdot)\)</span> is applied. This is typical of GLM in that in many cases the range of the outcomes is bounded (above or below some values) and therefore a so-called <strong>link function</strong> <span class="math inline">\(g(\cdot)\)</span> is used to allow a linear regression specification of the model on an unrestricted scale, which would otherwise be difficult to achieve. Estimates are then back-transformed on the original scale by applying the inverse function <span class="math inline">\(g(\cdot)^{-1}\)</span>. Examples of typical link functions include: <em>log, logit, square root, and identity</em> (ie no scaling). Their choice is mainly drive by the specific type of outcome variables and distributional assumptions made about the error term.</p></li>
<li><p>The individual error term <span class="math inline">\(\varepsilon_i\)</span> is not assumed to follow a normal distribution, but <strong>alternative parametric distributional forms</strong> are used, such as <em>Beta, Gamma, Bernoulli, or Negative Binomial</em>. The specific distributional choice is mainly driven again by the type of outcome variable which needs to be modelled.</p></li>
</ul>
<p>In <code>R</code>, the following code may be used to fit GLMs as shown in <a href="#eq-5" class="quarto-xref">Equation&nbsp;5</a> assuming Beta-distributions for the QALY and Gamma distributions for the TC data, assuming a logit link function for the former and an identity link function for the latter. The code also shows how to summarise the generated output.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mfx) <span class="co">#load package to fit beta regression</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">#fit Beta regression to QALY assuming logit link</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>glm_e <span class="ot">&lt;-</span> <span class="fu">betareg</span>(QALY <span class="sc">~</span> trt <span class="sc">+</span> u, <span class="at">data =</span> dataset_sam_skew.df,  <span class="at">link =</span> <span class="st">"logit"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">#fit Gamma regression to TC assuming identity link</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TC <span class="sc">~</span> trt <span class="sc">+</span> c, <span class="at">data =</span> dataset_sam_skew.df, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> <span class="st">"identity"</span>))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">#summarise output</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(glm_e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
betareg(formula = QALY ~ trt + u, data = dataset_sam_skew.df, link = "logit")

Quantile residuals:
    Min      1Q  Median      3Q     Max 
-2.0387 -0.4169  0.0253  0.5370  1.8036 

Coefficients (mean model with logit link):
            Estimate Std. Error z value            Pr(&gt;|z|)    
(Intercept) -12.0426     1.6704  -7.209 0.00000000000056158 ***
trtnew        0.4970     0.4229   1.175                0.24    
u            12.2652     1.5441   7.943 0.00000000000000197 ***

Phi coefficients (precision model with identity link):
      Estimate Std. Error z value Pr(&gt;|z|)   
(phi)   26.244      9.543    2.75  0.00596 **
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 

Type of estimator: ML (maximum likelihood)
Log-likelihood: 54.13 on 4 Df
Pseudo R-squared: 0.4825
Number of iterations: 37 (BFGS) + 5 (Fisher scoring) </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(glm_c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = TC ~ trt + c, family = Gamma(link = "identity"), 
    data = dataset_sam_skew.df)

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)   
(Intercept) -463.632    284.001  -1.633  0.12096   
trtnew        25.654      6.729   3.812  0.00139 **
c             11.047      5.586   1.978  0.06442 . 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for Gamma family taken to be 0.01431784)

    Null deviance: 0.66693  on 19  degrees of freedom
Residual deviance: 0.24186  on 17  degrees of freedom
AIC: 165.32

Number of Fisher Scoring iterations: 5</code></pre>
</div>
</div>
<p>Note that direct interpretation of the above model coefficients can be difficult due to the use of different link functions and non-normal distributional assumptions. However, we can use the convenient <code>emmeans</code> function from the package <code>emmean</code> to compute point and uncertainty estimates for mean QALY and TC variables on the original scale by treatment group (and the difference between groups using the <code>contrast</code> function) from the model output. The code part below shows how to do this.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">#compute mean QALY and TC by arm on original scale</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>glm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_e, <span class="sc">~</span> trt)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>glm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_c, <span class="sc">~</span> trt)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">#print results for QALYs (example)</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>glm_e.em</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> trt emmean     SE  df asymp.LCL asymp.UCL
 old  0.948 0.0144 Inf     0.920     0.976
 new  0.968 0.0108 Inf     0.947     0.989

Confidence level used: 0.95 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">#specify and compute mean differences between groups (New - Old)</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>diff_NewvsOld <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"New vs Old"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>glm_em_delta_e <span class="ot">&lt;-</span> <span class="fu">confint</span>(<span class="fu">contrast</span>(glm_e.em, diff_NewvsOld))</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>glm_em_delta_c <span class="ot">&lt;-</span> <span class="fu">confint</span>(<span class="fu">contrast</span>(glm_c.em, diff_NewvsOld))</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">#print results for QALYs difference (example)</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>glm_em_delta_e</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> contrast   estimate     SE  df asymp.LCL asymp.UCL
 New vs Old   0.0196 0.0168 Inf   -0.0133    0.0525

Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>The following (folded) code part shows how to construct an <code>R</code> function which allows to implement a non-parametric bootstrap procedure for QALY and TC variables and derive bootstrapped estimates for marginal and incremental mean estimates by fitting a GLM to the outcomes for each bootstrapped sample.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">#note that compared to the function developed before for OLS/SUR models, this one</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">#does not require to provide profiles for the computation of mean estimates but instead relies on the emmeans function to obtain these estimates without manual computation. Because of this the function is less flexible and can only evaluate mean estimates assuming a single profile for both QALY and TC models (the one used by emmeans to compute these quantities). However, the function needs the user to specify different distributions and link functions for the QALY and TC models. </span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rlang)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mfx) </span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bootstrap)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>boot_ec_glm <span class="ot">&lt;-</span> <span class="cf">function</span>(data, B, QALYreg, TCreg, QALY_dist, TC_dist, </span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                        QALY_link, TC_link, <span class="at">trt_pos =</span> <span class="dv">2</span>){</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.data.frame</span>(data)){<span class="fu">stop</span>(<span class="st">"data needs to be a data frame object"</span>)}</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(B)){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(B<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> <span class="sc">!</span>B<span class="sc">%%</span><span class="dv">1</span><span class="sc">==</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY model"</span>)}</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC model"</span>)}</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>QALY_dist <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Beta"</span>,<span class="st">"Binomial"</span>,<span class="st">"NegBinomial"</span>,<span class="st">"Gamma"</span>,<span class="st">"InvGaussian"</span>,<span class="st">"Poisson"</span>,<span class="st">"Gaussian"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid distribution name"</span>)}</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>TC_dist <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Beta"</span>,<span class="st">"Binomial"</span>,<span class="st">"NegBinomial"</span>,<span class="st">"Gamma"</span>,<span class="st">"InvGaussian"</span>,<span class="st">"Poisson"</span>,<span class="st">"Gaussian"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid distribution name"</span>)}</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>QALY_link <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"logit"</span>,<span class="st">"probit"</span>,<span class="st">"cauchit"</span>, <span class="st">"cloglog"</span>, <span class="st">"identity"</span>, <span class="st">"log"</span>, <span class="st">"sqrt"</span>, <span class="st">"1/mu^2"</span>, <span class="st">"inverse"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid link function name"</span>)}</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>TC_link <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"logit"</span>,<span class="st">"probit"</span>,<span class="st">"cauchit"</span>, <span class="st">"cloglog"</span>, <span class="st">"identity"</span>, <span class="st">"log"</span>, <span class="st">"sqrt"</span>, <span class="st">"1/mu^2"</span>, <span class="st">"inverse"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid link function name"</span>)}</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(trt_pos) <span class="sc">|</span> <span class="fu">length</span>(trt_pos)<span class="sc">!=</span><span class="dv">1</span> <span class="sc">|</span> trt_pos<span class="sc">&lt;=</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide valid trt indicator position in regressions"</span>)}</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>] <span class="co">#original sample size</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">#n covariates </span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>  nX_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(QALYreg, data))[<span class="dv">2</span>]</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>  nX_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(TCreg, data))[<span class="dv">2</span>]</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator and outcomes from provided formula</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(trt_name_e <span class="sc">!=</span> trt_name_c){<span class="fu">stop</span>(<span class="st">"please provide same trt variable name and position in QALY and TC formuale"</span>)}</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>  QALY_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[<span class="dv">1</span>]</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>  TC_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[<span class="dv">1</span>]</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check if trt indicator is factor and store its levels</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.factor</span>(data[,trt_name_e])){</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">levels</span>(data[,trt_name_e])} <span class="cf">else</span> {</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">unique</span>(data[,trt_name_e])}</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(trt_lev)<span class="sc">!=</span><span class="dv">2</span>){<span class="fu">stop</span>(<span class="st">"The function only allows comparison between two trt groups"</span>)}  </span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare empty objects to contain bootstrapped estimates</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>  data_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>  coeff_e <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>  coeff_c <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>  em_e_ctr <span class="ot">&lt;-</span> em_e_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>  em_c_ctr <span class="ot">&lt;-</span> em_c_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>  dataset.dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(data) <span class="co">#convert data into data.table object</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">#sample with replacement</span></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>    data_ec_b_list[[i]] <span class="ot">&lt;-</span> dataset.dt[<span class="fu">sample</span>(.N, n, <span class="at">replace =</span> T)]</span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (QALY)</span></span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">betareg</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">link =</span> QALY_link)}</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">link =</span> QALY_link)}</span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> QALY_link))} </span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (TC)</span></span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">betareg</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">link =</span> TC_link)}</span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">link =</span> TC_link)}</span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb40-72"><a href="#cb40-72" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb40-73"><a href="#cb40-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb40-74"><a href="#cb40-74" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb40-75"><a href="#cb40-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb40-76"><a href="#cb40-76" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> TC_link))} </span>
<span id="cb40-77"><a href="#cb40-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb40-78"><a href="#cb40-78" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_ec_b_list[[i]], <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb40-79"><a href="#cb40-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb40-80"><a href="#cb40-80" aria-hidden="true" tabindex="-1"></a>    glm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb40-81"><a href="#cb40-81" aria-hidden="true" tabindex="-1"></a>    glm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb40-82"><a href="#cb40-82" aria-hidden="true" tabindex="-1"></a>    em_e_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb40-83"><a href="#cb40-83" aria-hidden="true" tabindex="-1"></a>    em_e_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb40-84"><a href="#cb40-84" aria-hidden="true" tabindex="-1"></a>    em_c_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb40-85"><a href="#cb40-85" aria-hidden="true" tabindex="-1"></a>    em_c_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb40-86"><a href="#cb40-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb40-87"><a href="#cb40-87" aria-hidden="true" tabindex="-1"></a>    coeff_e[i] <span class="ot">&lt;-</span> em_e_int[i] <span class="sc">-</span> em_e_ctr[i]</span>
<span id="cb40-88"><a href="#cb40-88" aria-hidden="true" tabindex="-1"></a>    coeff_c[i] <span class="ot">&lt;-</span> em_c_int[i] <span class="sc">-</span> em_c_ctr[i]</span>
<span id="cb40-89"><a href="#cb40-89" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb40-90"><a href="#cb40-90" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create list objects to store all results </span></span>
<span id="cb40-91"><a href="#cb40-91" aria-hidden="true" tabindex="-1"></a>  res_e_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>coeff_e,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>em_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>em_e_int)</span>
<span id="cb40-92"><a href="#cb40-92" aria-hidden="true" tabindex="-1"></a>  res_c_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_c"</span><span class="ot">=</span>coeff_c,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>em_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>em_c_int)</span>
<span id="cb40-93"><a href="#cb40-93" aria-hidden="true" tabindex="-1"></a>  input_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"data"</span><span class="ot">=</span>data, <span class="st">"trt_pos"</span><span class="ot">=</span>trt_pos, <span class="st">"QALYreg"</span><span class="ot">=</span>QALYreg,</span>
<span id="cb40-94"><a href="#cb40-94" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TCreg"</span><span class="ot">=</span>TCreg,<span class="st">"QALY_link"</span><span class="ot">=</span>QALY_link,<span class="st">"QALY_dist"</span><span class="ot">=</span>QALY_dist,</span>
<span id="cb40-95"><a href="#cb40-95" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TC_dist"</span><span class="ot">=</span>TC_dist,<span class="st">"TC_link"</span><span class="ot">=</span>TC_link)</span>
<span id="cb40-96"><a href="#cb40-96" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute overall list and return it as output from the function</span></span>
<span id="cb40-97"><a href="#cb40-97" aria-hidden="true" tabindex="-1"></a>  res_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"QALY_boot"</span><span class="ot">=</span>res_e_b_list,<span class="st">"TC_boot"</span><span class="ot">=</span>res_c_b_list,<span class="st">"inputs"</span><span class="ot">=</span>input_list)</span>
<span id="cb40-98"><a href="#cb40-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(res_ec_b_list) <span class="ot">&lt;-</span> <span class="st">"bootCE_glm"</span></span>
<span id="cb40-99"><a href="#cb40-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_ec_b_list)</span>
<span id="cb40-100"><a href="#cb40-100" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can now apply the newly created bootstrap function called <code>boot_ec_glm</code> to our generated dataset to obtain <span class="math inline">\(B=200\)</span> bootstrapped estimates for the parameters of interest, which are here stored in a list object called <code>boot_res_glm</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to dataset</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>boot_res_glm <span class="ot">&lt;-</span> <span class="fu">boot_ec_glm</span>(<span class="at">data =</span> dataset, <span class="at">QALYreg =</span> QALY <span class="sc">~</span> trt <span class="sc">+</span> u,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">TCreg =</span> TC <span class="sc">~</span> trt <span class="sc">+</span> c, <span class="at">QALY_dist =</span> <span class="st">"Beta"</span>, <span class="at">TC_dist =</span> <span class="st">"Gamma"</span>,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>                    <span class="at">QALY_link =</span> <span class="st">"logit"</span>, <span class="at">TC_link =</span> <span class="st">"inverse"</span>, <span class="at">B=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Note that, depending on the selected distribution and link function, GLMs may encounter problems in estimation and sometimes may not be even fit to some specific data. For example, if QALYs contain some negative values (which is theoretically possible), then Beta distributions will never be able to fit since these are defined on the interval <span class="math inline">\((0,1)\)</span>. These problems are also more likely to occur when implementing GLMs within a bootstrap procedure, since the resampling done at each iteration may lead to some data structures that do not fit well the assumed distributions.</p>
<p>Similarly to what done in <a href="#sec-corr" class="quarto-xref">Section&nbsp;2</a>, the following (folded) code part shows how to modify the function for generating bootstrap confidence intervals to allow the use of GLM results (produced through the function <code>boot_ec_glm</code>) instead of those from OLS and SUR models.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">#jackknife sampling function (used to compute BCa interval inside main boot_ci function)</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>jk_ec_glm <span class="ot">&lt;-</span> <span class="cf">function</span>(data,QALYreg,TCreg,trt_pos,QALY_dist,TC_dist,</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                   QALY_link,TC_link){</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>]</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator from provided formula</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare objects to store results</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>  jk_delta_c_i <span class="ot">&lt;-</span> jk_delta_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>  jk_mu0_c_i <span class="ot">&lt;-</span> jk_mu0_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  jk_mu1_c_i <span class="ot">&lt;-</span> jk_mu1_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife re-sampling</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    data_i <span class="ot">&lt;-</span> data[<span class="sc">-</span>i,]</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain estimates of interest</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">betareg</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">link =</span> QALY_link)}</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">link =</span> QALY_link)}</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> QALY_link))} </span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (TC)</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">betareg</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">link =</span> TC_link)}</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">link =</span> TC_link)}</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> TC_link))} </span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data_i, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> TC_link))}    </span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>    glm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_i)</span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>    glm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_i)</span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    jk_mu0_e_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>    jk_mu1_e_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>    jk_mu0_c_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>    jk_mu1_c_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>    jk_delta_e_i[i] <span class="ot">&lt;-</span> jk_mu1_e_i[i] <span class="sc">-</span> jk_mu0_e_i[i]</span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>    jk_delta_c_i[i] <span class="ot">&lt;-</span> jk_mu1_c_i[i] <span class="sc">-</span> jk_mu0_c_i[i]   </span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>  jk_est_i <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(jk_delta_e_i,jk_delta_c_i,jk_mu0_e_i,jk_mu1_e_i,jk_mu0_c_i,jk_mu1_c_i)</span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(jk_est_i) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"jk_Delta_e"</span>,<span class="st">"jk_Delta_c"</span>,<span class="st">"jk_mu_e_ctr"</span>,<span class="st">"jk_mu_e_int"</span>,<span class="st">"jk_mu_c_ctr"</span>,<span class="st">"jk_mu_c_int"</span>)</span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(jk_est_i)</span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>boot_ci_glm <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">method =</span> <span class="st">"perc"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>){</span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">inherits</span>(x, <span class="fu">c</span>(<span class="st">"bootCE_glm"</span>,<span class="st">"tsbootCE_glm"</span>))) {<span class="fu">stop</span>(<span class="st">"Only objects of class 'bootCE_glm' or 'tsbootCE_glm' can be used"</span>)}</span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>method <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"perc"</span>,<span class="st">"BCa"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method name"</span>)}</span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(confidence)){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(confidence<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> confidence<span class="sc">&gt;=</span><span class="dv">1</span>){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract information from inputs</span></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a>  B <span class="ot">&lt;-</span> <span class="fu">length</span>(x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e)</span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a>  mu_e_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_ctr</span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>  mu_e_int <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_int</span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>  Delta_e <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e</span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>  mu_c_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_ctr</span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>  mu_c_int <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_int</span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>  Delta_c <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>Delta_c</span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> confidence</span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute CI bounds according to method chosen</span></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"perc"</span>){</span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"BCa"</span>){</span>
<span id="cb42-86"><a href="#cb42-86" aria-hidden="true" tabindex="-1"></a>    QALY_dist <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALY_dist</span>
<span id="cb42-87"><a href="#cb42-87" aria-hidden="true" tabindex="-1"></a>    TC_dist <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TC_dist</span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a>    QALY_link <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALY_link</span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a>    TC_link <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TC_link</span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>data</span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a>    trt_pos <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>trt_pos</span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a>    QALYreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALYreg</span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a>    TCreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TCreg</span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain avg BCa estimates based on original sample</span></span>
<span id="cb42-95"><a href="#cb42-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb42-96"><a href="#cb42-96" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">betareg</span>(QALYreg, <span class="at">data =</span> data, <span class="at">link =</span> QALY_link)}</span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(QALYreg, <span class="at">data =</span> data, <span class="at">link =</span> QALY_link)}</span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-105"><a href="#cb42-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb42-106"><a href="#cb42-106" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> QALY_link))} </span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (TC)</span></span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">betareg</span>(TCreg, <span class="at">data =</span> data, <span class="at">link =</span> TC_link)}</span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(TCreg, <span class="at">data =</span> data, <span class="at">link =</span> TC_link)}</span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> TC_link))} </span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb42-123"><a href="#cb42-123" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> data, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> TC_link))}    </span>
<span id="cb42-124"><a href="#cb42-124" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract name of trt indicator from provided formula</span></span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a>    trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a>    trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a>    glm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data)</span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a>    glm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data)</span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_int <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_int <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb42-135"><a href="#cb42-135" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_e <span class="ot">&lt;-</span> avg_BCa_mu_e_int <span class="sc">-</span> avg_BCa_mu_e_ctr</span>
<span id="cb42-136"><a href="#cb42-136" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_c <span class="ot">&lt;-</span> avg_BCa_mu_c_int <span class="sc">-</span> avg_BCa_mu_c_ctr    </span>
<span id="cb42-137"><a href="#cb42-137" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute proportion of samples below avg estimates</span></span>
<span id="cb42-138"><a href="#cb42-138" aria-hidden="true" tabindex="-1"></a>    plower_Delta_e <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_e[Delta_e<span class="sc">&lt;</span>avg_BCa_Delta_e])<span class="sc">/</span>B</span>
<span id="cb42-139"><a href="#cb42-139" aria-hidden="true" tabindex="-1"></a>    plower_Delta_c <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_c[Delta_c<span class="sc">&lt;</span>avg_BCa_Delta_c])<span class="sc">/</span>B</span>
<span id="cb42-140"><a href="#cb42-140" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_ctr[mu_e_ctr<span class="sc">&lt;</span>avg_BCa_mu_e_ctr])<span class="sc">/</span>B</span>
<span id="cb42-141"><a href="#cb42-141" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_int[mu_e_int<span class="sc">&lt;</span>avg_BCa_mu_e_int])<span class="sc">/</span>B</span>
<span id="cb42-142"><a href="#cb42-142" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_ctr[mu_c_ctr<span class="sc">&lt;</span>avg_BCa_mu_c_ctr])<span class="sc">/</span>B</span>
<span id="cb42-143"><a href="#cb42-143" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_int[mu_c_int<span class="sc">&lt;</span>avg_BCa_mu_c_int])<span class="sc">/</span>B</span>
<span id="cb42-144"><a href="#cb42-144" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute bias-correction term</span></span>
<span id="cb42-145"><a href="#cb42-145" aria-hidden="true" tabindex="-1"></a>    z0_Delta_e <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_e, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-146"><a href="#cb42-146" aria-hidden="true" tabindex="-1"></a>    z0_Delta_c <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_c, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-147"><a href="#cb42-147" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-148"><a href="#cb42-148" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-149"><a href="#cb42-149" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-150"><a href="#cb42-150" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-151"><a href="#cb42-151" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife sampling functions to get jeckknife estimates</span></span>
<span id="cb42-152"><a href="#cb42-152" aria-hidden="true" tabindex="-1"></a>    jk_res_glm <span class="ot">&lt;-</span> <span class="fu">jk_ec_glm</span>(<span class="at">data =</span> data, <span class="at">QALYreg=</span>QALYreg,<span class="at">TCreg=</span>TCreg,<span class="at">trt_pos=</span>trt_pos,</span>
<span id="cb42-153"><a href="#cb42-153" aria-hidden="true" tabindex="-1"></a>                        <span class="at">QALY_dist=</span>QALY_dist,<span class="at">TC_dist=</span>TC_dist,</span>
<span id="cb42-154"><a href="#cb42-154" aria-hidden="true" tabindex="-1"></a>                        <span class="at">QALY_link=</span>QALY_link,<span class="at">TC_link=</span>TC_link)</span>
<span id="cb42-155"><a href="#cb42-155" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute avg of jk estimates</span></span>
<span id="cb42-156"><a href="#cb42-156" aria-hidden="true" tabindex="-1"></a>    jk_res_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(jk_res_glm, <span class="dv">2</span>, mean, <span class="at">na.rm =</span> T) </span>
<span id="cb42-157"><a href="#cb42-157" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute skewness correction term</span></span>
<span id="cb42-158"><a href="#cb42-158" aria-hidden="true" tabindex="-1"></a>    a_Delta_e <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb42-159"><a href="#cb42-159" aria-hidden="true" tabindex="-1"></a>    a_Delta_c <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb42-160"><a href="#cb42-160" aria-hidden="true" tabindex="-1"></a>    a_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb42-161"><a href="#cb42-161" aria-hidden="true" tabindex="-1"></a>    a_mu_e_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb42-162"><a href="#cb42-162" aria-hidden="true" tabindex="-1"></a>    a_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb42-163"><a href="#cb42-163" aria-hidden="true" tabindex="-1"></a>    a_mu_c_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res_glm[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))    </span>
<span id="cb42-164"><a href="#cb42-164" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute adjusted probs for getting desired confidence level</span></span>
<span id="cb42-165"><a href="#cb42-165" aria-hidden="true" tabindex="-1"></a>    z_alpha1 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-166"><a href="#cb42-166" aria-hidden="true" tabindex="-1"></a>    z_alpha2 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-167"><a href="#cb42-167" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-168"><a href="#cb42-168" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-169"><a href="#cb42-169" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-170"><a href="#cb42-170" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-171"><a href="#cb42-171" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-172"><a href="#cb42-172" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-173"><a href="#cb42-173" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-174"><a href="#cb42-174" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-175"><a href="#cb42-175" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-176"><a href="#cb42-176" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-177"><a href="#cb42-177" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb42-178"><a href="#cb42-178" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb42-179"><a href="#cb42-179" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain quantiles on original scale</span></span>
<span id="cb42-180"><a href="#cb42-180" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_ctr,ci_u_mu_e_ctr))</span>
<span id="cb42-181"><a href="#cb42-181" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_int,ci_u_mu_e_int))</span>
<span id="cb42-182"><a href="#cb42-182" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_e,ci_u_Delta_e))</span>
<span id="cb42-183"><a href="#cb42-183" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_ctr,ci_u_mu_c_ctr))</span>
<span id="cb42-184"><a href="#cb42-184" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_int,ci_u_mu_c_int))</span>
<span id="cb42-185"><a href="#cb42-185" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_c,ci_u_Delta_c))</span>
<span id="cb42-186"><a href="#cb42-186" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-187"><a href="#cb42-187" aria-hidden="true" tabindex="-1"></a>  <span class="co">#organise and return results</span></span>
<span id="cb42-188"><a href="#cb42-188" aria-hidden="true" tabindex="-1"></a>  res_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>ci_Delta_e,<span class="st">"Delta_c"</span><span class="ot">=</span>ci_Delta_c,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>ci_mu_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>ci_mu_e_int,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>ci_mu_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>ci_mu_c_int)</span>
<span id="cb42-189"><a href="#cb42-189" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_list)</span>
<span id="cb42-190"><a href="#cb42-190" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-191"><a href="#cb42-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-192"><a href="#cb42-192" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to bootstrap results generated using the function boot_ec_glm to compute bootstrapped confidence intervals for all stored quantities using either the percentile or BCa approach (selected through the argument `method`).</span></span>
<span id="cb42-193"><a href="#cb42-193" aria-hidden="true" tabindex="-1"></a>boot_ci_glm_bca <span class="ot">&lt;-</span> <span class="fu">boot_ci_glm</span>(<span class="at">x =</span> boot_res_glm, <span class="at">method =</span> <span class="st">"BCa"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="summary-2" class="level2">
<h2 class="anchored" data-anchor-id="summary-2">Summary</h2>
<p>GLMs have been recommended as a valid approach to handle skewed data in CEA, although they are currently characterised by some drawbacks:</p>
<ul>
<li><p>Performance of the model may change substantially according to the specific parametric distributional assumptions made, with different distributions possibly leading to quite different results <span class="citation" data-cites="thompson2005sensitive">(<a href="#ref-thompson2005sensitive" role="doc-biblioref">Thompson and Nixon 2005</a>)</span>. In theory, choice of an adequate distributional assumption allows to obtain more reliable estimates for the quantities of interest compared to methods that ignore skewness but assessment of a “good enough” fit of the selected distribution to the available data is difficult to establish.</p></li>
<li><p>Choice of the link function may also have considerable impact on the fit of the model to the data- In general, link functions specified on the original scale are preferred to ease interpretation (eg identity link) but these often lead to instability of the estimates due to the non-symmetric nature of CE data, especially when multiple covariates are included in the models.</p></li>
<li><p>Within a frequentist framework, implementation of <strong>joint</strong> GLMs is often difficult and impractical. This forces analysts to rely on fitting separate models to QALY and TC variables, therefore ignoring their possible correlation. This can be indirectly taken into account by embedding the models within a paired bootstrapping procedure, although its performance with respect to joint modelling has not been fully assessed.</p></li>
</ul>
<p>More recently, methodological developments have been made in the context of Bayesian analysis of CE data, which allows a more flexible modelling framework compared to the standard frequentist approach. This lead to the development of so-called <strong>hurdle</strong> or two-part regression models in combination with non-normal distributional assumptions for CE outcomes to handle extremely skewed data even in small samples <span class="citation" data-cites="baio2014bayesian gabrio2019full">(<a href="#ref-baio2014bayesian" role="doc-biblioref">Baio 2014</a>; <a href="#ref-gabrio2019full" role="doc-biblioref">Gabrio, Mason, and Baio 2019</a>)</span>. However, implementation of these methods within a frequentist framework can be very challenging, especially when these need to be combined with bootstrapping to generate empricial distributions for the estimates of interest required to perform the CE assessment.</p>
</section>
</section>
<section id="sec-cluster" class="level1">
<h1>Clustering of data</h1>
<p>Some trials, for ethical or practical reasons, may randomise clusters rather than individual patients to each treatment arm. This is typically the case for <em>cluster</em> RCT, where the unit of randomisation becomes the treatment arm itself, ie individuals in a given cluster all receive the same treatment. When present, this design feature of the trial poses a threat to the validity of results derived from methods that ignore the clustering structure in the data, such as OLS, SUR or GLM approaches.</p>
<p>It has been shown that methods that ignore clustering (ie assume independence across all observations) will <strong>underestimate</strong> statistical uncertainty around parameter estimates, and may even result in biases and misleading conclusions <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>. The problem is further exacerbated in the context of CEA where clustering needs to be addressed jointly with the other <em>typical complexities</em> affecting the data, such as the need to deal with baseline imbalances, correlation between the outcomes, and the level of skewness in both CE outcomes <span class="citation" data-cites="gomes2012methods">(<a href="#ref-gomes2012methods" role="doc-biblioref">Gomes, Grieve, et al. 2012</a>)</span>.</p>
<p>Different approaches have been proposed in the literature to deal with clustering in CEA data and, among those assessed and compared, two main approaches have been suggested: <strong>Multilevel Models</strong> (MLM) and (non-parametric) <strong>Two-Stage Bootstrapping</strong> (TSB). The two approaches tackle the clustering problem from different perspectives but have been shown to perform good in general situations, although MLMs seem to have a generally better performance across a range of data structure scenarios <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>.</p>
<section id="data-generation-3" class="level2">
<h2 class="anchored" data-anchor-id="data-generation-3">Data generation</h2>
<p>Let’s start by generating some artificial data that will be used to show how the desired methods can be implemented in <code>R</code>. The code used to generate these data is provided in the following (folded) code part and, if not of interest, you may skip it and jump to the actual implementation code in the next section.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set parameter values for generating data</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">100</span> <span class="co">#sample size by cluster</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>J <span class="ot">&lt;-</span> <span class="dv">26</span> <span class="co">#n of clusters</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>beta0_c <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>beta1_c <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>tau_c <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">*</span><span class="dv">2</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>trt_j <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>,J<span class="sc">/</span><span class="dv">2</span>),<span class="fu">rep</span>(<span class="dv">1</span>,J<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate cluster-level means</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>phi_cj <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(J,beta0_c<span class="sc">+</span>beta1_c<span class="sc">*</span>trt_j, tau_c) <span class="co">#cost cluster means</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>c_ij <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> J)</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>sigma_c <span class="ot">&lt;-</span> <span class="dv">15</span><span class="sc">*</span><span class="dv">2</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate individual-level values</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>J){</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>  c_ij[,j] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n,phi_cj[j],sigma_c) <span class="co">#cost data</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>beta0_e <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>beta1_e <span class="ot">&lt;-</span> <span class="fl">0.1</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>tau_e <span class="ot">&lt;-</span> <span class="fl">0.1</span><span class="sc">*</span><span class="dv">2</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>gamma <span class="ot">&lt;-</span> tau_e<span class="sc">/</span>tau_c  <span class="co">#parameter capturing correlation between cluster QALY and cost means</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate cluster-level means</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>phi_ej <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(J,beta0_e<span class="sc">+</span>beta1_e<span class="sc">+</span>gamma<span class="sc">*</span>(phi_cj <span class="sc">-</span> (beta0_c<span class="sc">+</span>beta1_c<span class="sc">*</span>trt_j)), tau_e) <span class="co">#QALY cluster means</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>e_ij <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> J)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>sigma_e <span class="ot">&lt;-</span> <span class="fl">0.15</span><span class="sc">*</span><span class="dv">2</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>rho_ec <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>theta <span class="ot">&lt;-</span> rho_ec<span class="sc">*</span>(sigma_e<span class="sc">/</span>sigma_c) <span class="co">#parameter capturing correlation between QALY and cost</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate individual-level values</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>J){</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>  e_ij[,j] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n,phi_ej[j]<span class="sc">+</span>theta<span class="sc">*</span>(c_ij[,j]<span class="sc">-</span>phi_cj[j]),sigma_e)<span class="sc">+</span><span class="fu">rnorm</span>(n,<span class="dv">0</span>,<span class="fl">0.15</span>) <span class="co">#QALY data</span></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a><span class="co">#compute ICC by outcome (cluster variance/total variance)</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>icc_c <span class="ot">&lt;-</span> tau_c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(tau_c<span class="sc">^</span><span class="dv">2</span><span class="sc">+</span>sigma_c<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>icc_e <span class="ot">&lt;-</span> tau_e<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(tau_e<span class="sc">^</span><span class="dv">2</span><span class="sc">+</span>sigma_e<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a><span class="co">#generate dataset</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>cluster <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>J, <span class="at">each=</span>n)</span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>TC <span class="ot">&lt;-</span> <span class="fu">c</span>(c_ij)</span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>QALY <span class="ot">&lt;-</span> <span class="fu">c</span>(e_ij)</span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>trt <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(cluster<span class="sc">&lt;=</span><span class="dv">13</span>,<span class="st">"old"</span>,<span class="st">"new"</span>)</span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>id <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>n<span class="sc">*</span>J) <span class="co">#individual id number</span></span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>data.clus.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(id, QALY,TC,trt,cluster)</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>data.clus.df<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">factor</span>(data.clus.df<span class="sc">$</span>trt, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"old"</span>,<span class="st">"new"</span>))</span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a><span class="co">#randomly shuffle rows of the dataset</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>data.clus.df <span class="ot">&lt;-</span> data.clus.df[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(data.clus.df)), ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can inspect the first few rows of the newly-generated data by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(data.clus.df, <span class="at">n=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       id       QALY       TC trt cluster
2228  728 1.23285753 108.9805 new      23
1351 1326 0.90037472 171.1320 new      14
374  1924 0.47126061 154.6768 old       4
1382 2132 0.67579513 135.2535 new      14
247  1222 0.10535644 109.3631 old       3
2324  624 0.04669856 104.4512 new      24
2128  728 1.22815612 104.2594 new      22
1656 1456 1.02208538 191.0768 new      17</code></pre>
</div>
</div>
<p>and, as an example, we look at summary statistics for TC between two different clusters by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(data.clus.df<span class="sc">$</span>TC[data.clus.df<span class="sc">$</span>cluster<span class="sc">==</span><span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  24.10   54.12   74.48   76.33   95.71  139.58 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(data.clus.df<span class="sc">$</span>TC[data.clus.df<span class="sc">$</span>cluster<span class="sc">==</span><span class="dv">15</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  63.24  105.11  128.03  125.58  143.45  190.73 </code></pre>
</div>
</div>
<p>We can see that summary statistics can be quite different between clusters, therefore suggesting the violation of the independence assumption typical of standard statistical methods, such as OLS. We can also compute the <em>Intraclass Correlation Coefficients</em> (ICC) for the QALY (0.308) and TC (0.308) variables, which give an indication of the proportion of total variability in each outcome that is due to variability between clusters.</p>
</section>
<section id="method-application-3" class="level2">
<h2 class="anchored" data-anchor-id="method-application-3">Method application</h2>
<p>The general idea underlying MLM is to extend the standard OLS/SUR regression framework by adding some cluster-specific <strong>random terms</strong> to capture differences between cluster outcome means from the overall means computed across clusters. The regression model for the two CE outcomes can be expressed as:</p>
<p><span id="eq-6"><span class="math display">\[
\begin{aligned}
\text{QALY}_{ij} &amp;= \beta_0 + \beta_1\times \text{arm}_j + u_{je} + \varepsilon_{ije} \\
\text{TC}_{ij} &amp;= \alpha_0 + \alpha_1\times \text{arm}_j + u_{jc} + \varepsilon_{ijc} \\
\end{aligned}
\tag{6}\]</span></span></p>
<p>where <span class="math inline">\(u_{je}\)</span> and <span class="math inline">\(u_{jc}\)</span> denote the random terms that are specific to cluster <span class="math inline">\(j\)</span>. Similarly to what discussed for SUR models (<a href="#eq-4" class="quarto-xref">Equation&nbsp;4</a>), these error terms can be assumed to follow a joint normal distribution</p>
<p><span class="math display">\[
\begin{aligned}
\begin{pmatrix}
u_{je}\\
u_{jc}\\
\end{pmatrix} &amp;\sim  \text{Normal}
\begin{bmatrix}
\begin{pmatrix}
0\\
0
\end{pmatrix}\!\!,&amp;
\begin{pmatrix}
\tau^2_e &amp; \psi\tau_e\tau_c\\
\psi\tau_c\tau_e &amp; \tau^2_c
\end{pmatrix}
\end{bmatrix}
\end{aligned}
\]</span></p>
<p>where the parameter <span class="math inline">\(\psi\)</span> allows to link the two random terms to capture possible correlation between cluster QALY and TC means, although it is often assumed <span class="math inline">\(0\)</span> to ease implementation of the models.</p>
<p>In <code>R</code>, the following code may be used to fit separate MLM equations as shown in <a href="#eq-6" class="quarto-xref">Equation&nbsp;6</a> to the generated data and summarise the output:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4) <span class="co">#load package to fit MLM</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nlme) <span class="co">#load package to fit MLM</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">#fit MLM to QALY regression</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>mlm_e <span class="ot">&lt;-</span> <span class="fu">lme</span>(QALY <span class="sc">~</span> trt, <span class="at">random =</span> <span class="sc">~</span><span class="dv">1</span><span class="sc">|</span>cluster, <span class="at">data =</span> data.clus.df)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mlm_e) <span class="co">#summarise output</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Linear mixed-effects model fit by REML
  Data: data.clus.df 
       AIC      BIC    logLik
  2244.443 2267.893 -1118.222

Random effects:
 Formula: ~1 | cluster
        (Intercept)  Residual
StdDev:   0.2747145 0.3642086

Fixed effects:  QALY ~ trt 
                Value  Std.Error   DF  t-value p-value
(Intercept) 0.5955004 0.07685878 2574 7.747981  0.0000
trtnew      0.0256487 0.10869473   24 0.235970  0.8155
 Correlation: 
       (Intr)
trtnew -0.707

Standardized Within-Group Residuals:
        Min          Q1         Med          Q3         Max 
-3.45114121 -0.70888295 -0.01460118  0.66186518  4.39502802 

Number of Observations: 2600
Number of Groups: 26 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit MLM to QALY regression</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>mlm_c <span class="ot">&lt;-</span> <span class="fu">lme</span>(TC <span class="sc">~</span> trt, <span class="at">random =</span> <span class="sc">~</span><span class="dv">1</span><span class="sc">|</span>cluster, <span class="at">data =</span> data.clus.df)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mlm_c) <span class="co">#summarise output</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Linear mixed-effects model fit by REML
  Data: data.clus.df 
       AIC      BIC    logLik
  25064.68 25088.13 -12528.34

Random effects:
 Formula: ~1 | cluster
        (Intercept) Residual
StdDev:    19.13406 29.46526

Fixed effects:  TC ~ trt 
               Value Std.Error   DF   t-value p-value
(Intercept) 99.40969  5.369388 2574 18.514155  0.0000
trtnew      20.25840  7.593462   24  2.667874  0.0135
 Correlation: 
       (Intr)
trtnew -0.707

Standardized Within-Group Residuals:
        Min          Q1         Med          Q3         Max 
-3.77623879 -0.68339399 -0.01845129  0.67128677  3.20459691 

Number of Observations: 2600
Number of Groups: 26 </code></pre>
</div>
</div>
<p>We can use the function <code>emmean</code> from the <code>R</code> package <code>emmeans</code> to easily compute the mean QALYs in each treatment group. For example, we can type the following</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans) <span class="co">#load library to obtain marginal means</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>mlm1em_e <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_e, <span class="sc">~</span> trt) <span class="co">#compute mean outcome by level of trt</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>mlm1em_e</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> trt emmean     SE df lower.CL upper.CL
 old  0.596 0.0769 25    0.437    0.754
 new  0.621 0.0769 24    0.463    0.780

Degrees-of-freedom method: containment 
Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>to directly obtain estimates of the mean QALYs, their standard errors and <span class="math inline">\(95\%\)</span> confidence intervals by treatment group. We can then use the function <code>contrast</code> to derive estimates of any linear combination of the quantities above. For example, we may obtain estimates for the mean QALY difference (New - Old) by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">#take difference as - Old + New = New - Old</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>QALY_new_vs_old <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"New vs Old"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co">#compute linear combination</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>mlm1em_delta_e <span class="ot">&lt;-</span> <span class="fu">contrast</span>(mlm1em_e, QALY_new_vs_old)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="co">#obtain results in terms of confidence intervals</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="fu">confint</span>(mlm1em_delta_e, <span class="at">level =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> contrast   estimate    SE df lower.CL upper.CL
 New vs Old   0.0256 0.109 24   -0.199     0.25

Degrees-of-freedom method: containment 
Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>Although I have not shown here an application of MLM for TC estimates, these can be easily obtained in a similar way to what shown for QALYs.</p>
<p>In the (folded) code part below, I additionally provide <code>R</code> functions to implement MLMs within a boostrap procedure to generate bootstrapped estimates of the parameters of interest and their associated confidence intervals.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table) <span class="co">#package to handle datasets more efficiently</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bootstrap) <span class="co">#package to use bootstrap procedure </span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rlang)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nlme)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>boot_ec_mlm <span class="ot">&lt;-</span> <span class="cf">function</span>(data, B, QALYreg, TCreg, QALYrandom, TCrandom, <span class="at">trt_pos =</span> <span class="dv">2</span>){</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.data.frame</span>(data)){<span class="fu">stop</span>(<span class="st">"data needs to be a data frame object"</span>)}</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(B)){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(B<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> <span class="sc">!</span>B<span class="sc">%%</span><span class="dv">1</span><span class="sc">==</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY model"</span>)}</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC model"</span>)}</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYrandom)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY random effects"</span>)}</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCrandom)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC random effects"</span>)}</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(trt_pos) <span class="sc">|</span> <span class="fu">length</span>(trt_pos)<span class="sc">!=</span><span class="dv">1</span> <span class="sc">|</span> trt_pos<span class="sc">&lt;=</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide valid trt indicator position in regressions"</span>)}</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>] <span class="co">#original sample size</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#n covariates </span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>  nX_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(QALYreg, data))[<span class="dv">2</span>]</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>  nX_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(TCreg, data))[<span class="dv">2</span>]</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator and outcomes from provided formula</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(trt_name_e <span class="sc">!=</span> trt_name_c){<span class="fu">stop</span>(<span class="st">"please provide same trt variable name and position in QALY and TC formuale"</span>)}</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>  QALY_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[<span class="dv">1</span>]</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>  TC_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[<span class="dv">1</span>]</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check if trt indicator is factor and store its levels</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.factor</span>(data[,trt_name_e])){</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">levels</span>(data[,trt_name_e])} <span class="cf">else</span> {</span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">unique</span>(data[,trt_name_e])}</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(trt_lev)<span class="sc">!=</span><span class="dv">2</span>){<span class="fu">stop</span>(<span class="st">"The function only allows comparison between two trt groups"</span>)}  </span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare empty objects to contain bootstrapped estimates</span></span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>  data_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>  coeff_e <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a>  coeff_c <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>  em_e_ctr <span class="ot">&lt;-</span> em_e_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>  em_c_ctr <span class="ot">&lt;-</span> em_c_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a>  dataset.dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(data) <span class="co">#convert data into data.table object</span></span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){</span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">#sample with replacement</span></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>    data_ec_b_list[[i]] <span class="ot">&lt;-</span> dataset.dt[<span class="fu">sample</span>(.N, n, <span class="at">replace =</span> T)]</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">#fit models for QALY and TC</span></span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>    mlm_e <span class="ot">&lt;-</span> <span class="fu">lme</span>(QALYreg, <span class="at">random =</span> QALYrandom, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>    mlm_c <span class="ot">&lt;-</span> <span class="fu">lme</span>(TCreg, <span class="at">random =</span> TCrandom, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a>    mlm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb58-49"><a href="#cb58-49" aria-hidden="true" tabindex="-1"></a>    mlm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_ec_b_list[[i]])</span>
<span id="cb58-50"><a href="#cb58-50" aria-hidden="true" tabindex="-1"></a>    em_e_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-51"><a href="#cb58-51" aria-hidden="true" tabindex="-1"></a>    em_e_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-52"><a href="#cb58-52" aria-hidden="true" tabindex="-1"></a>    em_c_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-53"><a href="#cb58-53" aria-hidden="true" tabindex="-1"></a>    em_c_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-54"><a href="#cb58-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb58-55"><a href="#cb58-55" aria-hidden="true" tabindex="-1"></a>    coeff_e[i] <span class="ot">&lt;-</span> em_e_int[i] <span class="sc">-</span> em_e_ctr[i]</span>
<span id="cb58-56"><a href="#cb58-56" aria-hidden="true" tabindex="-1"></a>    coeff_c[i] <span class="ot">&lt;-</span> em_c_int[i] <span class="sc">-</span> em_c_ctr[i]</span>
<span id="cb58-57"><a href="#cb58-57" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-58"><a href="#cb58-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create list objects to store all results </span></span>
<span id="cb58-59"><a href="#cb58-59" aria-hidden="true" tabindex="-1"></a>  res_e_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>coeff_e,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>em_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>em_e_int)</span>
<span id="cb58-60"><a href="#cb58-60" aria-hidden="true" tabindex="-1"></a>  res_c_b_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_c"</span><span class="ot">=</span>coeff_c,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>em_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>em_c_int)</span>
<span id="cb58-61"><a href="#cb58-61" aria-hidden="true" tabindex="-1"></a>  input_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"data"</span><span class="ot">=</span>data, <span class="st">"trt_pos"</span><span class="ot">=</span>trt_pos, <span class="st">"QALYreg"</span><span class="ot">=</span>QALYreg,</span>
<span id="cb58-62"><a href="#cb58-62" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TCreg"</span><span class="ot">=</span>TCreg,<span class="st">"QALYrandom"</span><span class="ot">=</span>QALYrandom,<span class="st">"TCrandom"</span><span class="ot">=</span>TCrandom)</span>
<span id="cb58-63"><a href="#cb58-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute overall list and return it as output from the function</span></span>
<span id="cb58-64"><a href="#cb58-64" aria-hidden="true" tabindex="-1"></a>  res_ec_b_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"QALY_boot"</span><span class="ot">=</span>res_e_b_list,<span class="st">"TC_boot"</span><span class="ot">=</span>res_c_b_list,<span class="st">"inputs"</span><span class="ot">=</span>input_list)</span>
<span id="cb58-65"><a href="#cb58-65" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(res_ec_b_list) <span class="ot">&lt;-</span> <span class="st">"bootCE_mlm"</span></span>
<span id="cb58-66"><a href="#cb58-66" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_ec_b_list)</span>
<span id="cb58-67"><a href="#cb58-67" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-68"><a href="#cb58-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-69"><a href="#cb58-69" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to obtain bootstrap estimates from MLM</span></span>
<span id="cb58-70"><a href="#cb58-70" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb58-71"><a href="#cb58-71" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb58-72"><a href="#cb58-72" aria-hidden="true" tabindex="-1"></a><span class="co">#the function fit separate MLM to QALY and TC data using normal random effects term specified for the variables indicated in the arguments QALYrandom and TCrandom, which must be specified as formulae following the notation indicated for random effects terms in the function lme from the package nlme</span></span>
<span id="cb58-73"><a href="#cb58-73" aria-hidden="true" tabindex="-1"></a>boot_res_mlm <span class="ot">&lt;-</span> <span class="fu">boot_ec_mlm</span>(<span class="at">data =</span> data.clus.df, <span class="at">QALYreg =</span> QALY <span class="sc">~</span> trt, </span>
<span id="cb58-74"><a href="#cb58-74" aria-hidden="true" tabindex="-1"></a>                            <span class="at">QALYrandom =</span> <span class="sc">~</span><span class="dv">1</span><span class="sc">|</span>cluster, <span class="at">TCreg =</span> TC <span class="sc">~</span> trt, </span>
<span id="cb58-75"><a href="#cb58-75" aria-hidden="true" tabindex="-1"></a>                            <span class="at">TCrandom =</span> <span class="sc">~</span><span class="dv">1</span><span class="sc">|</span>cluster, <span class="at">B=</span><span class="dv">200</span>)</span>
<span id="cb58-76"><a href="#cb58-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-77"><a href="#cb58-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-78"><a href="#cb58-78" aria-hidden="true" tabindex="-1"></a><span class="co">#jackknife sampling function (used to compute BCa interval inside main boot_ci function)</span></span>
<span id="cb58-79"><a href="#cb58-79" aria-hidden="true" tabindex="-1"></a>jk_ec_mlm <span class="ot">&lt;-</span> <span class="cf">function</span>(data,QALYreg,TCreg,trt_pos,QALYrandom,TCrandom){</span>
<span id="cb58-80"><a href="#cb58-80" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>]</span>
<span id="cb58-81"><a href="#cb58-81" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator from provided formula</span></span>
<span id="cb58-82"><a href="#cb58-82" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb58-83"><a href="#cb58-83" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb58-84"><a href="#cb58-84" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare objects to store results</span></span>
<span id="cb58-85"><a href="#cb58-85" aria-hidden="true" tabindex="-1"></a>  jk_delta_c_i <span class="ot">&lt;-</span> jk_delta_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-86"><a href="#cb58-86" aria-hidden="true" tabindex="-1"></a>  jk_mu0_c_i <span class="ot">&lt;-</span> jk_mu0_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-87"><a href="#cb58-87" aria-hidden="true" tabindex="-1"></a>  jk_mu1_c_i <span class="ot">&lt;-</span> jk_mu1_e_i <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb58-88"><a href="#cb58-88" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb58-89"><a href="#cb58-89" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife re-sampling</span></span>
<span id="cb58-90"><a href="#cb58-90" aria-hidden="true" tabindex="-1"></a>    data_i <span class="ot">&lt;-</span> data[<span class="sc">-</span>i,]</span>
<span id="cb58-91"><a href="#cb58-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">#fit models</span></span>
<span id="cb58-92"><a href="#cb58-92" aria-hidden="true" tabindex="-1"></a>    mlm_e <span class="ot">&lt;-</span> <span class="fu">lme</span>(QALYreg, <span class="at">random =</span> QALYrandom, <span class="at">data =</span> data_i)</span>
<span id="cb58-93"><a href="#cb58-93" aria-hidden="true" tabindex="-1"></a>    mlm_c <span class="ot">&lt;-</span> <span class="fu">lme</span>(TCreg, <span class="at">random =</span> TCrandom, <span class="at">data =</span> data_i)</span>
<span id="cb58-94"><a href="#cb58-94" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb58-95"><a href="#cb58-95" aria-hidden="true" tabindex="-1"></a>    mlm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_i)</span>
<span id="cb58-96"><a href="#cb58-96" aria-hidden="true" tabindex="-1"></a>    mlm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data_i)</span>
<span id="cb58-97"><a href="#cb58-97" aria-hidden="true" tabindex="-1"></a>    jk_mu0_e_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-98"><a href="#cb58-98" aria-hidden="true" tabindex="-1"></a>    jk_mu1_e_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-99"><a href="#cb58-99" aria-hidden="true" tabindex="-1"></a>    jk_mu0_c_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-100"><a href="#cb58-100" aria-hidden="true" tabindex="-1"></a>    jk_mu1_c_i[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-101"><a href="#cb58-101" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb58-102"><a href="#cb58-102" aria-hidden="true" tabindex="-1"></a>    jk_delta_e_i[i] <span class="ot">&lt;-</span> jk_mu1_e_i[i] <span class="sc">-</span> jk_mu0_e_i[i]</span>
<span id="cb58-103"><a href="#cb58-103" aria-hidden="true" tabindex="-1"></a>    jk_delta_c_i[i] <span class="ot">&lt;-</span> jk_mu1_c_i[i] <span class="sc">-</span> jk_mu0_c_i[i]    </span>
<span id="cb58-104"><a href="#cb58-104" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-105"><a href="#cb58-105" aria-hidden="true" tabindex="-1"></a>  jk_est_i <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(jk_delta_e_i,jk_delta_c_i,jk_mu0_e_i,jk_mu1_e_i,jk_mu0_c_i,jk_mu1_c_i)</span>
<span id="cb58-106"><a href="#cb58-106" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(jk_est_i) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"jk_Delta_e"</span>,<span class="st">"jk_Delta_c"</span>,<span class="st">"jk_mu_e_ctr"</span>,<span class="st">"jk_mu_e_int"</span>,<span class="st">"jk_mu_c_ctr"</span>,<span class="st">"jk_mu_c_int"</span>)</span>
<span id="cb58-107"><a href="#cb58-107" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(jk_est_i)</span>
<span id="cb58-108"><a href="#cb58-108" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-109"><a href="#cb58-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-110"><a href="#cb58-110" aria-hidden="true" tabindex="-1"></a>boot_ci_mlm <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">method =</span> <span class="st">"perc"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>){</span>
<span id="cb58-111"><a href="#cb58-111" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb58-112"><a href="#cb58-112" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">inherits</span>(x, <span class="fu">c</span>(<span class="st">"bootCE_mlm"</span>))) {<span class="fu">stop</span>(<span class="st">"Only objects of class 'bootCE_mlm' can be used"</span>)}</span>
<span id="cb58-113"><a href="#cb58-113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>method <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"perc"</span>,<span class="st">"BCa"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method name"</span>)}</span>
<span id="cb58-114"><a href="#cb58-114" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(confidence)){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb58-115"><a href="#cb58-115" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(confidence<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> confidence<span class="sc">&gt;=</span><span class="dv">1</span>){<span class="fu">stop</span>(<span class="st">"please provide valid confidence level"</span>)}</span>
<span id="cb58-116"><a href="#cb58-116" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract information from inputs</span></span>
<span id="cb58-117"><a href="#cb58-117" aria-hidden="true" tabindex="-1"></a>  B <span class="ot">&lt;-</span> <span class="fu">length</span>(x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e)</span>
<span id="cb58-118"><a href="#cb58-118" aria-hidden="true" tabindex="-1"></a>  mu_e_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_ctr</span>
<span id="cb58-119"><a href="#cb58-119" aria-hidden="true" tabindex="-1"></a>  mu_e_int <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>mu_e_int</span>
<span id="cb58-120"><a href="#cb58-120" aria-hidden="true" tabindex="-1"></a>  Delta_e <span class="ot">&lt;-</span> x<span class="sc">$</span>QALY_boot<span class="sc">$</span>Delta_e</span>
<span id="cb58-121"><a href="#cb58-121" aria-hidden="true" tabindex="-1"></a>  mu_c_ctr <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_ctr</span>
<span id="cb58-122"><a href="#cb58-122" aria-hidden="true" tabindex="-1"></a>  mu_c_int <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>mu_c_int</span>
<span id="cb58-123"><a href="#cb58-123" aria-hidden="true" tabindex="-1"></a>  Delta_c <span class="ot">&lt;-</span> x<span class="sc">$</span>TC_boot<span class="sc">$</span>Delta_c</span>
<span id="cb58-124"><a href="#cb58-124" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> confidence</span>
<span id="cb58-125"><a href="#cb58-125" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute CI bounds according to method chosen</span></span>
<span id="cb58-126"><a href="#cb58-126" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"perc"</span>){</span>
<span id="cb58-127"><a href="#cb58-127" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-128"><a href="#cb58-128" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-129"><a href="#cb58-129" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-130"><a href="#cb58-130" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-131"><a href="#cb58-131" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-132"><a href="#cb58-132" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>,(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>)))</span>
<span id="cb58-133"><a href="#cb58-133" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-134"><a href="#cb58-134" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(method <span class="sc">==</span> <span class="st">"BCa"</span>){</span>
<span id="cb58-135"><a href="#cb58-135" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>data</span>
<span id="cb58-136"><a href="#cb58-136" aria-hidden="true" tabindex="-1"></a>    trt_pos <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>trt_pos</span>
<span id="cb58-137"><a href="#cb58-137" aria-hidden="true" tabindex="-1"></a>    QALYreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALYreg</span>
<span id="cb58-138"><a href="#cb58-138" aria-hidden="true" tabindex="-1"></a>    TCreg <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TCreg</span>
<span id="cb58-139"><a href="#cb58-139" aria-hidden="true" tabindex="-1"></a>    QALYrandom <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>QALYrandom</span>
<span id="cb58-140"><a href="#cb58-140" aria-hidden="true" tabindex="-1"></a>    TCrandom <span class="ot">&lt;-</span> x<span class="sc">$</span>inputs<span class="sc">$</span>TCrandom</span>
<span id="cb58-141"><a href="#cb58-141" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain avg BCa estimates based on original sample</span></span>
<span id="cb58-142"><a href="#cb58-142" aria-hidden="true" tabindex="-1"></a>    mlm_e <span class="ot">&lt;-</span> <span class="fu">lme</span>(QALYreg, <span class="at">random =</span> QALYrandom, <span class="at">data =</span> data)</span>
<span id="cb58-143"><a href="#cb58-143" aria-hidden="true" tabindex="-1"></a>    mlm_c <span class="ot">&lt;-</span> <span class="fu">lme</span>(TCreg, <span class="at">random =</span> TCrandom, <span class="at">data =</span> data)</span>
<span id="cb58-144"><a href="#cb58-144" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract name of trt indicator from provided formula</span></span>
<span id="cb58-145"><a href="#cb58-145" aria-hidden="true" tabindex="-1"></a>    trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb58-146"><a href="#cb58-146" aria-hidden="true" tabindex="-1"></a>    trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb58-147"><a href="#cb58-147" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb58-148"><a href="#cb58-148" aria-hidden="true" tabindex="-1"></a>    mlm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data)</span>
<span id="cb58-149"><a href="#cb58-149" aria-hidden="true" tabindex="-1"></a>    mlm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(mlm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> data)</span>
<span id="cb58-150"><a href="#cb58-150" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-151"><a href="#cb58-151" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_e_int <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-152"><a href="#cb58-152" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb58-153"><a href="#cb58-153" aria-hidden="true" tabindex="-1"></a>    avg_BCa_mu_c_int <span class="ot">&lt;-</span> <span class="fu">summary</span>(mlm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb58-154"><a href="#cb58-154" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb58-155"><a href="#cb58-155" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_e <span class="ot">&lt;-</span> avg_BCa_mu_e_int <span class="sc">-</span> avg_BCa_mu_e_ctr</span>
<span id="cb58-156"><a href="#cb58-156" aria-hidden="true" tabindex="-1"></a>    avg_BCa_Delta_c <span class="ot">&lt;-</span> avg_BCa_mu_c_int <span class="sc">-</span> avg_BCa_mu_c_ctr     </span>
<span id="cb58-157"><a href="#cb58-157" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute proportion of samples below avg estimates</span></span>
<span id="cb58-158"><a href="#cb58-158" aria-hidden="true" tabindex="-1"></a>    plower_Delta_e <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_e[Delta_e<span class="sc">&lt;</span>avg_BCa_Delta_e])<span class="sc">/</span>B</span>
<span id="cb58-159"><a href="#cb58-159" aria-hidden="true" tabindex="-1"></a>    plower_Delta_c <span class="ot">&lt;-</span> <span class="fu">length</span>(Delta_c[Delta_c<span class="sc">&lt;</span>avg_BCa_Delta_c])<span class="sc">/</span>B</span>
<span id="cb58-160"><a href="#cb58-160" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_ctr[mu_e_ctr<span class="sc">&lt;</span>avg_BCa_mu_e_ctr])<span class="sc">/</span>B</span>
<span id="cb58-161"><a href="#cb58-161" aria-hidden="true" tabindex="-1"></a>    plower_mu_e_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_e_int[mu_e_int<span class="sc">&lt;</span>avg_BCa_mu_e_int])<span class="sc">/</span>B</span>
<span id="cb58-162"><a href="#cb58-162" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_ctr[mu_c_ctr<span class="sc">&lt;</span>avg_BCa_mu_c_ctr])<span class="sc">/</span>B</span>
<span id="cb58-163"><a href="#cb58-163" aria-hidden="true" tabindex="-1"></a>    plower_mu_c_int <span class="ot">&lt;-</span> <span class="fu">length</span>(mu_c_int[mu_c_int<span class="sc">&lt;</span>avg_BCa_mu_c_int])<span class="sc">/</span>B</span>
<span id="cb58-164"><a href="#cb58-164" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute bias-correction term</span></span>
<span id="cb58-165"><a href="#cb58-165" aria-hidden="true" tabindex="-1"></a>    z0_Delta_e <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_e, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-166"><a href="#cb58-166" aria-hidden="true" tabindex="-1"></a>    z0_Delta_c <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_Delta_c, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-167"><a href="#cb58-167" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-168"><a href="#cb58-168" aria-hidden="true" tabindex="-1"></a>    z0_mu_e_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_e_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-169"><a href="#cb58-169" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_ctr, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-170"><a href="#cb58-170" aria-hidden="true" tabindex="-1"></a>    z0_mu_c_int <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(plower_mu_c_int, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-171"><a href="#cb58-171" aria-hidden="true" tabindex="-1"></a>    <span class="co">#apply jackknife sampling functions to get jeckknife estimates</span></span>
<span id="cb58-172"><a href="#cb58-172" aria-hidden="true" tabindex="-1"></a>    jk_res_mlm <span class="ot">&lt;-</span> <span class="fu">jk_ec_mlm</span>(<span class="at">data =</span> data, <span class="at">QALYreg=</span>QALYreg,<span class="at">TCreg=</span>TCreg,<span class="at">trt_pos=</span>trt_pos,</span>
<span id="cb58-173"><a href="#cb58-173" aria-hidden="true" tabindex="-1"></a>                        <span class="at">QALYrandom=</span>QALYrandom,<span class="at">TCrandom=</span>TCrandom)</span>
<span id="cb58-174"><a href="#cb58-174" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute avg of jk estimates</span></span>
<span id="cb58-175"><a href="#cb58-175" aria-hidden="true" tabindex="-1"></a>    jk_res_avg <span class="ot">&lt;-</span> <span class="fu">apply</span>(jk_res_mlm, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T) </span>
<span id="cb58-176"><a href="#cb58-176" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute skewness correction term</span></span>
<span id="cb58-177"><a href="#cb58-177" aria-hidden="true" tabindex="-1"></a>    a_Delta_e <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_e"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_Delta_e"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb58-178"><a href="#cb58-178" aria-hidden="true" tabindex="-1"></a>    a_Delta_c <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_Delta_c"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_Delta_c"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb58-179"><a href="#cb58-179" aria-hidden="true" tabindex="-1"></a>    a_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_ctr"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_e_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb58-180"><a href="#cb58-180" aria-hidden="true" tabindex="-1"></a>    a_mu_e_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_e_int"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_e_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb58-181"><a href="#cb58-181" aria-hidden="true" tabindex="-1"></a>    a_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_ctr"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_c_ctr"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb58-182"><a href="#cb58-182" aria-hidden="true" tabindex="-1"></a>    a_mu_c_int <span class="ot">&lt;-</span> <span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">3</span>) <span class="sc">/</span> (<span class="dv">6</span><span class="sc">*</span>(<span class="fu">sum</span>((jk_res_avg[<span class="st">"jk_mu_c_int"</span>] <span class="sc">-</span> jk_res_mlm[,<span class="st">"jk_mu_c_int"</span>])<span class="sc">^</span><span class="dv">2</span>))<span class="sc">^</span>(<span class="dv">3</span><span class="sc">/</span><span class="dv">2</span>))    </span>
<span id="cb58-183"><a href="#cb58-183" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute adjusted probs for getting desired confidence level</span></span>
<span id="cb58-184"><a href="#cb58-184" aria-hidden="true" tabindex="-1"></a>    z_alpha1 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-185"><a href="#cb58-185" aria-hidden="true" tabindex="-1"></a>    z_alpha2 <span class="ot">&lt;-</span> <span class="fu">qnorm</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">lower.tail =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-186"><a href="#cb58-186" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-187"><a href="#cb58-187" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_e <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_e <span class="sc">+</span> ((z0_Delta_e<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_e<span class="sc">*</span>(z0_Delta_e<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-188"><a href="#cb58-188" aria-hidden="true" tabindex="-1"></a>    ci_l_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-189"><a href="#cb58-189" aria-hidden="true" tabindex="-1"></a>    ci_u_Delta_c <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_Delta_c <span class="sc">+</span> ((z0_Delta_c<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_Delta_c<span class="sc">*</span>(z0_Delta_c<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-190"><a href="#cb58-190" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-191"><a href="#cb58-191" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_ctr <span class="sc">+</span> ((z0_mu_e_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_ctr<span class="sc">*</span>(z0_mu_e_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-192"><a href="#cb58-192" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-193"><a href="#cb58-193" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_e_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_e_int <span class="sc">+</span> ((z0_mu_e_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_e_int<span class="sc">*</span>(z0_mu_e_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-194"><a href="#cb58-194" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-195"><a href="#cb58-195" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_ctr <span class="sc">+</span> ((z0_mu_c_ctr<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_ctr<span class="sc">*</span>(z0_mu_c_ctr<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-196"><a href="#cb58-196" aria-hidden="true" tabindex="-1"></a>    ci_l_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha1)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha1))))</span>
<span id="cb58-197"><a href="#cb58-197" aria-hidden="true" tabindex="-1"></a>    ci_u_mu_c_int <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(z0_mu_c_int <span class="sc">+</span> ((z0_mu_c_int<span class="sc">+</span>z_alpha2)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a_mu_c_int<span class="sc">*</span>(z0_mu_c_int<span class="sc">+</span>z_alpha2))))</span>
<span id="cb58-198"><a href="#cb58-198" aria-hidden="true" tabindex="-1"></a>    <span class="co">#obtain quantiles on original scale</span></span>
<span id="cb58-199"><a href="#cb58-199" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_ctr,ci_u_mu_e_ctr))</span>
<span id="cb58-200"><a href="#cb58-200" aria-hidden="true" tabindex="-1"></a>    ci_mu_e_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_e_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_e_int,ci_u_mu_e_int))</span>
<span id="cb58-201"><a href="#cb58-201" aria-hidden="true" tabindex="-1"></a>    ci_Delta_e <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_e, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_e,ci_u_Delta_e))</span>
<span id="cb58-202"><a href="#cb58-202" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_ctr <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_ctr, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_ctr,ci_u_mu_c_ctr))</span>
<span id="cb58-203"><a href="#cb58-203" aria-hidden="true" tabindex="-1"></a>    ci_mu_c_int <span class="ot">&lt;-</span> <span class="fu">quantile</span>(mu_c_int, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_mu_c_int,ci_u_mu_c_int))</span>
<span id="cb58-204"><a href="#cb58-204" aria-hidden="true" tabindex="-1"></a>    ci_Delta_c <span class="ot">&lt;-</span> <span class="fu">quantile</span>(Delta_c, <span class="at">probs =</span> <span class="fu">c</span>(ci_l_Delta_c,ci_u_Delta_c))</span>
<span id="cb58-205"><a href="#cb58-205" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb58-206"><a href="#cb58-206" aria-hidden="true" tabindex="-1"></a>  <span class="co">#organise and return results</span></span>
<span id="cb58-207"><a href="#cb58-207" aria-hidden="true" tabindex="-1"></a>  res_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>ci_Delta_e,<span class="st">"Delta_c"</span><span class="ot">=</span>ci_Delta_c,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>ci_mu_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>ci_mu_e_int,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>ci_mu_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>ci_mu_c_int)</span>
<span id="cb58-208"><a href="#cb58-208" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_list)</span>
<span id="cb58-209"><a href="#cb58-209" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb58-210"><a href="#cb58-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-211"><a href="#cb58-211" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to MLM results</span></span>
<span id="cb58-212"><a href="#cb58-212" aria-hidden="true" tabindex="-1"></a>boot_ci_mlm_bca <span class="ot">&lt;-</span> <span class="fu">boot_ci_mlm</span>(<span class="at">x =</span> boot_res_mlm, <span class="at">method =</span> <span class="st">"BCa"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>An alternative approach to handle clustering in CEA is to combine standard statistical methods that ignore clustering (eg OLS, SUR or GLM) with a modified version of non-parametric bootstrapping, which takes the name of <strong>Two-Stage Bootstrapping</strong> (TSB). The key change consists in the way the sampling with replacement is performed from the original sample so to take into account the two-level data structure represented by clusters and individuals within clusters at each bootstrap iteration <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>. In short, the TSB procedure can be summarised in the following steps:</p>
<ol type="1">
<li>Generate a “bootstrap” sample by <em>sampling with replacement</em> clusters from the original dataset and then sample QALY and TC individual values together within each resampled cluster</li>
<li>Fit the desired model to the newly obtained bootstrap sample to derive bootstrap estimates for the quantities of interest (eg mean outcome differences), for example using OLS or SUR models (ie <span class="math inline">\(\hat{\beta}^b_1\)</span> and <span class="math inline">\(\hat{\alpha}^b_1\)</span>)</li>
<li>Repeat step 1-2 for a large number of bootstrap iterations <span class="math inline">\(B\)</span> (eg <span class="math inline">\(5000\)</span>) and store the results to generate a set of <span class="math inline">\(B\)</span> bootstrap estimates for <span class="math inline">\(b=1,\ldots,B\)</span></li>
<li>Use the stored sets of bootstrap estimates (ie <span class="math inline">\(\hat{\beta}^b_1\)</span> and <span class="math inline">\(\hat{\alpha}^b_1\)</span>) to <em>empirically</em> approximate the sampling distribution of the parameters of interest.</li>
<li>Use this distribution of estimates to quantify the level of uncertainty around the quantities of interest, eg in terms of confidence intervals.</li>
</ol>
<p>A limitation of standard TSB is that, due to the two-stage sampling procedure, it is very likely that the level of uncertainty, and so the variance of the estimated quantities, is <strong>overestimated</strong>. Thus, some form of <em>shrinkage correction</em> should be implemented within the TSB procedure to correct for variance overestimation <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>. When using this correction, the TSB procedure is modified by shrinking cluster means and estimating individual residuals from the cluster means before any sampling is performed. Next, resampling is first applied to the shrunk cluster means, and then to the individual residuals. Finally, the resampled cluster means and individual residuals are combined to obtain a complete bootstrap sample, for which steps 2-5 are then followed.</p>
<p>The following (folded) code part shows how to construct an <code>R</code> function which allows to implement a non-parametric TSB procedure with shrinkage correction for QALY and TC variables and derive bootstrapped estimates for marginal and incremental mean estimates by fitting a OLS or SUR model to each bootstrapped sample.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table) <span class="co">#package to handle datasets more efficiently</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bootstrap) <span class="co">#package to use bootstrap procedure </span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rlang)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>tsboot_ec <span class="ot">&lt;-</span> <span class="cf">function</span>(data, B, QALYreg, TCreg, <span class="at">method =</span> <span class="st">"OLS"</span>, cluster, <span class="at">unbalclus=</span><span class="st">"donner"</span>,</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">profile_QALY=</span><span class="st">"default"</span>, <span class="at">profile_TC=</span><span class="st">"default"</span>, <span class="at">trt_pos =</span> <span class="dv">2</span>){</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.data.frame</span>(data)){<span class="fu">stop</span>(<span class="st">"data needs to be a data frame object"</span>)}</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(B)){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(B<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> <span class="sc">!</span>B<span class="sc">%%</span><span class="dv">1</span><span class="sc">==</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY model"</span>)}</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC model"</span>)}</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>method <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"OLS"</span>,<span class="st">"SUR"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method name"</span>)}</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(trt_pos) <span class="sc">|</span> <span class="fu">length</span>(trt_pos)<span class="sc">!=</span><span class="dv">1</span> <span class="sc">|</span> trt_pos<span class="sc">&lt;=</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide valid trt indicator position in regressions"</span>)}</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.character</span>(cluster)){<span class="fu">stop</span>(<span class="st">"please provide valid cluster variable name"</span>)}</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>cluster <span class="sc">%in%</span> <span class="fu">names</span>(data)){<span class="fu">stop</span>(<span class="st">"please provide valid cluster variable name"</span>)}</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>unbalclus <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"donner"</span>,<span class="st">"median"</span>,<span class="st">"mean"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method to compute avg cluster size when standardising"</span>)}</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">#convert cluster as factor and then numeric </span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>  data[,cluster] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">as.factor</span>(data[,cluster]))</span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check that cluster variable is integer </span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">all</span>(data[,cluster] <span class="sc">-</span> <span class="fu">floor</span>(data[,cluster]) <span class="sc">==</span> <span class="dv">0</span>)){<span class="fu">stop</span>(<span class="st">"cluster values should be integers"</span>)}</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>  n_size <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>] <span class="co">#original sample size</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">#n covariates </span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>  nX_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(QALYreg, data))[<span class="dv">2</span>]</span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>  nX_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(TCreg, data))[<span class="dv">2</span>]</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check that correct profile provided or set default</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(profile_QALY <span class="sc">!=</span> <span class="st">"default"</span>){</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.vector</span>(profile_QALY) <span class="sc">|</span> <span class="fu">length</span>(profile_QALY)<span class="sc">!=</span>nX_e){<span class="fu">stop</span>(<span class="st">"provide valid profile for QALYreg"</span>)}}</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(profile_TC <span class="sc">!=</span> <span class="st">"default"</span>){</span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.vector</span>(profile_TC) <span class="sc">|</span> <span class="fu">length</span>(profile_TC)<span class="sc">!=</span>nX_c){<span class="fu">stop</span>(<span class="st">"provide valid profile for TCreg"</span>)}}</span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator and outcomes from provided formula</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(trt_name_e <span class="sc">!=</span> trt_name_c){<span class="fu">stop</span>(<span class="st">"please provide same trt variable name and position in QALY and TC formuale"</span>)}</span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a>  QALY_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[<span class="dv">1</span>]</span>
<span id="cb59-35"><a href="#cb59-35" aria-hidden="true" tabindex="-1"></a>  TC_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[<span class="dv">1</span>]</span>
<span id="cb59-36"><a href="#cb59-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check if trt indicator is factor and store its levels</span></span>
<span id="cb59-37"><a href="#cb59-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.factor</span>(data[,trt_name_e])){</span>
<span id="cb59-38"><a href="#cb59-38" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb59-39"><a href="#cb59-39" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">levels</span>(data[,trt_name_e])} <span class="cf">else</span> {</span>
<span id="cb59-40"><a href="#cb59-40" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb59-41"><a href="#cb59-41" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">unique</span>(data[,trt_name_e])}</span>
<span id="cb59-42"><a href="#cb59-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(trt_lev)<span class="sc">!=</span><span class="dv">2</span>){<span class="fu">stop</span>(<span class="st">"The function only allows comparison between two trt groups"</span>)}</span>
<span id="cb59-43"><a href="#cb59-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare empty objects to contain bootstrapped estimates</span></span>
<span id="cb59-44"><a href="#cb59-44" aria-hidden="true" tabindex="-1"></a>  coeff_e <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb59-45"><a href="#cb59-45" aria-hidden="true" tabindex="-1"></a>  coeff_c <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb59-46"><a href="#cb59-46" aria-hidden="true" tabindex="-1"></a>  em_e_ctr <span class="ot">&lt;-</span> em_e_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb59-47"><a href="#cb59-47" aria-hidden="true" tabindex="-1"></a>  em_c_ctr <span class="ot">&lt;-</span> em_c_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb59-48"><a href="#cb59-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){</span>
<span id="cb59-49"><a href="#cb59-49" aria-hidden="true" tabindex="-1"></a>    count <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set count for while loop across strata</span></span>
<span id="cb59-50"><a href="#cb59-50" aria-hidden="true" tabindex="-1"></a>    n.strata <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(data[,trt_name_e]))</span>
<span id="cb59-51"><a href="#cb59-51" aria-hidden="true" tabindex="-1"></a>    shrunk.data <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb59-52"><a href="#cb59-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (count<span class="sc">&lt;</span>n.strata){</span>
<span id="cb59-53"><a href="#cb59-53" aria-hidden="true" tabindex="-1"></a>    count <span class="ot">&lt;-</span> count<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb59-54"><a href="#cb59-54" aria-hidden="true" tabindex="-1"></a>    data1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(data[data[,trt_name_e]<span class="sc">==</span><span class="fu">unique</span>(data[,trt_name_e])[count],])</span>
<span id="cb59-55"><a href="#cb59-55" aria-hidden="true" tabindex="-1"></a>    clus.size <span class="ot">&lt;-</span> <span class="fu">table</span>(data1[,cluster])</span>
<span id="cb59-56"><a href="#cb59-56" aria-hidden="true" tabindex="-1"></a>    cost.x <span class="ot">&lt;-</span> <span class="fu">tapply</span>(data1[,TC_name],data1[,cluster],mean) <span class="co"># calc cluster means</span></span>
<span id="cb59-57"><a href="#cb59-57" aria-hidden="true" tabindex="-1"></a>    qaly.x <span class="ot">&lt;-</span> <span class="fu">tapply</span>(data1[,QALY_name],data1[,cluster],mean) <span class="co"># calc cluster means</span></span>
<span id="cb59-58"><a href="#cb59-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># STANDARDIZE Z: calc b for standardiwing z</span></span>
<span id="cb59-59"><a href="#cb59-59" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(data1[,cluster]))</span>
<span id="cb59-60"><a href="#cb59-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">var</span>(clus.size)<span class="sc">==</span><span class="dv">0</span>){</span>
<span id="cb59-61"><a href="#cb59-61" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">unique</span>(clus.size)</span>
<span id="cb59-62"><a href="#cb59-62" aria-hidden="true" tabindex="-1"></a>   } <span class="cf">else</span> {</span>
<span id="cb59-63"><a href="#cb59-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"donner"</span>){</span>
<span id="cb59-64"><a href="#cb59-64" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = Donner"</span>),<span class="cn">NA</span>)</span>
<span id="cb59-65"><a href="#cb59-65" aria-hidden="true" tabindex="-1"></a>     n <span class="ot">&lt;-</span> <span class="fu">sum</span>(clus.size)</span>
<span id="cb59-66"><a href="#cb59-66" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> (n<span class="sc">-</span>(<span class="fu">sum</span>(clus.size<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span>n))<span class="sc">/</span>(a<span class="dv">-1</span>)</span>
<span id="cb59-67"><a href="#cb59-67" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"median"</span>){</span>
<span id="cb59-68"><a href="#cb59-68" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = median"</span>),<span class="cn">NA</span>)</span>
<span id="cb59-69"><a href="#cb59-69" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">median</span>(clus.size)</span>
<span id="cb59-70"><a href="#cb59-70" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"mean"</span>){</span>
<span id="cb59-71"><a href="#cb59-71" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = mean"</span>),<span class="cn">NA</span>)</span>
<span id="cb59-72"><a href="#cb59-72" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">mean</span>(clus.size)</span>
<span id="cb59-73"><a href="#cb59-73" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {}</span>
<span id="cb59-74"><a href="#cb59-74" aria-hidden="true" tabindex="-1"></a>   } <span class="co"># End of 'else'</span></span>
<span id="cb59-75"><a href="#cb59-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># standardise z using cluster means (dfm = deviation from cluster mean)</span></span>
<span id="cb59-76"><a href="#cb59-76" aria-hidden="true" tabindex="-1"></a>    cost.dfm <span class="ot">&lt;-</span> data1[,TC_name]<span class="sc">-</span><span class="fu">rep</span>(cost.x,<span class="at">times=</span>clus.size)</span>
<span id="cb59-77"><a href="#cb59-77" aria-hidden="true" tabindex="-1"></a>    qaly.dfm <span class="ot">&lt;-</span> data1[,QALY_name]<span class="sc">-</span><span class="fu">rep</span>(qaly.x,<span class="at">times=</span>clus.size)</span>
<span id="cb59-78"><a href="#cb59-78" aria-hidden="true" tabindex="-1"></a>    cost.z <span class="ot">&lt;-</span> (cost.dfm)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="dv">1-1</span><span class="sc">/</span>b)</span>
<span id="cb59-79"><a href="#cb59-79" aria-hidden="true" tabindex="-1"></a>    qaly.z <span class="ot">&lt;-</span> (qaly.dfm)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="dv">1-1</span><span class="sc">/</span>b)</span>
<span id="cb59-80"><a href="#cb59-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SHRINKAGE: calc c for shrinking x</span></span>
<span id="cb59-81"><a href="#cb59-81" aria-hidden="true" tabindex="-1"></a>    cost.ssw <span class="ot">&lt;-</span> <span class="fu">sum</span>(cost.dfm<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb59-82"><a href="#cb59-82" aria-hidden="true" tabindex="-1"></a>    qaly.ssw <span class="ot">&lt;-</span> <span class="fu">sum</span>(qaly.dfm<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb59-83"><a href="#cb59-83" aria-hidden="true" tabindex="-1"></a>    cost.ssb <span class="ot">&lt;-</span> <span class="fu">sum</span>((cost.x<span class="sc">-</span><span class="fu">mean</span>(cost.x))<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb59-84"><a href="#cb59-84" aria-hidden="true" tabindex="-1"></a>    qaly.ssb <span class="ot">&lt;-</span> <span class="fu">sum</span>((qaly.x<span class="sc">-</span><span class="fu">mean</span>(qaly.x))<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb59-85"><a href="#cb59-85" aria-hidden="true" tabindex="-1"></a>    cost.rhs <span class="ot">&lt;-</span> a<span class="sc">/</span>(a<span class="dv">-1</span>) <span class="sc">-</span> cost.ssw<span class="sc">/</span>(b<span class="sc">*</span>(b<span class="dv">-1</span>)<span class="sc">*</span>cost.ssb)</span>
<span id="cb59-86"><a href="#cb59-86" aria-hidden="true" tabindex="-1"></a>    qaly.rhs <span class="ot">&lt;-</span> a<span class="sc">/</span>(a<span class="dv">-1</span>) <span class="sc">-</span> qaly.ssw<span class="sc">/</span>(b<span class="sc">*</span>(b<span class="dv">-1</span>)<span class="sc">*</span>qaly.ssb)</span>
<span id="cb59-87"><a href="#cb59-87" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(cost.rhs<span class="sc">&lt;</span><span class="dv">0</span>, cost.c<span class="ot">&lt;-</span><span class="dv">1</span>, cost.c<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">-</span><span class="fu">sqrt</span>(cost.rhs))</span>
<span id="cb59-88"><a href="#cb59-88" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(qaly.rhs<span class="sc">&lt;</span><span class="dv">0</span>, qaly.c<span class="ot">&lt;-</span><span class="dv">1</span>, qaly.c<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">-</span><span class="fu">sqrt</span>(qaly.rhs))</span>
<span id="cb59-89"><a href="#cb59-89" aria-hidden="true" tabindex="-1"></a>    <span class="do">## re-calc x</span></span>
<span id="cb59-90"><a href="#cb59-90" aria-hidden="true" tabindex="-1"></a>    cost.x <span class="ot">&lt;-</span> cost.c<span class="sc">*</span><span class="fu">mean</span>(data1[,TC_name]) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>cost.c)<span class="sc">*</span>cost.x</span>
<span id="cb59-91"><a href="#cb59-91" aria-hidden="true" tabindex="-1"></a>    qaly.x <span class="ot">&lt;-</span> qaly.c<span class="sc">*</span><span class="fu">mean</span>(data1[,QALY_name]) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>qaly.c)<span class="sc">*</span>qaly.x</span>
<span id="cb59-92"><a href="#cb59-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># TWO-STAGE SAMPLING &amp; RE-CONSTRUCT OBS WITH SHRUNKEN MEANS AND STANDARDISED RESIDUALS</span></span>
<span id="cb59-93"><a href="#cb59-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gen random clus (order) id with replacement</span></span>
<span id="cb59-94"><a href="#cb59-94" aria-hidden="true" tabindex="-1"></a>    sampled.x.cid <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">unique</span>(data1[,cluster])),<span class="at">replace=</span>T)</span>
<span id="cb59-95"><a href="#cb59-95" aria-hidden="true" tabindex="-1"></a>    sampled.z.iid <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(cost.z),<span class="fu">sum</span>(clus.size[sampled.x.cid]),<span class="at">replace=</span>T) <span class="co"># chosen ind ids     for varying stratum sizes</span></span>
<span id="cb59-96"><a href="#cb59-96" aria-hidden="true" tabindex="-1"></a>    sampled.cost <span class="ot">&lt;-</span> <span class="fu">rep</span>(cost.x[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid])<span class="sc">+</span>cost.z[sampled.z.iid]</span>
<span id="cb59-97"><a href="#cb59-97" aria-hidden="true" tabindex="-1"></a>    sampled.qaly <span class="ot">&lt;-</span> <span class="fu">rep</span>(qaly.x[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid])<span class="sc">+</span>qaly.z[sampled.z.iid]</span>
<span id="cb59-98"><a href="#cb59-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># bind data from multiple strata together</span></span>
<span id="cb59-99"><a href="#cb59-99" aria-hidden="true" tabindex="-1"></a>    shrunk.data <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">rbind</span>(shrunk.data,<span class="fu">cbind</span>(sampled.cost,sampled.qaly,</span>
<span id="cb59-100"><a href="#cb59-100" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="fu">unique</span>(data1[,cluster])[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid]),</span>
<span id="cb59-101"><a href="#cb59-101" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="fu">unique</span>(data[,trt_name_e])[count],<span class="at">times=</span><span class="fu">sum</span>(clus.size[sampled.x.cid])))))</span>
<span id="cb59-102"><a href="#cb59-102" aria-hidden="true" tabindex="-1"></a>  } <span class="co"># end of while</span></span>
<span id="cb59-103"><a href="#cb59-103" aria-hidden="true" tabindex="-1"></a>  <span class="co">#rename variables</span></span>
<span id="cb59-104"><a href="#cb59-104" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(shrunk.data) <span class="ot">&lt;-</span> <span class="fu">c</span>(TC_name,QALY_name,cluster,trt_name_e)</span>
<span id="cb59-105"><a href="#cb59-105" aria-hidden="true" tabindex="-1"></a>  <span class="co">#copy trt levels if factor</span></span>
<span id="cb59-106"><a href="#cb59-106" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is_true</span>(trt_fact)){ </span>
<span id="cb59-107"><a href="#cb59-107" aria-hidden="true" tabindex="-1"></a>    shrunk.data[,trt_name_e] <span class="ot">&lt;-</span> <span class="fu">factor</span>(shrunk.data[,trt_name_e], <span class="at">levels=</span><span class="fu">sort</span>(<span class="fu">unique</span>(shrunk.data[,trt_name_e])), <span class="at">labels =</span> trt_lev)}</span>
<span id="cb59-108"><a href="#cb59-108" aria-hidden="true" tabindex="-1"></a>    <span class="co">#create a dt object</span></span>
<span id="cb59-109"><a href="#cb59-109" aria-hidden="true" tabindex="-1"></a>    dataset_tsb.dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(shrunk.data)</span>
<span id="cb59-110"><a href="#cb59-110" aria-hidden="true" tabindex="-1"></a>    <span class="co">#fit model</span></span>
<span id="cb59-111"><a href="#cb59-111" aria-hidden="true" tabindex="-1"></a>    model_ec <span class="ot">&lt;-</span> <span class="fu">systemfit</span>(<span class="fu">list</span>(<span class="at">QALYreg =</span> QALYreg, <span class="at">TCreg =</span> TCreg), </span>
<span id="cb59-112"><a href="#cb59-112" aria-hidden="true" tabindex="-1"></a>                          <span class="at">method=</span>method, <span class="at">data=</span>dataset_tsb.dt)</span>
<span id="cb59-113"><a href="#cb59-113" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract covariate values</span></span>
<span id="cb59-114"><a href="#cb59-114" aria-hidden="true" tabindex="-1"></a>    X_e <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])</span>
<span id="cb59-115"><a href="#cb59-115" aria-hidden="true" tabindex="-1"></a>    X_c <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])</span>
<span id="cb59-116"><a href="#cb59-116" aria-hidden="true" tabindex="-1"></a>    <span class="co">#define QALYreg profile</span></span>
<span id="cb59-117"><a href="#cb59-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(profile_QALY <span class="sc">==</span> <span class="st">"default"</span>){</span>
<span id="cb59-118"><a href="#cb59-118" aria-hidden="true" tabindex="-1"></a>     profile_b_QALY <span class="ot">&lt;-</span> <span class="fu">apply</span>(X_e, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T)</span>
<span id="cb59-119"><a href="#cb59-119" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {profile_b_QALY <span class="ot">&lt;-</span> profile_QALY}</span>
<span id="cb59-120"><a href="#cb59-120" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_ctr <span class="ot">&lt;-</span> profile_b_QALY_int <span class="ot">&lt;-</span> profile_b_QALY</span>
<span id="cb59-121"><a href="#cb59-121" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_ctr[trt_pos] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set profile for comparator</span></span>
<span id="cb59-122"><a href="#cb59-122" aria-hidden="true" tabindex="-1"></a>    profile_b_QALY_int[trt_pos] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#set profile for reference</span></span>
<span id="cb59-123"><a href="#cb59-123" aria-hidden="true" tabindex="-1"></a>    <span class="co">#define TCreg profile</span></span>
<span id="cb59-124"><a href="#cb59-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(profile_TC <span class="sc">==</span> <span class="st">"default"</span>){</span>
<span id="cb59-125"><a href="#cb59-125" aria-hidden="true" tabindex="-1"></a>     profile_b_TC <span class="ot">&lt;-</span> <span class="fu">apply</span>(X_c, <span class="dv">2</span>, mean, <span class="at">na.rm=</span>T)</span>
<span id="cb59-126"><a href="#cb59-126" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {profile_b_TC <span class="ot">&lt;-</span> profile_TC}</span>
<span id="cb59-127"><a href="#cb59-127" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_ctr <span class="ot">&lt;-</span> profile_b_TC_int <span class="ot">&lt;-</span> profile_b_TC</span>
<span id="cb59-128"><a href="#cb59-128" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_ctr[trt_pos] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set profile for comparator</span></span>
<span id="cb59-129"><a href="#cb59-129" aria-hidden="true" tabindex="-1"></a>    profile_b_TC_int[trt_pos] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#set profile for reference</span></span>
<span id="cb59-130"><a href="#cb59-130" aria-hidden="true" tabindex="-1"></a>    <span class="co">#extract coefficient estimates from each model</span></span>
<span id="cb59-131"><a href="#cb59-131" aria-hidden="true" tabindex="-1"></a>    coeff_e[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb59-132"><a href="#cb59-132" aria-hidden="true" tabindex="-1"></a>    coeff_c[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[trt_pos,<span class="st">"Estimate"</span>]</span>
<span id="cb59-133"><a href="#cb59-133" aria-hidden="true" tabindex="-1"></a>    <span class="co">#compute linear combination of parameters</span></span>
<span id="cb59-134"><a href="#cb59-134" aria-hidden="true" tabindex="-1"></a>    em_e_ctr[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_QALY_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb59-135"><a href="#cb59-135" aria-hidden="true" tabindex="-1"></a>    em_e_int[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_QALY_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">1</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb59-136"><a href="#cb59-136" aria-hidden="true" tabindex="-1"></a>    em_c_ctr[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_TC_ctr) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb59-137"><a href="#cb59-137" aria-hidden="true" tabindex="-1"></a>    em_c_int[i] <span class="ot">&lt;-</span> <span class="fu">t</span>(profile_b_TC_int) <span class="sc">%*%</span> <span class="fu">summary</span>(model_ec<span class="sc">$</span>eq[[<span class="dv">2</span>]])<span class="sc">$</span>coefficients[,<span class="st">"Estimate"</span>] </span>
<span id="cb59-138"><a href="#cb59-138" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb59-139"><a href="#cb59-139" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create list objects to store all results </span></span>
<span id="cb59-140"><a href="#cb59-140" aria-hidden="true" tabindex="-1"></a>  res_e_tsb_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>coeff_e,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>em_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>em_e_int)</span>
<span id="cb59-141"><a href="#cb59-141" aria-hidden="true" tabindex="-1"></a>  res_c_tsb_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_c"</span><span class="ot">=</span>coeff_c,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>em_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>em_c_int)</span>
<span id="cb59-142"><a href="#cb59-142" aria-hidden="true" tabindex="-1"></a>  input_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"data"</span><span class="ot">=</span>data, <span class="st">"method"</span><span class="ot">=</span>method, <span class="st">"trt_pos"</span><span class="ot">=</span>trt_pos, <span class="st">"QALYreg"</span><span class="ot">=</span>QALYreg,</span>
<span id="cb59-143"><a href="#cb59-143" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TCreg"</span><span class="ot">=</span>TCreg,<span class="st">"profile_QALY_ctr"</span><span class="ot">=</span>profile_b_QALY_ctr,</span>
<span id="cb59-144"><a href="#cb59-144" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"profile_QALY_int"</span><span class="ot">=</span>profile_b_QALY_int,<span class="st">"profile_TC_ctr"</span><span class="ot">=</span>profile_b_TC_ctr,</span>
<span id="cb59-145"><a href="#cb59-145" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"profile_TC_int"</span><span class="ot">=</span>profile_b_TC_int, <span class="st">"cluster"</span><span class="ot">=</span>cluster, <span class="st">"unbalclus"</span><span class="ot">=</span>unbalclus)</span>
<span id="cb59-146"><a href="#cb59-146" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute overall list and return it as output from the function</span></span>
<span id="cb59-147"><a href="#cb59-147" aria-hidden="true" tabindex="-1"></a>  res_ec_tsb_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"QALY_boot"</span><span class="ot">=</span>res_e_tsb_list,<span class="st">"TC_boot"</span><span class="ot">=</span>res_c_tsb_list,<span class="st">"inputs"</span><span class="ot">=</span>input_list)</span>
<span id="cb59-148"><a href="#cb59-148" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(res_ec_tsb_list) <span class="ot">&lt;-</span> <span class="st">"tsbootCE"</span></span>
<span id="cb59-149"><a href="#cb59-149" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_ec_tsb_list)</span>
<span id="cb59-150"><a href="#cb59-150" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can now apply the newly created TSB function called <code>tsboot_res</code> to our generated dataset to obtain <span class="math inline">\(B=200\)</span> bootstrapped estimates for the parameters of interest, which are here stored in a list object called <code>tsboot_res</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to dataset</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>tsboot_res <span class="ot">&lt;-</span> <span class="fu">tsboot_ec</span>(<span class="at">data =</span> data.clus.df, <span class="at">QALYreg =</span> QALY <span class="sc">~</span> trt, <span class="at">cluster =</span> <span class="st">"cluster"</span>,</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">TCreg =</span> TC <span class="sc">~</span> trt, <span class="at">method =</span> <span class="st">"OLS"</span>, <span class="at">B=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Next, we can use the functions <code>jk_ec</code> and <code>boot_ci</code> shown in <a href="#sec-corr" class="quarto-xref">Section&nbsp;2</a> to compute bootstrapped confidence intervals. As an example, we can now apply the newly created bootstrap function called <code>boot_ci</code> to our bootstrap results stored in the object <code>tsboot_res</code> to compute bootstrapped confidence intervals for all stored quantities using either the BCa approach (selected through the argument <code>method</code>).</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to TSB results</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>tsboot_ci_bca <span class="ot">&lt;-</span> <span class="fu">boot_ci</span>(<span class="at">x =</span> tsboot_res, <span class="at">method =</span> <span class="st">"BCa"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>tsboot_ci_bca</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>$Delta_e
0.5842263%  91.91954% 
-0.1961036  0.1850060 

$Delta_c
0.8417625%  93.69878% 
  2.949009  32.641264 

$mu_e_ctr
5.173335% 98.90882% 
0.4810873 0.7642355 

$mu_e_int
1.631128% 96.27396% 
0.4918447 0.7677400 

$mu_c_ctr
8.490612% 99.46002% 
 92.51988 112.04817 

$mu_c_int
1.857534% 96.67969% 
 109.7356  130.1179 </code></pre>
</div>
</div>
<p>For completeness, in the following (folded) code part, I also provide the same TSB functions but tailored to the specification of independent GLMs rather than OLS/SUR models only possible with <code>tsboot_res</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">#note that compared to the function developed before for OLS/SUR models, this one</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">#does not require to provide profiles for the computation of mean estimates but instead relies on the emmeans function to obtain these estimates without manual computation. Because of this the function is less flexible and can only evaluate mean estimates assuming a single profile for both QALY and TC models (the one used by emmeans to compute these quantities). However, the function needs the user to specify different distributions and link functions for the QALY and TC models. </span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rlang)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mfx) </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bootstrap)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans)</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>tsboot_ec_glm <span class="ot">&lt;-</span> <span class="cf">function</span>(data, B, QALYreg, TCreg, QALY_dist, TC_dist, </span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                        QALY_link, TC_link, cluster, <span class="at">unbalclus=</span><span class="st">"donner"</span>, <span class="at">trt_pos =</span> <span class="dv">2</span>){</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#the following lines are needed to make sure proper inputs are given</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.data.frame</span>(data)){<span class="fu">stop</span>(<span class="st">"data needs to be a data frame object"</span>)}</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(B)){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(B<span class="sc">&lt;=</span><span class="dv">0</span> <span class="sc">|</span> <span class="sc">!</span>B<span class="sc">%%</span><span class="dv">1</span><span class="sc">==</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide number of bootstrap iterations"</span>)}</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(QALYreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for QALY model"</span>)}</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is_formula</span>(TCreg)){<span class="fu">stop</span>(<span class="st">"please provide formula for TC model"</span>)}</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>QALY_dist <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Beta"</span>,<span class="st">"Binomial"</span>,<span class="st">"NegBinomial"</span>,<span class="st">"Gamma"</span>,<span class="st">"InvGaussian"</span>,<span class="st">"Poisson"</span>,<span class="st">"Gaussian"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid distribution name"</span>)}</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>TC_dist <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Beta"</span>,<span class="st">"Binomial"</span>,<span class="st">"NegBinomial"</span>,<span class="st">"Gamma"</span>,<span class="st">"InvGaussian"</span>,<span class="st">"Poisson"</span>,<span class="st">"Gaussian"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid distribution name"</span>)}</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>QALY_link <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"logit"</span>,<span class="st">"probit"</span>,<span class="st">"cauchit"</span>, <span class="st">"cloglog"</span>, <span class="st">"identity"</span>, <span class="st">"log"</span>, <span class="st">"sqrt"</span>, <span class="st">"1/mu^2"</span>, <span class="st">"inverse"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid link function name"</span>)}</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>TC_link <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"logit"</span>,<span class="st">"probit"</span>,<span class="st">"cauchit"</span>, <span class="st">"cloglog"</span>, <span class="st">"identity"</span>, <span class="st">"log"</span>, <span class="st">"sqrt"</span>, <span class="st">"1/mu^2"</span>, <span class="st">"inverse"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid link function name"</span>)}</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.numeric</span>(trt_pos) <span class="sc">|</span> <span class="fu">length</span>(trt_pos)<span class="sc">!=</span><span class="dv">1</span> <span class="sc">|</span> trt_pos<span class="sc">&lt;=</span><span class="dv">0</span>){<span class="fu">stop</span>(<span class="st">"please provide valid trt indicator position in regressions"</span>)}</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.character</span>(cluster)){<span class="fu">stop</span>(<span class="st">"please provide valid cluster variable name"</span>)}</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>cluster <span class="sc">%in%</span> <span class="fu">names</span>(data)){<span class="fu">stop</span>(<span class="st">"please provide valid cluster variable name"</span>)}</span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>unbalclus <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"donner"</span>,<span class="st">"median"</span>,<span class="st">"mean"</span>)){<span class="fu">stop</span>(<span class="st">"please provide valid method to compute avg cluster size when standardising"</span>)}</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">#convert cluster as factor and then numeric </span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>  data[,cluster] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">as.factor</span>(data[,cluster]))</span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check that cluster variable is integer </span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">all</span>(data[,cluster] <span class="sc">-</span> <span class="fu">floor</span>(data[,cluster]) <span class="sc">==</span> <span class="dv">0</span>)){<span class="fu">stop</span>(<span class="st">"cluster values should be integers"</span>)}</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>  n_size <span class="ot">&lt;-</span> <span class="fu">dim</span>(data)[<span class="dv">1</span>] <span class="co">#original sample size</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">#n covariates </span></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>  nX_e <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(QALYreg, data))[<span class="dv">2</span>]</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>  nX_c <span class="ot">&lt;-</span> <span class="fu">dim</span>(<span class="fu">model.matrix</span>(TCreg, data))[<span class="dv">2</span>]</span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">#extract name of trt indicator and outcomes from provided formula</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a>  trt_name_e <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[trt_pos]</span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a>  trt_name_c <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[trt_pos]</span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(trt_name_e <span class="sc">!=</span> trt_name_c){<span class="fu">stop</span>(<span class="st">"please provide same trt variable name and position in QALY and TC formuale"</span>)}</span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>  QALY_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(QALYreg)[<span class="dv">1</span>]</span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>  TC_name <span class="ot">&lt;-</span> <span class="fu">all.vars</span>(TCreg)[<span class="dv">1</span>]</span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">#check if trt indicator is factor and store its levels</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.factor</span>(data[,trt_name_e])){</span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">levels</span>(data[,trt_name_e])} <span class="cf">else</span> {</span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>    trt_fact <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a>    trt_lev <span class="ot">&lt;-</span> <span class="fu">unique</span>(data[,trt_name_e])}</span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(trt_lev)<span class="sc">!=</span><span class="dv">2</span>){<span class="fu">stop</span>(<span class="st">"The function only allows comparison between two trt groups"</span>)}</span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>  <span class="co">#prepare empty objects to contain bootstrapped estimates</span></span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>  coeff_e <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a>  coeff_c <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a>  em_e_ctr <span class="ot">&lt;-</span> em_e_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a>  em_c_ctr <span class="ot">&lt;-</span> em_c_int <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B){</span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a>    count <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#set count for while loop across strata</span></span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a>    n.strata <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(data[,trt_name_e]))</span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a>    shrunk.data <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (count<span class="sc">&lt;</span>n.strata){</span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a>    count <span class="ot">&lt;-</span> count<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a>    data1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(data[data[,trt_name_e]<span class="sc">==</span><span class="fu">unique</span>(data[,trt_name_e])[count],])</span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a>    clus.size <span class="ot">&lt;-</span> <span class="fu">table</span>(data1[,cluster])</span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a>    cost.x <span class="ot">&lt;-</span> <span class="fu">tapply</span>(data1[,TC_name],data1[,cluster],mean) <span class="co"># calc cluster means</span></span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a>    qaly.x <span class="ot">&lt;-</span> <span class="fu">tapply</span>(data1[,QALY_name],data1[,cluster],mean) <span class="co"># calc cluster means</span></span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># STANDARDIZE Z: calc b for standardiwing z</span></span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(data1[,cluster]))</span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">var</span>(clus.size)<span class="sc">==</span><span class="dv">0</span>){</span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">unique</span>(clus.size)</span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true" tabindex="-1"></a>   } <span class="cf">else</span> {</span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"donner"</span>){</span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = Donner"</span>),<span class="cn">NA</span>)</span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true" tabindex="-1"></a>     n <span class="ot">&lt;-</span> <span class="fu">sum</span>(clus.size)</span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> (n<span class="sc">-</span>(<span class="fu">sum</span>(clus.size<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span>n))<span class="sc">/</span>(a<span class="dv">-1</span>)</span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"median"</span>){</span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = median"</span>),<span class="cn">NA</span>)</span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">median</span>(clus.size)</span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (unbalclus<span class="sc">==</span><span class="st">"mean"</span>){</span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true" tabindex="-1"></a>     <span class="fu">ifelse</span>(warning,<span class="fu">print</span>(<span class="st">"'average' clus size = mean"</span>),<span class="cn">NA</span>)</span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> <span class="fu">mean</span>(clus.size)</span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {}</span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true" tabindex="-1"></a>   } <span class="co"># End of 'else'</span></span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># standardise z using cluster means (dfm = deviation from cluster mean)</span></span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true" tabindex="-1"></a>    cost.dfm <span class="ot">&lt;-</span> data1[,TC_name]<span class="sc">-</span><span class="fu">rep</span>(cost.x,<span class="at">times=</span>clus.size)</span>
<span id="cb63-80"><a href="#cb63-80" aria-hidden="true" tabindex="-1"></a>    qaly.dfm <span class="ot">&lt;-</span> data1[,QALY_name]<span class="sc">-</span><span class="fu">rep</span>(qaly.x,<span class="at">times=</span>clus.size)</span>
<span id="cb63-81"><a href="#cb63-81" aria-hidden="true" tabindex="-1"></a>    cost.z <span class="ot">&lt;-</span> (cost.dfm)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="dv">1-1</span><span class="sc">/</span>b)</span>
<span id="cb63-82"><a href="#cb63-82" aria-hidden="true" tabindex="-1"></a>    qaly.z <span class="ot">&lt;-</span> (qaly.dfm)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="dv">1-1</span><span class="sc">/</span>b)</span>
<span id="cb63-83"><a href="#cb63-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SHRINKAGE: calc c for shrinking x</span></span>
<span id="cb63-84"><a href="#cb63-84" aria-hidden="true" tabindex="-1"></a>    cost.ssw <span class="ot">&lt;-</span> <span class="fu">sum</span>(cost.dfm<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb63-85"><a href="#cb63-85" aria-hidden="true" tabindex="-1"></a>    qaly.ssw <span class="ot">&lt;-</span> <span class="fu">sum</span>(qaly.dfm<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb63-86"><a href="#cb63-86" aria-hidden="true" tabindex="-1"></a>    cost.ssb <span class="ot">&lt;-</span> <span class="fu">sum</span>((cost.x<span class="sc">-</span><span class="fu">mean</span>(cost.x))<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb63-87"><a href="#cb63-87" aria-hidden="true" tabindex="-1"></a>    qaly.ssb <span class="ot">&lt;-</span> <span class="fu">sum</span>((qaly.x<span class="sc">-</span><span class="fu">mean</span>(qaly.x))<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb63-88"><a href="#cb63-88" aria-hidden="true" tabindex="-1"></a>    cost.rhs <span class="ot">&lt;-</span> a<span class="sc">/</span>(a<span class="dv">-1</span>) <span class="sc">-</span> cost.ssw<span class="sc">/</span>(b<span class="sc">*</span>(b<span class="dv">-1</span>)<span class="sc">*</span>cost.ssb)</span>
<span id="cb63-89"><a href="#cb63-89" aria-hidden="true" tabindex="-1"></a>    qaly.rhs <span class="ot">&lt;-</span> a<span class="sc">/</span>(a<span class="dv">-1</span>) <span class="sc">-</span> qaly.ssw<span class="sc">/</span>(b<span class="sc">*</span>(b<span class="dv">-1</span>)<span class="sc">*</span>qaly.ssb)</span>
<span id="cb63-90"><a href="#cb63-90" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(cost.rhs<span class="sc">&lt;</span><span class="dv">0</span>, cost.c<span class="ot">&lt;-</span><span class="dv">1</span>, cost.c<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">-</span><span class="fu">sqrt</span>(cost.rhs))</span>
<span id="cb63-91"><a href="#cb63-91" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(qaly.rhs<span class="sc">&lt;</span><span class="dv">0</span>, qaly.c<span class="ot">&lt;-</span><span class="dv">1</span>, qaly.c<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">-</span><span class="fu">sqrt</span>(qaly.rhs))</span>
<span id="cb63-92"><a href="#cb63-92" aria-hidden="true" tabindex="-1"></a>    <span class="do">## re-calc x</span></span>
<span id="cb63-93"><a href="#cb63-93" aria-hidden="true" tabindex="-1"></a>    cost.x <span class="ot">&lt;-</span> cost.c<span class="sc">*</span><span class="fu">mean</span>(data1[,TC_name]) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>cost.c)<span class="sc">*</span>cost.x</span>
<span id="cb63-94"><a href="#cb63-94" aria-hidden="true" tabindex="-1"></a>    qaly.x <span class="ot">&lt;-</span> qaly.c<span class="sc">*</span><span class="fu">mean</span>(data1[,QALY_name]) <span class="sc">+</span> (<span class="dv">1</span><span class="sc">-</span>qaly.c)<span class="sc">*</span>qaly.x</span>
<span id="cb63-95"><a href="#cb63-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># TWO-STAGE SAMPLING &amp; RE-CONSTRUCT OBS WITH SHRUNKEN MEANS AND STANDARDISED RESIDUALS</span></span>
<span id="cb63-96"><a href="#cb63-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gen random clus (order) id with replacement</span></span>
<span id="cb63-97"><a href="#cb63-97" aria-hidden="true" tabindex="-1"></a>    sampled.x.cid <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">unique</span>(data1[,cluster])),<span class="at">replace=</span>T)</span>
<span id="cb63-98"><a href="#cb63-98" aria-hidden="true" tabindex="-1"></a>    sampled.z.iid <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(cost.z),<span class="fu">sum</span>(clus.size[sampled.x.cid]),<span class="at">replace=</span>T) <span class="co"># chosen ind ids     for varying stratum sizes</span></span>
<span id="cb63-99"><a href="#cb63-99" aria-hidden="true" tabindex="-1"></a>    sampled.cost <span class="ot">&lt;-</span> <span class="fu">rep</span>(cost.x[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid])<span class="sc">+</span>cost.z[sampled.z.iid]</span>
<span id="cb63-100"><a href="#cb63-100" aria-hidden="true" tabindex="-1"></a>    sampled.qaly <span class="ot">&lt;-</span> <span class="fu">rep</span>(qaly.x[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid])<span class="sc">+</span>qaly.z[sampled.z.iid]</span>
<span id="cb63-101"><a href="#cb63-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># bind data from multiple strata together</span></span>
<span id="cb63-102"><a href="#cb63-102" aria-hidden="true" tabindex="-1"></a>    shrunk.data <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">rbind</span>(shrunk.data,<span class="fu">cbind</span>(sampled.cost,sampled.qaly,</span>
<span id="cb63-103"><a href="#cb63-103" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="fu">unique</span>(data1[,cluster])[sampled.x.cid],<span class="at">times=</span>clus.size[sampled.x.cid]),</span>
<span id="cb63-104"><a href="#cb63-104" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="fu">unique</span>(data[,trt_name_e])[count],<span class="at">times=</span><span class="fu">sum</span>(clus.size[sampled.x.cid])))))</span>
<span id="cb63-105"><a href="#cb63-105" aria-hidden="true" tabindex="-1"></a>  } <span class="co"># end of while</span></span>
<span id="cb63-106"><a href="#cb63-106" aria-hidden="true" tabindex="-1"></a>  <span class="co">#rename variables</span></span>
<span id="cb63-107"><a href="#cb63-107" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(shrunk.data) <span class="ot">&lt;-</span> <span class="fu">c</span>(TC_name,QALY_name,cluster,trt_name_e)</span>
<span id="cb63-108"><a href="#cb63-108" aria-hidden="true" tabindex="-1"></a>  <span class="co">#copy trt levels if factor</span></span>
<span id="cb63-109"><a href="#cb63-109" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is_true</span>(trt_fact)){ </span>
<span id="cb63-110"><a href="#cb63-110" aria-hidden="true" tabindex="-1"></a>    shrunk.data[,trt_name_e] <span class="ot">&lt;-</span> <span class="fu">factor</span>(shrunk.data[,trt_name_e], <span class="at">levels=</span><span class="fu">sort</span>(<span class="fu">unique</span>(shrunk.data[,trt_name_e])), <span class="at">labels =</span> trt_lev)}</span>
<span id="cb63-111"><a href="#cb63-111" aria-hidden="true" tabindex="-1"></a>    <span class="co">#create a dt object</span></span>
<span id="cb63-112"><a href="#cb63-112" aria-hidden="true" tabindex="-1"></a>    dataset_tsb.dt <span class="ot">&lt;-</span> <span class="fu">data.table</span>(shrunk.data)</span>
<span id="cb63-113"><a href="#cb63-113" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (QALY)</span></span>
<span id="cb63-114"><a href="#cb63-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb63-115"><a href="#cb63-115" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">betareg</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">link =</span> QALY_link)}</span>
<span id="cb63-116"><a href="#cb63-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb63-117"><a href="#cb63-117" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">link =</span> QALY_link)}</span>
<span id="cb63-118"><a href="#cb63-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb63-119"><a href="#cb63-119" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb63-120"><a href="#cb63-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb63-121"><a href="#cb63-121" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb63-122"><a href="#cb63-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb63-123"><a href="#cb63-123" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb63-124"><a href="#cb63-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb63-125"><a href="#cb63-125" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> QALY_link))} </span>
<span id="cb63-126"><a href="#cb63-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(QALY_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb63-127"><a href="#cb63-127" aria-hidden="true" tabindex="-1"></a>      glm_e <span class="ot">&lt;-</span> <span class="fu">glm</span>(QALYreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> QALY_link))}</span>
<span id="cb63-128"><a href="#cb63-128" aria-hidden="true" tabindex="-1"></a>    <span class="co">#select and fit GLM based on distribution and link function (TC)</span></span>
<span id="cb63-129"><a href="#cb63-129" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Beta"</span>){</span>
<span id="cb63-130"><a href="#cb63-130" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">betareg</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">link =</span> TC_link)}</span>
<span id="cb63-131"><a href="#cb63-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"NegBinomial"</span>){</span>
<span id="cb63-132"><a href="#cb63-132" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm.nb</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">link =</span> TC_link)}</span>
<span id="cb63-133"><a href="#cb63-133" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Binomial"</span>){</span>
<span id="cb63-134"><a href="#cb63-134" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb63-135"><a href="#cb63-135" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gamma"</span>){</span>
<span id="cb63-136"><a href="#cb63-136" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">Gamma</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb63-137"><a href="#cb63-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"InvGaussian"</span>){</span>
<span id="cb63-138"><a href="#cb63-138" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">inverse.gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb63-139"><a href="#cb63-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Poisson"</span>){</span>
<span id="cb63-140"><a href="#cb63-140" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> TC_link))} </span>
<span id="cb63-141"><a href="#cb63-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(TC_dist<span class="sc">==</span><span class="st">"Gaussian"</span>){</span>
<span id="cb63-142"><a href="#cb63-142" aria-hidden="true" tabindex="-1"></a>      glm_c <span class="ot">&lt;-</span> <span class="fu">glm</span>(TCreg, <span class="at">data =</span> dataset_tsb.dt, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> TC_link))}</span>
<span id="cb63-143"><a href="#cb63-143" aria-hidden="true" tabindex="-1"></a>    <span class="co">#use emmeans function to get mean outcomes for each arm</span></span>
<span id="cb63-144"><a href="#cb63-144" aria-hidden="true" tabindex="-1"></a>    glm_e.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_e, trt_name_e, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> dataset_tsb.dt)</span>
<span id="cb63-145"><a href="#cb63-145" aria-hidden="true" tabindex="-1"></a>    glm_c.em <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(glm_c, trt_name_c, <span class="at">type =</span> <span class="st">"response"</span>, <span class="at">data =</span> dataset_tsb.dt)</span>
<span id="cb63-146"><a href="#cb63-146" aria-hidden="true" tabindex="-1"></a>    em_e_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb63-147"><a href="#cb63-147" aria-hidden="true" tabindex="-1"></a>    em_e_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_e.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb63-148"><a href="#cb63-148" aria-hidden="true" tabindex="-1"></a>    em_c_ctr[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb63-149"><a href="#cb63-149" aria-hidden="true" tabindex="-1"></a>    em_c_int[i] <span class="ot">&lt;-</span> <span class="fu">summary</span>(glm_c.em)[<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb63-150"><a href="#cb63-150" aria-hidden="true" tabindex="-1"></a>    <span class="co">#specify and compute mean differences between groups</span></span>
<span id="cb63-151"><a href="#cb63-151" aria-hidden="true" tabindex="-1"></a>    coeff_e[i] <span class="ot">&lt;-</span> em_e_int[i] <span class="sc">-</span> em_e_ctr[i]</span>
<span id="cb63-152"><a href="#cb63-152" aria-hidden="true" tabindex="-1"></a>    coeff_c[i] <span class="ot">&lt;-</span> em_c_int[i] <span class="sc">-</span> em_c_ctr[i]</span>
<span id="cb63-153"><a href="#cb63-153" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb63-154"><a href="#cb63-154" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create list objects to store all results </span></span>
<span id="cb63-155"><a href="#cb63-155" aria-hidden="true" tabindex="-1"></a>  res_e_tsb_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_e"</span><span class="ot">=</span>coeff_e,<span class="st">"mu_e_ctr"</span><span class="ot">=</span>em_e_ctr,<span class="st">"mu_e_int"</span><span class="ot">=</span>em_e_int)</span>
<span id="cb63-156"><a href="#cb63-156" aria-hidden="true" tabindex="-1"></a>  res_c_tsb_list <span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">"Delta_c"</span><span class="ot">=</span>coeff_c,<span class="st">"mu_c_ctr"</span><span class="ot">=</span>em_c_ctr,<span class="st">"mu_c_int"</span><span class="ot">=</span>em_c_int)</span>
<span id="cb63-157"><a href="#cb63-157" aria-hidden="true" tabindex="-1"></a>  input_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"data"</span><span class="ot">=</span>data, <span class="st">"trt_pos"</span><span class="ot">=</span>trt_pos, <span class="st">"QALYreg"</span><span class="ot">=</span>QALYreg,</span>
<span id="cb63-158"><a href="#cb63-158" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TCreg"</span><span class="ot">=</span>TCreg,<span class="st">"QALY_link"</span><span class="ot">=</span>QALY_link,<span class="st">"QALY_dist"</span><span class="ot">=</span>QALY_dist,</span>
<span id="cb63-159"><a href="#cb63-159" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"TC_dist"</span><span class="ot">=</span>TC_dist,<span class="st">"TC_link"</span><span class="ot">=</span>TC_link,<span class="st">"cluster"</span><span class="ot">=</span>cluster, <span class="st">"unbalclus"</span><span class="ot">=</span>unbalclus)</span>
<span id="cb63-160"><a href="#cb63-160" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute overall list and return it as output from the function</span></span>
<span id="cb63-161"><a href="#cb63-161" aria-hidden="true" tabindex="-1"></a>  res_ec_tsb_list <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"QALY_boot"</span><span class="ot">=</span>res_e_tsb_list,<span class="st">"TC_boot"</span><span class="ot">=</span>res_c_tsb_list,<span class="st">"inputs"</span><span class="ot">=</span>input_list)</span>
<span id="cb63-162"><a href="#cb63-162" aria-hidden="true" tabindex="-1"></a>  <span class="fu">class</span>(res_ec_tsb_list) <span class="ot">&lt;-</span> <span class="st">"tsbootCE_glm"</span></span>
<span id="cb63-163"><a href="#cb63-163" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(res_ec_tsb_list)</span>
<span id="cb63-164"><a href="#cb63-164" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb63-165"><a href="#cb63-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-166"><a href="#cb63-166" aria-hidden="true" tabindex="-1"></a><span class="co">#example on how to use function</span></span>
<span id="cb63-167"><a href="#cb63-167" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb63-168"><a href="#cb63-168" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb63-169"><a href="#cb63-169" aria-hidden="true" tabindex="-1"></a><span class="co">#apply function to dataset (here assume normal distributions since data simulated assuming normality)</span></span>
<span id="cb63-170"><a href="#cb63-170" aria-hidden="true" tabindex="-1"></a>tsboot_res_glm <span class="ot">&lt;-</span> <span class="fu">tsboot_ec_glm</span>(<span class="at">data =</span> data.clus.df, <span class="at">QALYreg =</span> QALY <span class="sc">~</span> trt, <span class="at">cluster =</span> <span class="st">"cluster"</span>,</span>
<span id="cb63-171"><a href="#cb63-171" aria-hidden="true" tabindex="-1"></a>                    <span class="at">TCreg =</span> TC <span class="sc">~</span> trt, <span class="at">QALY_dist =</span> <span class="st">"Gaussian"</span>, <span class="at">TC_dist =</span> <span class="st">"Gaussian"</span>,</span>
<span id="cb63-172"><a href="#cb63-172" aria-hidden="true" tabindex="-1"></a>                    <span class="at">QALY_link =</span> <span class="st">"identity"</span>, <span class="at">TC_link =</span> <span class="st">"identity"</span>, <span class="at">B=</span><span class="dv">200</span>)</span>
<span id="cb63-173"><a href="#cb63-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-174"><a href="#cb63-174" aria-hidden="true" tabindex="-1"></a><span class="co">#apply CI function to TSB results for GLMs</span></span>
<span id="cb63-175"><a href="#cb63-175" aria-hidden="true" tabindex="-1"></a>tsboot_ci_bca_glm <span class="ot">&lt;-</span> <span class="fu">boot_ci_glm</span>(<span class="at">x =</span> tsboot_res_glm, <span class="at">method =</span> <span class="st">"BCa"</span>, <span class="at">confidence =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="summary-3" class="level2">
<h2 class="anchored" data-anchor-id="summary-3">Summary</h2>
<p><strong>MLMs</strong> have been advocated in the literature as an ideal approach to deal with clustering in general scenarios, with poor performance only whan having a small number of clusters and sample size <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>. However, especially within a frequentist framework, the implementation of MLMs faces serious issues when deviating from standard methods assuming normality and, even under said assumptions, specification of a joint multivariate random effects model is often not trivial using standard software packages.</p>
<p><strong>TSB</strong> has been proposed as an alternative approach to handle clustering by correctly replicating the clustered structure at each bootstrap iteration in combination with standard statistical regression methods (eg OLS). Implementation of TSB without <em>shrinkage correction</em> is not recommended since the method tends to overestimate uncertainty due to the inherent double sampling procedure. However, even when the correction is applied and similarly to MLMs, it has been shown that TSB can perform poorly when dealing with a small number of clusters and sample sizes <span class="citation" data-cites="gomes2012developing">(<a href="#ref-gomes2012developing" role="doc-biblioref">Gomes, Ng, et al. 2012</a>)</span>. In addition, as any non-parametric resampling method, different approaches can be used to obtain uncertainty measures for the bootstrapped quantities (eg confidence intervals), and a clear performance assessment of each alternative approach across all possible scenarios is lacking.</p>
<p>We note that, within a Bayesian framework, the possibility to rely on powerful and generic simulation methods such as <strong>Mark Chain Monte Carlo</strong> (MCMC) algorithms <span class="citation" data-cites="brooks2011handbook">(<a href="#ref-brooks2011handbook" role="doc-biblioref">Brooks et al. 2011</a>)</span> allows to implement MLMs more easily and assuming different parametric distributions for CE outcomes, thus allowing to deal with high level of skewness even in small samples <span class="citation" data-cites="grieve2010bayesian ng2016multilevel">(<a href="#ref-grieve2010bayesian" role="doc-biblioref">Grieve, Nixon, and Thompson 2010</a>; <a href="#ref-ng2016multilevel" role="doc-biblioref">Ng et al. 2016</a>)</span>.</p>
</section>
</section>
<section id="sec-missing" class="level1">
<h1>Missing Data</h1>
<p>The topic of missing data in trial-based CEA is huge and what I will attempt to cover here is merely a small piece of the overall picture from the literature, which I advice the interested reader to consult <span class="citation" data-cites="manca2005handling marshall2009can faria2014guide gomes2013multiple diaz2014handling gabrio2017handling gabrio2021joint mason2021flexible">(<a href="#ref-manca2005handling" role="doc-biblioref">Manca and Palmer 2005</a>; <a href="#ref-marshall2009can" role="doc-biblioref">Marshall, Billingham, and Bryan 2009</a>; <a href="#ref-faria2014guide" role="doc-biblioref">Faria et al. 2014</a>; <a href="#ref-gomes2013multiple" role="doc-biblioref">Gomes et al. 2013</a>; <a href="#ref-diaz2014handling" role="doc-biblioref">Dı́az-Ordaz, Kenward, and Grieve 2014</a>; <a href="#ref-gabrio2017handling" role="doc-biblioref">Gabrio, Mason, and Baio 2017</a>; <a href="#ref-gabrio2021joint" role="doc-biblioref">Gabrio et al. 2021</a>; <a href="#ref-mason2021flexible" role="doc-biblioref">Mason et al. 2021</a>)</span>.</p>
<p>What is more or less certain is that some missing outcome values for some individuals is likely to occur at least at some measurment collection time during the trial, which impairs the computation of aggregated CE variables (eg QALY and TC) for those cases. If prevention strategies did not work well and a considerable amount of missing values occurs in the trial, then we have to accept that our analysis will be characterised by some inherent uncertainty. Indeed, although different approaches for handling missing data have been proposed in the CEA literature, any method relies on some <strong>untestable</strong> assumptions about the missing values that cannot be checked from the data at hand.</p>
<p>The best we can do is try to:</p>
<ul>
<li>choose and formulate our <strong>assumptions</strong> about the missing cases in the most transparent and plausible way given the trial and analysis context;</li>
<li>select a <strong>missingness method</strong> that best matches those assumptions</li>
<li>explore the <strong>sensitivity of the results</strong> under the stated assumptions to some plausible departures</li>
</ul>
<p>For the first step, there is a general consensus in the literature of relying on the <em>Rubin’s taxonomy</em> to formally define the assumptions about the missing data generating process, often referred to as <strong>missing data mechanism</strong><span class="citation" data-cites="little2019statistical">(<a href="#ref-little2019statistical" role="doc-biblioref">Little and Rubin 2019</a>)</span>, which can be thought of as the mechanism responsible for the occurrence of missingness. According to the type of assumptions formulated, this mechanism can be broadly distinguished under three general classes:</p>
<ul>
<li><p><strong>Missing Completely At Random</strong> (MCAR): missingness occurs randomly and is therefore not cause or associated with any other variables (eg lost records).</p></li>
<li><p><strong>Missing At Random</strong> (MAR): missingness exclusively depends on some <em>observed</em> variable that is available (eg individuals have missing outcome data only because they are older and age is measured).</p></li>
<li><p><strong>Missing Not At Random</strong> (MNAR): missingness (also) depends on some <em>unobserved</em> variable that is not fully available (eg individuals have missing outcome data because they are experiencing lower health/higher costs and at least some of these values are not measured).</p></li>
</ul>
<p>Choice of the type of mechanism, and therefore missingness assumptions, for a specific analysis should be guided by both observed and external information available to the analysts, including missingness patterns, previous studies, clinical and expert knowledge. Once a decision is made about the “most” plausible mechanism, this should be set as the <strong>base-case</strong> assumption and a missingness method that provide vaòid results under the chosen assumption should be implemented for the analysis.</p>
<p>In general, methods that rely on quite restrictive assumptions (eg MCAR), such as <strong>Complete Case Analysis</strong> (CCA), should be avoided as they are likely to bias the results and mislead the CE conclusions. There are some specific situations in which these methods provide valid results, especially in the context of randomised trials <span class="citation" data-cites="white2005adjusting white2010bias">(<a href="#ref-white2005adjusting" role="doc-biblioref">White and Thompson 2005</a>; <a href="#ref-white2010bias" role="doc-biblioref">White and Carlin 2010</a>)</span>, but their implementation should be clearly justified. Similarly, methods that replace the missing outcome data with a single value (eg mean or last value observed), referred to as <strong>Single Imputation</strong> (SI) approaches, should be avoided as they often make very restrictive and hard to interpret assumptions about the missingness mechanism that are unlikely to lead to plausible inferences.</p>
<p>Currently, the most recommended approach to deal with missing CE outcome data in trial-based analyses is <strong>Multiple Imputation</strong> (MI), often implemented under its version known as <em>multiple imputation by chained equations</em> or MICE <span class="citation" data-cites="van2012flexible">(<a href="#ref-van2012flexible" role="doc-biblioref">Van Buuren and Van Buuren 2012</a>)</span>. A series of factors contributed to the success of MICE within the CEA community, which include: possibility to obtain inferences under different mechanisms’ assumptions for each variable; correct representation of missingness uncertainty under the selected assumptions through the specification of an imputation model for each variable; handling of missing values in multiple non-normally distributed and correlated variables. Because of the popularity of MICE and its characteristics making it quite handy for implementation in trial-based CEA, in the next sections I will focus on this approach and show some examples on how it can be implemented in <code>R</code>.</p>
<section id="data-generation-4" class="level2">
<h2 class="anchored" data-anchor-id="data-generation-4">Data generation</h2>
<p>The following (folded) code is simply used to generate some artificial CEA data for exemplary purposes to demonstrate how MICE may be conducted in <code>R</code>. If not of interest, you may skip the folded code and jump to the actual implementation code in the next section. In this simulation I will make things easy and generate data assuming normal distributions and limited number of covariate data. However, the implementation of the methods shown in the following sections is general and can be applied to more realistic data too.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate data and missing under different mechanisms</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co">#set up parameter values to generate data</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>n_full <span class="ot">&lt;-</span> <span class="dv">250</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>mu_x1 <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>sd_x1 <span class="ot">&lt;-</span> <span class="fl">0.15</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>x1_data <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n_full, mu_x1, sd_x1) <span class="co">#simulate covariate values</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>n_full <span class="ot">&lt;-</span> <span class="dv">250</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>mu_x2 <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>sd_x2 <span class="ot">&lt;-</span> <span class="dv">25</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>x2_data <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n_full, mu_x2, sd_x2) <span class="co">#simulate covariate values</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>p_trt <span class="ot">&lt;-</span> <span class="fl">0.5</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>trt_data <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(n_full, p_trt, <span class="at">size =</span> <span class="dv">1</span>)<span class="co">#simulate trt indicator</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>beta0_data <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>beta1_data <span class="ot">&lt;-</span> <span class="fl">0.15</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>beta2_data <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate outcome values</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>y1_data <span class="ot">&lt;-</span> beta0_data <span class="sc">+</span> beta1_data<span class="sc">*</span>trt_data <span class="sc">+</span> beta2_data<span class="sc">*</span>x1_data <span class="sc">+</span> <span class="fu">rnorm</span>(n_full, <span class="dv">0</span>, <span class="fl">0.1</span>)</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>alpha0_data <span class="ot">&lt;-</span> <span class="dv">250</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>alpha1_data <span class="ot">&lt;-</span> <span class="dv">35</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>alpha2_data <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>alpha3_data <span class="ot">&lt;-</span> <span class="dv">55</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a><span class="co">#simulate outcome values</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>y2_data <span class="ot">&lt;-</span> alpha0_data <span class="sc">+</span> alpha1_data<span class="sc">*</span>trt_data <span class="sc">+</span> alpha2_data<span class="sc">*</span>x2_data <span class="sc">+</span> alpha3_data<span class="sc">*</span>y1_data <span class="sc">+</span> <span class="fu">rnorm</span>(n_full, <span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a><span class="co">#generate fully-observed datset and assign names to variables</span></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>full.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(y1_data,y2_data,trt_data,x1_data,x2_data)</span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(full.df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"QALY"</span>,<span class="st">"TC"</span>,<span class="st">"trt"</span>,<span class="st">"u"</span>,<span class="st">"c"</span>)</span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>full.df<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(full.df<span class="sc">$</span>trt<span class="sc">==</span><span class="dv">0</span>,<span class="st">"old"</span>,<span class="st">"new"</span>)</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>full.df<span class="sc">$</span>trt <span class="ot">&lt;-</span> <span class="fu">factor</span>(full.df<span class="sc">$</span>trt, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"old"</span>,<span class="st">"new"</span>))</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a><span class="co">#introduce MAR missingness in QALY given u</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(boot)</span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a><span class="co">#set parameter values for mechanisms</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>eta0_mar <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">9</span></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>eta_1_mar <span class="ot">&lt;-</span> <span class="fl">14.5</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a>eta_2_mar <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>eta_3_mar <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>p_mar_e <span class="ot">&lt;-</span> <span class="fu">inv.logit</span>(eta0_mar <span class="sc">+</span> eta_1_mar<span class="sc">*</span>full.df<span class="sc">$</span>u <span class="sc">+</span> eta_2_mar<span class="sc">*</span>full.df<span class="sc">$</span>QALY <span class="sc">+</span> eta_3_mar<span class="sc">*</span><span class="fu">as.numeric</span>(full.df<span class="sc">$</span>trt))</span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>iota0_mar <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">4</span></span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>iota_1_mar <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a>iota_2_mar <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a>iota_3_mar <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb64-46"><a href="#cb64-46" aria-hidden="true" tabindex="-1"></a>p_mar_c <span class="ot">&lt;-</span> <span class="fu">inv.logit</span>(iota0_mar <span class="sc">+</span> iota_1_mar<span class="sc">*</span>full.df<span class="sc">$</span>c<span class="sc">/</span><span class="dv">100</span> <span class="sc">+</span> iota_2_mar<span class="sc">*</span>full.df<span class="sc">$</span>TC <span class="sc">+</span> iota_3_mar<span class="sc">*</span><span class="fu">as.numeric</span>(full.df<span class="sc">$</span>trt))</span>
<span id="cb64-47"><a href="#cb64-47" aria-hidden="true" tabindex="-1"></a><span class="co">#generate missing data indicators (0=observed,1=missing)</span></span>
<span id="cb64-48"><a href="#cb64-48" aria-hidden="true" tabindex="-1"></a>m_mar_e <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(n_full, p_mar_e, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb64-49"><a href="#cb64-49" aria-hidden="true" tabindex="-1"></a>m_mar_c <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(n_full, p_mar_c, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb64-50"><a href="#cb64-50" aria-hidden="true" tabindex="-1"></a>full.mar <span class="ot">&lt;-</span> full.df</span>
<span id="cb64-51"><a href="#cb64-51" aria-hidden="true" tabindex="-1"></a><span class="co">#introduce MAR missing QALY data and distinguish between a variable showing only the observed QALY values (QALY_obs) and another showing only the missing QALY values (QALY_mis)</span></span>
<span id="cb64-52"><a href="#cb64-52" aria-hidden="true" tabindex="-1"></a>full.mar<span class="sc">$</span>m_QALY <span class="ot">&lt;-</span> m_mar_e</span>
<span id="cb64-53"><a href="#cb64-53" aria-hidden="true" tabindex="-1"></a>full.mar<span class="sc">$</span>m_TC <span class="ot">&lt;-</span> m_mar_c</span>
<span id="cb64-54"><a href="#cb64-54" aria-hidden="true" tabindex="-1"></a>full.mar<span class="sc">$</span>QALY_obs <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(full.mar<span class="sc">$</span>m_QALY<span class="sc">==</span><span class="dv">0</span>,full.mar<span class="sc">$</span>QALY,<span class="cn">NA</span>)</span>
<span id="cb64-55"><a href="#cb64-55" aria-hidden="true" tabindex="-1"></a>full.mar<span class="sc">$</span>TC_obs <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(full.mar<span class="sc">$</span>m_TC<span class="sc">==</span><span class="dv">0</span>,full.mar<span class="sc">$</span>TC,<span class="cn">NA</span>)</span>
<span id="cb64-56"><a href="#cb64-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-57"><a href="#cb64-57" aria-hidden="true" tabindex="-1"></a><span class="co">#randomly shuffle rows of the MAR dataset</span></span>
<span id="cb64-58"><a href="#cb64-58" aria-hidden="true" tabindex="-1"></a>full.mar <span class="ot">&lt;-</span> full.mar[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(full.mar)), ]</span>
<span id="cb64-59"><a href="#cb64-59" aria-hidden="true" tabindex="-1"></a><span class="co">#keep only relevant variables and rename them</span></span>
<span id="cb64-60"><a href="#cb64-60" aria-hidden="true" tabindex="-1"></a>dataset.mis <span class="ot">&lt;-</span> full.mar[,<span class="fu">c</span>(<span class="st">"QALY_obs"</span>,<span class="st">"TC_obs"</span>,<span class="st">"trt"</span>,<span class="st">"u"</span>,<span class="st">"c"</span>)]</span>
<span id="cb64-61"><a href="#cb64-61" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(dataset.mis) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"QALY"</span>,<span class="st">"TC"</span>,<span class="st">"trt"</span>,<span class="st">"u"</span>,<span class="st">"c"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can inspect the first few rows of the generated data stored in the <code>R</code> object <code>full.mar</code> to see the variable showing the observed QALY values (<code>QALY</code>) and TC values (<code>TC</code>), which were generated under a MAR mechanism conditional on the fully observed baseline utilities (<code>u</code>) and costs (<code>c</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(dataset.mis, <span class="at">n=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         QALY       TC trt         u         c
34  0.6891580 378.6541 new 0.3518463  91.95314
48  0.8021310       NA new 0.5254678  93.04074
193 0.4477710 455.1781 new 0.2485247 126.63579
188 0.8710712 471.2896 new 0.4307028 110.27430
58  0.7926060       NA new 0.4134793 103.14698
87         NA 458.9715 new 0.6311773 114.55390
135 0.6656135 423.3912 new 0.3820836 132.51559
107 0.6320513 320.8635 new 0.3455197 116.77745</code></pre>
</div>
</div>
<p>We can also manually compute the number of missing QALY and TC values generated in this dataset across treatment groups, corresponding to 61 (24 <span class="math inline">\(\%\)</span>) and 69 (28 <span class="math inline">\(\%\)</span>), respectively.</p>
</section>
<section id="method-application-4" class="level2">
<h2 class="anchored" data-anchor-id="method-application-4">Method application</h2>
<p>Although a variety of missing data methods exist in the general statistical literature <span class="citation" data-cites="schafer2002missing">(<a href="#ref-schafer2002missing" role="doc-biblioref">Schafer and Graham 2002</a>)</span>, here I will exclusively focus on MI as the recommended approach for handling missing outcome CE data, with a focus on its most popular implementation version MICE. Without entering technical details, the general procedure behind MI methods can be summarised in three steps:</p>
<ol type="1">
<li><p>For each missing value, generate a set of <span class="math inline">\(M\)</span> imputed values according to some pre-specified <em>imputation model</em> to guide the imputation process. For each variable, its missing values are replaced with the <span class="math inline">\(m=1\ldots,M\)</span> imputations to create a corresponding set of <span class="math inline">\(M\)</span> completed (observed and imputed) datasets. Elements that need to be defined within said model include: <em>method of imputation</em>; <em>number of imputed values</em> $M; <em>order of imputation</em> in case of multiple missing variables.</p></li>
<li><p>In each imputed dataset <span class="math inline">\(m\)</span>, the analysis model (ie the model used to derive the estimates of interest) is fitted and corresponding estimates <span class="math inline">\(\hat{\beta}_m\)</span> are derived for <span class="math inline">\(m=1,\ldots,M\)</span>. In CEA, typical examples of these models include OLS, SUR, GLM or MLMs.</p></li>
<li><p>The so-called <em>Rubin’s rules</em> <span class="citation" data-cites="little2019statistical">(<a href="#ref-little2019statistical" role="doc-biblioref">Little and Rubin 2019</a>)</span> are used to combine the <span class="math inline">\(M\)</span> parameter estimates derived from fitting the analysis model to the completed datasets into single quantities <span class="math inline">\(\hat{\beta}\)</span>. These rules ensure that the derivation of estimates and related uncertainty measures takes into account missing data uncertainty reflected by the uncertainty associated with the <span class="math inline">\(M\)</span> different imputations for each missing value.</p></li>
</ol>
<p>Compared to standard MI methods, the <strong>MICE</strong> version is particularly appealing when addressing missingness in CEA because it allows a separate imputation model specification for each missing variable in the dataset. This allows to specify imputations models that can directly address the data complexities of each variable (eg skewness, value ranges, association with other variables) within an univariate modelling approach (eg using regression methods). The price to pay for this flexibility is that the overall imputation model involving all missing variables is not theoretically well defined. However, simulation exercises have suggested that, provided the specification of the imputation model for each variable is correct, the derived results are valid under the specified missingness assumptions.</p>
<p>Within MICE, a popular imputation method is the non-parametric <em>predictive mean matching</em> (PMM) approach <span class="citation" data-cites="allison2015imputation">(<a href="#ref-allison2015imputation" role="doc-biblioref">Allison 2015</a>)</span>, consisting in a specific type of resampling procedure that allows to generate imputations using predictive information from other variables and that are always consistent with the observed values for each variable. In addition, it is generally recommended that a sufficiently large number of imputations <span class="math inline">\(M\)</span> is chosen to ensure the validity of MI inferences. Despite different recommendations, in the literature a choice for <span class="math inline">\(M\)</span> closed to the so-called <em>fraction of missing information</em> for a given dataset is often advocated <span class="citation" data-cites="graham2007many carpenter2023multiple">(<a href="#ref-graham2007many" role="doc-biblioref">Graham, Olchowski, and Gilreath 2007</a>; <a href="#ref-carpenter2023multiple" role="doc-biblioref">Carpenter et al. 2023</a>)</span>. In many cases, this quantity is approximated by the overall proportion of missing values. As for the order of imputation of the missing variables, no generally accepted guidelines exist in the literature, with the exception of the general recommendation of applying MI methods separately to each treatment arm in a clinical trial setting.</p>
<p>Depending on the assumed missingness mechanism, specification of the imputation model should change to reflect those assumptions. Often, MAR is suggested as the reference assumption to be taken in the base-case analysis by including as many variables likely associated with the missing data as possible in the imputation model to “improve” the robustness of the results, ie use all available information from the data to inform the imputation process. However, it is important to note that as the imputation model becomes more complex (ie includes more variables), the MICE algorithm (fundamentally a MCMC method) will likely encounter convergence problems and possibly lead to incorrect inferences, especially in the context of very sparse data and high missingness rates. Therefore, care should be used when selecting the variables to include in the imputation model as well as in the selection of which variables should be used to inform the imputation of a given missing variable to minimise chances of incurring in convergence problems. To this purpose, it is generally suggested to perform some preliminary analyses (eg using plots, test or regression methods) to check, for each missing variable, the association between missingness indicators and other variables in the dataset. The results from these analyses can then be used to guide the selection of the variables to include in the imputation model for each missing variable.</p>
<p>In <code>R</code>, the following code may be used to implement MICE (under a MAR assumption) to the generated data and summarise the output. The following MI specification is used: number of imputations <span class="math inline">\(M=30\)</span>; PMM as imputation method for all missing variables (<code>QALY</code> and <code>TC</code>) using corresponding observed baseline values (<code>u</code> and <code>c</code>) as the only variables included in their respective imputation models.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mice) <span class="co">#load package to implement MICE</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">#split data by treatment group (Old and New)</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>dataset.mis_Old <span class="ot">&lt;-</span> dataset.mis[dataset.mis<span class="sc">$</span>trt<span class="sc">==</span><span class="st">"old"</span>,]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>dataset.mis_New <span class="ot">&lt;-</span> dataset.mis[dataset.mis<span class="sc">$</span>trt<span class="sc">==</span><span class="st">"new"</span>,]</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">#set up MICE inputs for old group</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>mice_Old <span class="ot">&lt;-</span> <span class="fu">mice</span>(dataset.mis_Old, <span class="at">print =</span> <span class="cn">FALSE</span>, <span class="at">method =</span> <span class="st">'pmm'</span>, <span class="at">maxit =</span> <span class="dv">0</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>pM_Old <span class="ot">&lt;-</span> mice_Old<span class="sc">$</span>predictorMatrix <span class="co">#extract default predictor matrix</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="co">#customise pred matrix to your needs (row=variable to be imputed, column=variable used as predictor)</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="co">#in the matrix an entry of 1 means that the corresponding column variable is used as predictor for the corresponding row variable</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>pM_Old[<span class="st">"QALY"</span>,<span class="fu">c</span>(<span class="st">"TC"</span>,<span class="st">"u"</span>)] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#require that QALY always imputed using TC and u</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>pM_Old[<span class="st">"QALY"</span>,<span class="fu">c</span>(<span class="st">"c"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that QALY is never imputed using c</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>pM_Old[<span class="st">"TC"</span>,<span class="fu">c</span>(<span class="st">"u"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that TC is never imputed using u</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>pM_Old[,<span class="fu">c</span>(<span class="st">"trt"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that any variable is never imputed using trt</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>meth_Old <span class="ot">&lt;-</span> mice_Old<span class="sc">$</span>method <span class="co">#extract default imputation methods</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a><span class="co">#by default PMM assumed as imputation methods for numeric variables</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="co">#set up MICE inputs for new group</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>mice_New <span class="ot">&lt;-</span> <span class="fu">mice</span>(dataset.mis_New, <span class="at">print =</span> <span class="cn">FALSE</span>, <span class="at">method =</span> <span class="st">'pmm'</span>, <span class="at">maxit =</span> <span class="dv">0</span>)</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>pM_New <span class="ot">&lt;-</span> mice_New<span class="sc">$</span>predictorMatrix <span class="co">#extract default predictor matrix</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>pM_New[<span class="st">"QALY"</span>,<span class="fu">c</span>(<span class="st">"TC"</span>,<span class="st">"u"</span>)] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="co">#require that QALY always imputed using TC and u</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>pM_New[<span class="st">"QALY"</span>,<span class="fu">c</span>(<span class="st">"c"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that QALY is never imputed using c</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>pM_New[<span class="st">"TC"</span>,<span class="fu">c</span>(<span class="st">"u"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that TC is never imputed using u</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>pM_New[,<span class="fu">c</span>(<span class="st">"trt"</span>)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co">#require that any variable is never imputed using trt</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>meth_New <span class="ot">&lt;-</span> mice_New<span class="sc">$</span>method <span class="co">#extract default imputation methods</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="dv">30</span> <span class="co">#number of imputations</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a><span class="co">#set rng for reproducibility</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2345</span>)</span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a><span class="co">#implement MICE to old and new group</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>mice_Old_fit <span class="ot">&lt;-</span> <span class="fu">mice</span>(dataset.mis_Old, <span class="at">predictorMatrix =</span> pM_Old, <span class="at">method=</span>meth_Old, <span class="at">m =</span> M, <span class="at">print =</span> <span class="cn">FALSE</span>)</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>mice_New_fit <span class="ot">&lt;-</span> <span class="fu">mice</span>(dataset.mis_New, <span class="at">predictorMatrix =</span> pM_New, <span class="at">method=</span>meth_New, <span class="at">m =</span> M, <span class="at">print =</span> <span class="cn">FALSE</span>)</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a><span class="co">#combine the imputed datasets across groups</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>mice_fit <span class="ot">&lt;-</span> <span class="fu">rbind</span>(mice_Old_fit, mice_New_fit)</span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a><span class="co">#lme_mice_data &lt;- with(mice_data, lm(QALY_obs ~ trt + u))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The object <code>mice_fit</code> contains the results of the MICE imputation algorithm, which was implemented separately by treatment group for QALY and TC variables according to the imputation model specification given above. It is generally a good idea to check the results generated using the function <code>mice</code> to make sure that no general problems occurred in the algorithm convergence or no implausible imputations were generated for all variables. For example, we can check for possible convergence problems using the <code>plot</code> function which, when applied to a <code>mice</code> object, produces the following plot</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(mice_fit, <span class="at">y=</span><span class="fu">c</span>(<span class="st">"QALY"</span>,<span class="st">"TC"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="code_files/figure-html/unnamed-chunk-42-1.png" class="img-fluid figure-img" width="480"></p>
</figure>
</div>
</div>
</div>
<p>which shows the convergence pattern of mean and standard deviation statistics for QALY and TC variables with respect to each of the 30 imputed values (lines) across the algorithm iterations (default set to <span class="math inline">\(5\)</span> but can be modified within <code>mice</code> using the argument <code>maxit</code>). Overall, a random pattern like the one shown in this case suggests that no evident convergence problems seem to affect the imputed variables. We can also look at the density distribution of the imputed values and compare it to that of the observed data for each imputed variable using the function <code>densityplot</code> (usually helpful for numeric variables), which produces the following plot.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">densityplot</span>(mice_fit, <span class="sc">~</span> QALY<span class="sc">+</span> TC<span class="sc">|</span>trt, <span class="at">layout=</span><span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="code_files/figure-html/unnamed-chunk-43-1.png" class="img-fluid figure-img" width="480"></p>
</figure>
</div>
</div>
</div>
<p>The argument <code>~ QALY+ TC|trt</code> is used to specify to display the results for the two outcome variables <em>conditional</em> on the treatment indicator values, i.e.&nbsp;within the two subgroups for the old and new arm. Many others diagnostic measures and plots are available in <code>mice</code> to check the generated imputations. For a general overview of how to implement these and other customisation options available for objects generated through <code>mice</code> I recommend checking out this <a href="https://stefvanbuuren.name/fimd/">online and freely available book version</a> of the MICE developer.</p>
<p>After checking the results of MICE, we can now proceed to fit the analysis model to each completed dataset to derive <span class="math inline">\(M\)</span> estimates for the parameters of interest. In our case, we are interested in retrieving estimates for the mean QALY/TC in each treatment group and for the mean incrementals. The <code>mice</code> function is quite flexible and is compatible with many different <code>R</code> functions that fit different types of statistical methods, including OLS, SUR, GLM and MLM. In this simulated study, we fit standard OLS regression models to each outcome for demonstrative purposes. We achieve this by using the function <code>with</code> which allows to fit the desired models (specified as its second argument) within each completed dataset contained in the object <code>mice_fit</code> (specified as its first argument)</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co">#fit QALY and TC model in each completed dataset and store results</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>lm_mice_e <span class="ot">&lt;-</span> <span class="fu">with</span>(mice_fit, <span class="fu">lm</span>(QALY <span class="sc">~</span> trt <span class="sc">+</span> u))</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>lm_mice_c <span class="ot">&lt;-</span> <span class="fu">with</span>(mice_fit, <span class="fu">lm</span>(TC <span class="sc">~</span> trt <span class="sc">+</span> c))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The generated objects <code>lm_mice_e</code> and <code>lm_mice_c</code> contain the <span class="math inline">\(M\)</span> different parameter estimates of the OLS regressions fitted to each completed dataset stored in <code>mice_fit</code>. Pooled estimates for these parameters across the <span class="math inline">\(M\)</span> values, obtained using Rubin’s rules, can be generated by using the <code>pool</code> function. For example, for the QALY model, we can obtain and summarise the pooled point and uncertainty estimates for all model parameters by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">#pool regression results across imputations for QALY model</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>pool_lm_mice_e <span class="ot">&lt;-</span> <span class="fu">pool</span>(lm_mice_e)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pool_lm_mice_e, <span class="at">conf.int =</span> <span class="cn">TRUE</span>, <span class="at">conf.level =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>         term  estimate  std.error statistic        df
1 (Intercept) 0.1871130 0.02662999  7.026402 127.39204
2      trtnew 0.1621742 0.01518626 10.679011 111.26219
3           u 1.0105077 0.05340866 18.920298  94.03143
                                     p.value     2.5 %    97.5 %  conf.low
1 0.0000000001139214095370705727883371694009 0.1344186 0.2398074 0.1344186
2 0.0000000000000000009451108771931596269286 0.1320824 0.1922660 0.1320824
3 0.0000000000000000000000000000000008031831 0.9044640 1.1165514 0.9044640
  conf.high
1 0.2398074
2 0.1922660
3 1.1165514</code></pre>
</div>
</div>
<p>Given that in CEA we are interested in estimates for the mearginal means of each outcome and their difference between treatment groups, we can use the function <code>emmeans</code> from the package <code>emmean</code> to compute these quantities based on the MICE output in generated before. This can be done for each outcome by typing</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans) <span class="co">#load package to compute marginal means</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">#obtain marginal means for QALY and TC across imputations</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>em_lm_mice_e_ctr <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(lm_mice_e, <span class="sc">~</span> trt)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>em_lm_mice_c_ctr <span class="ot">&lt;-</span> <span class="fu">emmeans</span>(lm_mice_c, <span class="sc">~</span> trt)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>em_lm_mice_e_ctr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> trt emmean      SE  df lower.CL upper.CL
 old  0.681 0.00973 140    0.662    0.701
 new  0.844 0.01140 103    0.821    0.866

Confidence level used: 0.95 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>em_lm_mice_c_ctr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> trt emmean   SE  df lower.CL upper.CL
 old    394 4.67 131      384      403
 new    430 5.00 150      420      439

Confidence level used: 0.95 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">#take difference as - Old + New = New - Old</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>new_vs_old <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"New vs Old"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">#compute linear combinations to get incremental estimates</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>lm_mice_delta_e <span class="ot">&lt;-</span> <span class="fu">contrast</span>(em_lm_mice_e_ctr, new_vs_old) </span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>lm_mice_delta_c <span class="ot">&lt;-</span> <span class="fu">contrast</span>(em_lm_mice_c_ctr, new_vs_old) </span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="co">#obtain results in terms of confidence intervals</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="fu">confint</span>(lm_mice_delta_e, <span class="at">level =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> contrast   estimate     SE  df lower.CL upper.CL
 New vs Old    0.162 0.0152 111    0.132    0.192

Confidence level used: 0.95 </code></pre>
</div>
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">confint</span>(lm_mice_delta_c, <span class="at">level =</span> <span class="fl">0.95</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> contrast   estimate   SE  df lower.CL upper.CL
 New vs Old     35.9 6.54 178       23     48.8

Confidence level used: 0.95 </code></pre>
</div>
</div>
<p>Here I stop myself from discussing possible extensions of MI to be integrated with other approaches that I showed before, eg combine MI with bootstrapping or with methods to handle clustering (perhaps this can be explored another time). One of the reasons is also because combination of MI with bootstrapping or other non-standard analysis methods can be very challenging and clear guidelines about the performance of the methods when combined together is still lacking <span class="citation" data-cites="schomaker2018bootstrap brand2019combining">(<a href="#ref-schomaker2018bootstrap" role="doc-biblioref">Schomaker and Heumann 2018</a>; <a href="#ref-brand2019combining" role="doc-biblioref">Brand et al. 2019</a>)</span>. This is particularly problematic for CEA, where the additional complexities of the data should be taken into account while also being able to handle missingness uncertainty.</p>
</section>
<section id="summary-4" class="level2">
<h2 class="anchored" data-anchor-id="summary-4">Summary</h2>
<p>In CEA practice, simple but likely biased and inappropriate methods for handling missing data (eg CCA) have been historically implemented. In addition, many reviews highlighted a generally poor reporting practice about missing data information (eg amount, pattern, etc.) and, even more importantly, a lack of clarity about the methods adopted to generate the results and conclusions of the studies <span class="citation" data-cites="noble2012missing diaz2014handling leurent2018missing">(<a href="#ref-noble2012missing" role="doc-biblioref">Noble, Hollingworth, and Tilling 2012</a>; <a href="#ref-diaz2014handling" role="doc-biblioref">Dı́az-Ordaz, Kenward, and Grieve 2014</a>; <a href="#ref-leurent2018missing" role="doc-biblioref">Leurent, Gomes, and Carpenter 2018</a>)</span>. Only in recent years, a gradual movement towards more advanced and appropriate missing data methods (eg MI) seems to have occurred, although there is still a general lack of implementation details about these methods <span class="citation" data-cites="gabrio2017handling ling2022scoping">(<a href="#ref-gabrio2017handling" role="doc-biblioref">Gabrio, Mason, and Baio 2017</a>; <a href="#ref-ling2022scoping" role="doc-biblioref">Ling et al. 2022</a>)</span>.</p>
<p>While the uptaking of more appropriate methods to handle missingness is encouraging, it is important to report in a transparent and clear way how these methods were used in a specific analysis since statistical and CE results can be quite sensitive to the specific modelling or imputation strategies chosen. As an example, MAR as the “benchmark” (and often only) assumption in CEA is routinely selected, which in many cases may be sensible and genuinely reflect the assumptions of the analysts about the missingness mechanism under consideration. However, the plausibility of any missingness assumption, including MAR, can never be checked from the data and therefore it is extremely important that some form of <strong>sensitivity analyses</strong> is conducted to assess the robustness of the study results to departures from MAR. Within an MI framework in CEA, different MNAR imputation strategies have developed to achieve this task <span class="citation" data-cites="leurent2018sensitivity leurent2020reference">(<a href="#ref-leurent2018sensitivity" role="doc-biblioref">Leurent et al. 2018</a>, <a href="#ref-leurent2020reference" role="doc-biblioref">2020</a>)</span>. In the wider missing data CEA literature, alternative approaches have also been proposed to handle missingness using more flexible methods, such as <em>Bayesian models</em>, that naturally lend themselves to the incorporation of external evidence (eg expert opinion or informed guess) into the analysis and assess the robustness of the results to MNAR assumptions <span class="citation" data-cites="mason2018bayesian gabrio2019full">(<a href="#ref-mason2018bayesian" role="doc-biblioref">Mason et al. 2018</a>; <a href="#ref-gabrio2019full" role="doc-biblioref">Gabrio, Mason, and Baio 2019</a>)</span>.</p>
<p>Finally, throughout this document I have exclusively focussed on implementing different statistical methods at the level of aggregated CE variables in a study, ie QALYs and TCs, which are usually computed based on the values of different components (ie utilities and costs) collected at different time points during the study period. An alternative analysis approach would be to focus on the disaggregated CE components and implement different statistical methods to analyse these variables instead, which has already been done in the literature <span class="citation" data-cites="mason2021flexible gabrio2020bayesian gabrio2021joint ben2023conducting">(<a href="#ref-mason2021flexible" role="doc-biblioref">Mason et al. 2021</a>; <a href="#ref-gabrio2020bayesian" role="doc-biblioref">Gabrio, Daniels, and Baio 2020</a>; <a href="#ref-gabrio2021joint" role="doc-biblioref">Gabrio et al. 2021</a>; <a href="#ref-ben2023conducting" role="doc-biblioref">Ben, Dongen, El Alili, et al. 2023</a>)</span>. While, in principle, shifting the focus of the analysis to aggregated variables is more convenient from a modelling perspective (ie less number of variables and their interactions to model), in practice, this is no longer true when some missingness occurs at the disaggregated level. Indeed, when some missing outcome values occur at one or multiple time points during the study, information about these partially-observed variables is lost when the objective of the analysis is moved at the more aggregated level. This is likely to be a major concern for those CE outcomes that are affected by so-called <em>item-level missingness</em>, where patients fill in only a part of the questionnaire answers, which is quite common for resource use instruments (used to compute costs). When this occurs, then implementing an analysis model at the most disaggregated data level (eg resource use answers or costs at each time point in the study) allows a more efficient use of the observed data collected, which would be instead at least partially lost by modelling at more aggregated data levels <span class="citation" data-cites="ben2023handling">(<a href="#ref-ben2023handling" role="doc-biblioref">Ben, Dongen, Alili, et al. 2023</a>)</span>. However, implementation of models at the level of disaggregated CE components is very challenging unless relying on standard normality and independence methods’ assumptions. This is because: appropriate <em>missingness methods</em> need to be combined with adequate <em>methods to handle the typical CE data complexities</em> (correlation, skewness, clustering) within a more complex multivariate modelling framework while also generating correct bootstrapped estimates for the quantities of interest to produce standard CEA output.</p>
</section>
</section>
<section id="references" class="level1 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-achana2021multivariate" class="csl-entry" role="listitem">
Achana, Felix, Daniel Gallacher, Raymond Oppong, Sungwook Kim, Stavros Petrou, James Mason, and Michael Crowther. 2021. <span>“Multivariate Generalized Linear Mixed-Effects Models for the Analysis of Clinical Trial–Based Cost-Effectiveness Data.”</span> <em>Medical Decision Making</em> 41 (6): 667–84.
</div>
<div id="ref-allison2015imputation" class="csl-entry" role="listitem">
Allison, Paul. 2015. <span>“Imputation by Predictive Mean Matching: Promise &amp; Peril.”</span> <em>Statistical Horizons</em>.
</div>
<div id="ref-baio2014bayesian" class="csl-entry" role="listitem">
Baio, Gianluca. 2014. <span>“Bayesian Models for Cost-Effectiveness Analysis in the Presence of Structural Zero Costs.”</span> <em>Statistics in Medicine</em> 33 (11): 1900–1913.
</div>
<div id="ref-barber2000analysis" class="csl-entry" role="listitem">
Barber, Julie A, and Simon G Thompson. 2000. <span>“Analysis of Cost Data in Randomized Trials: An Application of the Non-Parametric Bootstrap.”</span> <em>Statistics in Medicine</em> 19 (23): 3219–36.
</div>
<div id="ref-barber2004multiple" class="csl-entry" role="listitem">
Barber, Julie, and Simon Thompson. 2004. <span>“Multiple Regression of Cost Data: Use of Generalised Linear Models.”</span> <em>Journal of Health Services Research &amp; Policy</em> 9 (4): 197–204.
</div>
<div id="ref-ben2023handling" class="csl-entry" role="listitem">
Ben, Ângela Jornada, Johanna M van Dongen, Mohamed El Alili, Martijn W Heymans, Jos WR Twisk, Janet L MacNeil-Vroomen, Maartje de Wit, Susan EM van Dijk, Teddy Oosterhuis, and Judith E Bosmans. 2023. <span>“The Handling of Missing Data in Trial-Based Economic Evaluations: Should Data Be Multiply Imputed Prior to Longitudinal Linear Mixed-Model Analyses?”</span> <em>The European Journal of Health Economics</em> 24 (6): 951–65.
</div>
<div id="ref-ben2023conducting" class="csl-entry" role="listitem">
Ben, Ângela Jornada, Johanna M van Dongen, Mohamed El Alili, Jonas L Esser, Hana Marie Broulı́ková, and Judith E Bosmans. 2023. <span>“Conducting Trial-Based Economic Evaluations Using r: A Tutorial.”</span> <em>Pharmacoeconomics</em> 41 (11): 1403–13.
</div>
<div id="ref-black1990plane" class="csl-entry" role="listitem">
Black, William C. 1990. <span>“The CE Plane: A Graphic Representation of Cost-Effectiveness.”</span> <em>Medical Decision Making</em> 10 (3): 212–14.
</div>
<div id="ref-brand2019combining" class="csl-entry" role="listitem">
Brand, Jaap, Stef van Buuren, Saskia le Cessie, and Wilbert van den Hout. 2019. <span>“Combining Multiple Imputation and Bootstrap in the Analysis of Cost-Effectiveness Trial Data.”</span> <em>Statistics in Medicine</em> 38 (2): 210–20.
</div>
<div id="ref-briggs1999constructing" class="csl-entry" role="listitem">
Briggs, Andrew H, Christopher Z Mooney, and David E Wonderling. 1999. <span>“Constructing Confidence Intervals for Cost-Effectiveness Ratios: An Evaluation of Parametric and Non-Parametric Techniques Using Monte Carlo Simulation.”</span> <em>Statistics in Medicine</em> 18 (23): 3245–62.
</div>
<div id="ref-briggs1997pulling" class="csl-entry" role="listitem">
Briggs, Andrew H, David E Wonderling, and Christopher Z Mooney. 1997. <span>“Pulling Cost-Effectiveness Analysis up by Its Bootstraps: A Non-Parametric Approach to Confidence Interval Estimation.”</span> <em>Health Economics</em> 6 (4): 327–40.
</div>
<div id="ref-brooks2011handbook" class="csl-entry" role="listitem">
Brooks, Steve, Andrew Gelman, Galin Jones, and Xiao-Li Meng. 2011. <em>Handbook of Markov Chain Monte Carlo</em>. CRC press.
</div>
<div id="ref-carpenter2023multiple" class="csl-entry" role="listitem">
Carpenter, James R, Jonathan W Bartlett, Tim P Morris, Angela M Wood, Matteo Quartagno, and Michael G Kenward. 2023. <em>Multiple Imputation and Its Application</em>. John Wiley &amp; Sons.
</div>
<div id="ref-conigliani2009bayesian" class="csl-entry" role="listitem">
Conigliani, Caterina, and Andrea Tancredi. 2009. <span>“A Bayesian Model Averaging Approach for Cost-Effectiveness Analyses.”</span> <em>Health Economics</em> 18 (7): 807–21.
</div>
<div id="ref-diaz2014handling" class="csl-entry" role="listitem">
Dı́az-Ordaz, K, Michael G Kenward, and Richard Grieve. 2014. <span>“Handling Missing Values in Cost Effectiveness Analyses That Use Data from Cluster Randomized Trials.”</span> <em>Journal of the Royal Statistical Society Series A: Statistics in Society</em> 177 (2): 457–74.
</div>
<div id="ref-drummond2015methods" class="csl-entry" role="listitem">
Drummond, Michael F, Mark J Sculpher, Karl Claxton, Greg L Stoddart, and George W Torrance. 2015. <em>Methods for the Economic Evaluation of Health Care Programmes</em>. Oxford university press.
</div>
<div id="ref-el2022scoping" class="csl-entry" role="listitem">
El Alili, Mohamed, Johanna M van Dongen, Jonas L Esser, Martijn W Heymans, Maurits W van Tulder, and Judith E Bosmans. 2022. <span>“A Scoping Review of Statistical Methods for Trial-Based Economic Evaluations: The Current State of Play.”</span> <em>Health Economics</em> 31 (12): 2680–99.
</div>
<div id="ref-faria2014guide" class="csl-entry" role="listitem">
Faria, Rita, Manuel Gomes, David Epstein, and Ian R White. 2014. <span>“A Guide to Handling Missing Data in Cost-Effectiveness Analysis Conducted Within Randomised Controlled Trials.”</span> <em>Pharmacoeconomics</em> 32 (12): 1157–70.
</div>
<div id="ref-fenwick2001representing" class="csl-entry" role="listitem">
Fenwick, Elisabeth, Karl Claxton, and Mark Sculpher. 2001. <span>“Representing Uncertainty: The Role of Cost-Effectiveness Acceptability Curves.”</span> <em>Health Economics</em> 10 (8): 779–87.
</div>
<div id="ref-gabrio2020bayesian" class="csl-entry" role="listitem">
Gabrio, Andrea, Michael J Daniels, and Gianluca Baio. 2020. <span>“A Bayesian Parametric Approach to Handle Missing Longitudinal Outcome Data in Trial-Based Health Economic Evaluations.”</span> <em>Journal of the Royal Statistical Society Series A: Statistics in Society</em> 183 (2): 607–29.
</div>
<div id="ref-gabrio2021joint" class="csl-entry" role="listitem">
Gabrio, Andrea, Rachael Hunter, Alexina J Mason, and Gianluca Baio. 2021. <span>“Joint Longitudinal Models for Dealing with Missing at Random Data in Trial-Based Economic Evaluations.”</span> <em>Value in Health</em> 24 (5): 699–706.
</div>
<div id="ref-gabrio2017handling" class="csl-entry" role="listitem">
Gabrio, Andrea, Alexina J Mason, and Gianluca Baio. 2017. <span>“Handling Missing Data in Within-Trial Cost-Effectiveness Analysis: A Review with Future Recommendations.”</span> <em>PharmacoEconomics-Open</em> 1 (2): 79–97.
</div>
<div id="ref-gabrio2019full" class="csl-entry" role="listitem">
———. 2019. <span>“A Full Bayesian Model to Handle Structural Ones and Missingness in Economic Evaluations from Individual-Level Data.”</span> <em>Statistics in Medicine</em> 38 (8): 1399–1420.
</div>
<div id="ref-glick2014economic" class="csl-entry" role="listitem">
Glick, Henry A, Jalpa A Doshi, Seema S Sonnad, and Daniel Polsky. 2014. <em>Economic Evaluation in Clinical Trials</em>. OUP Oxford.
</div>
<div id="ref-gomes2013multiple" class="csl-entry" role="listitem">
Gomes, Manuel, Karla Dı́az-Ordaz, Richard Grieve, and Michael G Kenward. 2013. <span>“Multiple Imputation Methods for Handling Missing Data in Cost-Effectiveness Analyses That Use Data from Hierarchical Studies: An Application to Cluster Randomized Trials.”</span> <em>Medical Decision Making</em> 33 (8): 1051–63.
</div>
<div id="ref-gomes2012methods" class="csl-entry" role="listitem">
Gomes, Manuel, Richard Grieve, Richard Nixon, Edmond S-W Ng, James Carpenter, and Simon G Thompson. 2012. <span>“Methods for Covariate Adjustment in Cost-Effectiveness Analysis That Use Cluster Randomised Trials.”</span> <em>Health Economics</em> 21 (9): 1101–18.
</div>
<div id="ref-gomes2012developing" class="csl-entry" role="listitem">
Gomes, Manuel, Edmond S-W Ng, Richard Grieve, Richard Nixon, James Carpenter, and Simon G Thompson. 2012. <span>“Developing Appropriate Methods for Cost-Effectiveness Analysis of Cluster Randomized Trials.”</span> <em>Medical Decision Making</em> 32 (2): 350–61.
</div>
<div id="ref-graham2007many" class="csl-entry" role="listitem">
Graham, John W, Allison E Olchowski, and Tamika D Gilreath. 2007. <span>“How Many Imputations Are Really Needed? Some Practical Clarifications of Multiple Imputation Theory.”</span> <em>Prevention Science</em> 8 (3): 206–13.
</div>
<div id="ref-grieve2010bayesian" class="csl-entry" role="listitem">
Grieve, Richard, Richard Nixon, and Simon G Thompson. 2010. <span>“Bayesian Hierarchical Models for Cost-Effectiveness Analyses That Use Data from Cluster Randomized Trials.”</span> <em>Medical Decision Making</em> 30 (2): 163–75.
</div>
<div id="ref-indurkhya2006using" class="csl-entry" role="listitem">
Indurkhya, Alka, Nandita Mitra, and Deborah Schrag. 2006. <span>“Using Propensity Scores to Estimate the Cost–Effectiveness of Medical Therapies.”</span> <em>Statistics in Medicine</em> 25 (9): 1561–76.
</div>
<div id="ref-lambert2008estimating" class="csl-entry" role="listitem">
Lambert, Paul C, Lucinda J Billingham, Nicola J Cooper, Alex J Sutton, and Keith R Abrams. 2008. <span>“Estimating the Cost-Effectiveness of an Intervention in a Clinical Trial When Partial Cost Information Is Available: A Bayesian Approach.”</span> <em>Health Economics</em> 17 (1): 67–81.
</div>
<div id="ref-leurent2018missing" class="csl-entry" role="listitem">
Leurent, Baptiste, Manuel Gomes, and James R Carpenter. 2018. <span>“Missing Data in Trial-Based Cost-Effectiveness Analysis: An Incomplete Journey.”</span> <em>Health Economics</em> 27 (6): 1024–40.
</div>
<div id="ref-leurent2020reference" class="csl-entry" role="listitem">
Leurent, Baptiste, Manuel Gomes, Suzie Cro, Nicola Wiles, and James R Carpenter. 2020. <span>“Reference-Based Multiple Imputation for Missing Data Sensitivity Analyses in Trial-Based Cost-Effectiveness Analysis.”</span> <em>Health Economics</em> 29 (2): 171–84.
</div>
<div id="ref-leurent2018sensitivity" class="csl-entry" role="listitem">
Leurent, Baptiste, Manuel Gomes, Rita Faria, Stephen Morris, Richard Grieve, and James R Carpenter. 2018. <span>“Sensitivity Analysis for Not-at-Random Missing Data in Trial-Based Cost-Effectiveness Analysis: A Tutorial.”</span> <em>Pharmacoeconomics</em> 36 (8): 889–901.
</div>
<div id="ref-ling2022scoping" class="csl-entry" role="listitem">
Ling, Xiaoxiao, Andrea Gabrio, Alexina Mason, and Gianluca Baio. 2022. <span>“A Scoping Review of Item-Level Missing Data in Within-Trial Cost-Effectiveness Analysis.”</span> <em>Value in Health</em> 25 (9): 1654–62.
</div>
<div id="ref-little2019statistical" class="csl-entry" role="listitem">
Little, Roderick JA, and Donald B Rubin. 2019. <em>Statistical Analysis with Missing Data</em>. John Wiley &amp; Sons.
</div>
<div id="ref-manca2005estimating" class="csl-entry" role="listitem">
Manca, Andrea, Neil Hawkins, and Mark J Sculpher. 2005. <span>“Estimating Mean QALYs in Trial-Based Cost-Effectiveness Analysis: The Importance of Controlling for Baseline Utility.”</span> <em>Health Economics</em> 14 (5): 487–96.
</div>
<div id="ref-manca2005handling" class="csl-entry" role="listitem">
Manca, Andrea, and Stephen Palmer. 2005. <span>“Handling Missing Data in Patient-Level Cost-Effectiveness Analysis Alongside Randomised Clinical Trials.”</span> <em>Applied Health Economics and Health Policy</em> 4 (2): 65–75.
</div>
<div id="ref-marshall2009can" class="csl-entry" role="listitem">
Marshall, Andrea, Lucinda J Billingham, and Stirling Bryan. 2009. <span>“Can We Afford to Ignore Missing Data in Cost-Effectiveness Analyses?”</span> <em>The European Journal of Health Economics</em> 10 (1): 1–3.
</div>
<div id="ref-mason2021flexible" class="csl-entry" role="listitem">
Mason, Alexina J, Manuel Gomes, James Carpenter, and Richard Grieve. 2021. <span>“Flexible Bayesian Longitudinal Models for Cost-Effectiveness Analyses with Informative Missing Data.”</span> <em>Health Economics</em> 30 (12): 3138–58.
</div>
<div id="ref-mason2018bayesian" class="csl-entry" role="listitem">
Mason, Alexina J, Manuel Gomes, Richard Grieve, and James R Carpenter. 2018. <span>“A Bayesian Framework for Health Economic Evaluation in Studies with Missing Data.”</span> <em>Health Economics</em> 27 (11): 1670–83.
</div>
<div id="ref-nederland2024guideline" class="csl-entry" role="listitem">
Nederland, Zorginstituut. 2024. <span>“Guideline for Economic Evaluations in Healthcare (2024 Version).”</span> <em>Zorginstituut Nederland: Diemen</em>.
</div>
<div id="ref-ng2016multilevel" class="csl-entry" role="listitem">
Ng, Edmond SW, Karla Diaz-Ordaz, Richard Grieve, Richard M Nixon, Simon G Thompson, and James R Carpenter. 2016. <span>“Multilevel Models for Cost-Effectiveness Analyses That Use Cluster Randomised Trial Data: An Approach to Model Choice.”</span> <em>Statistical Methods in Medical Research</em> 25 (5): 2036–52.
</div>
<div id="ref-nixon2005methods" class="csl-entry" role="listitem">
Nixon, Richard M, and Simon G Thompson. 2005. <span>“Methods for Incorporating Covariate Adjustment, Subgroup Analysis and Between-Centre Differences into Cost-Effectiveness Evaluations.”</span> <em>Health Economics</em> 14 (12): 1217–29.
</div>
<div id="ref-nixon2010non" class="csl-entry" role="listitem">
Nixon, Richard M, David Wonderling, and Richard D Grieve. 2010. <span>“Non-Parametric Methods for Cost-Effectiveness Analysis: The Central Limit Theorem and the Bootstrap Compared.”</span> <em>Health Economics</em> 19 (3): 316–33.
</div>
<div id="ref-noble2012missing" class="csl-entry" role="listitem">
Noble, Sian Marie, William Hollingworth, and Kate Tilling. 2012. <span>“Missing Data in Trial-Based Cost-Effectiveness Analysis: The Current State of Play.”</span> <em>Health Economics</em> 21 (2): 187–200.
</div>
<div id="ref-o2001framework" class="csl-entry" role="listitem">
O’Hagan, Anthony, and John W Stevens. 2001. <span>“A Framework for Cost-Effectiveness Analysis from Clinical Trial Data.”</span> <em>Health Economics</em> 10 (4): 303–15.
</div>
<div id="ref-o2003assessing" class="csl-entry" role="listitem">
———. 2003. <span>“Assessing and Comparing Costs: How Robust Are the Bootstrap and Methods Based on Asymptotic Normality?”</span> <em>Health Economics</em> 12 (1): 33–49.
</div>
<div id="ref-schafer2002missing" class="csl-entry" role="listitem">
Schafer, Joseph L, and John W Graham. 2002. <span>“Missing Data: Our View of the State of the Art.”</span> <em>Psychological Methods</em> 7 (2): 147.
</div>
<div id="ref-schomaker2018bootstrap" class="csl-entry" role="listitem">
Schomaker, Michael, and Christian Heumann. 2018. <span>“Bootstrap Inference When Using Multiple Imputation.”</span> <em>Statistics in Medicine</em> 37 (14): 2252–66.
</div>
<div id="ref-sekhon2012matching" class="csl-entry" role="listitem">
Sekhon, Jasjeet Singh, and Richard D Grieve. 2012. <span>“A Matching Method for Improving Covariate Balance in Cost-Effectiveness Analyses.”</span> <em>Health Economics</em> 21 (6): 695–714.
</div>
<div id="ref-stinnett1998net" class="csl-entry" role="listitem">
Stinnett, Aaron A, and John Mullahy. 1998. <span>“Net Health Benefits: A New Framework for the Analysis of Uncertainty in Cost-Effectiveness Analysis.”</span> <em>Medical Decision Making</em> 18 (2_suppl): S68–80.
</div>
<div id="ref-thompson2000should" class="csl-entry" role="listitem">
Thompson, Simon G, and Julie A Barber. 2000. <span>“How Should Cost Data in Pragmatic Randomised Trials Be Analysed?”</span> <em>Bmj</em> 320 (7243): 1197–1200.
</div>
<div id="ref-thompson2005sensitive" class="csl-entry" role="listitem">
Thompson, Simon G, and Richard M Nixon. 2005. <span>“How Sensitive Are Cost-Effectiveness Analyses to Choice of Parametric Distributions?”</span> <em>Medical Decision Making</em> 25 (4): 416–23.
</div>
<div id="ref-van2009deal" class="csl-entry" role="listitem">
Van Asselt, Antoinette DI, Ghislaine APG Van Mastrigt, Carmen D Dirksen, Arnoud Arntz, Johan L Severens, and Alfons GH Kessels. 2009. <span>“How to Deal with Cost Differences at Baseline.”</span> <em>Pharmacoeconomics</em> 27 (6): 519–28.
</div>
<div id="ref-van2012flexible" class="csl-entry" role="listitem">
Van Buuren, Stef, and Stef Van Buuren. 2012. <em>Flexible Imputation of Missing Data</em>. Vol. 10. CRC press Boca Raton, FL.
</div>
<div id="ref-white2010bias" class="csl-entry" role="listitem">
White, Ian R, and John B Carlin. 2010. <span>“Bias and Efficiency of Multiple Imputation Compared with Complete-Case Analysis for Missing Covariate Values.”</span> <em>Statistics in Medicine</em> 29 (28): 2920–31.
</div>
<div id="ref-white2005adjusting" class="csl-entry" role="listitem">
White, Ian R, and Simon G Thompson. 2005. <span>“Adjusting for Partially Missing Baseline Measurements in Randomized Trials.”</span> <em>Statistics in Medicine</em> 24 (7): 993–1007.
</div>
<div id="ref-willan2004regression" class="csl-entry" role="listitem">
Willan, Andrew R, Andrew H Briggs, and Jeffrey S Hoch. 2004. <span>“Regression Methods for Covariate Adjustment and Subgroup Analysis for Non-Censored Cost-Effectiveness Data.”</span> <em>Health Economics</em> 13 (5): 461–75.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>